設計
===

Catalog微服務採用分層架構，自上往下分為：

* 展示層。以RESTFul風格向外曝露Catalog支持的領域模型和操作，以JSON格式接受和迴應領域模型內容。
* 業務邏輯層，處理應用相關的業務邏輯，比如填充createdAt和updatedAt。
* 數據訪問層，處理Java object和具體存儲實體之間的映射轉換，實現橧刪改查等存儲訪問操作。

[plantuml,catalog-design,png]
....
@startuml
package "Catalog Service" {
    REST - [Presentation Layer]
    [Presentation Layer] --> [Business Logic Layer]: <<call>>
    [Business Logic Layer] --> [Data Access Layer]: <<call>>
}

database datastore

[Data Access Layer] --> datastore
@enduml
....

這𥚃我們採用Spring Data REST實現展現層；供助Spring Data REST開放的實體事件擴展機制，實現業務邏輯；數據存儲方案選用MongoDB；數據訪問層採用Spring Data MongoDB實現。

== 理解 Lombok

[quote, Lombok, https://projectlombok.org]
____
Lombok項目是一個Java庫，它會自動插入您的編輯器和構建工具中，從而使您的Java更加生動有趣。
永遠不要再寫另一個getter或equals方法，帶有一個註釋的您的類有一個功能全面的生成器，自動化您的日誌記錄變量等等。
____

[quote, Lombok Execution Path, https://projectlombok.org/contributing/lombok-execution-path]
____
使用javac（以及netbeans，maven，gradle和大多數其他構建系統）時，lombok作為註釋處理器運行。

Lombok在classpath中，且javac將在它可以找到的類路徑上加載每個`META-INF/services/javax.annotation.processing.Processor`文件，讀取每一行並加載該類，然後將其作為註釋處理器執行。`lombok.jar`有此文件，它將`lombok.launch.AnnotationProcessorHider$AnnotationProcessor`列為條目。
____

Lombok實現為注解處理器「Annotation Processor」，在編譯期被Java編譯器調用，掃描代碼，讀取Lombok注解及關鍵詞標注的類，並執行相應的代碼轉換。

== 理解 REST

[quote, Representational State Transfer, https://en.wikipedia.org/wiki/Representational_state_transfer]
____
代表性狀態轉移（REST）是一種軟件體系結構樣式，它定義了一組用於創建Web服務的約束。 符合REST體系結構樣式的Web服務（稱為RESTful Web服務）提供Internet上計算機系統之間的互操作性。 RESTful Web服務允許請求系統通過使用統一且預定義的無狀態操作集來訪問和操縱Web資源的文本表示。 其他類型的Web服務（例如SOAP Web服務）公開其自己的任意操作集。
____

RESTFul Web服務有以下特性：

* 以資源為中心，領域模型在RESTFul API中表現為資源，所有的業務操作都表現為對資源的操作。
* 重用HTTP請求方法。以HTTP請求方法表逹對資源的操作。HTTP協議中定義了九種請求方法：
+
|===
|Method|Description

|GET
|GET方法請求指定資源的表示形式。 使用GET的請求應僅檢索數據。

|HEAD
|HEAD方法請求的響應與GET請求的響應相同，但沒有響應主體。

|POST
|POST方法用於將實體提交給指定的資源，通常會導致狀態更改或對服務器產生副作用。

|PUT
|PUT方法用請求有效負載替換目標資源的所有當前表示形式。

|DELETE
|DELETE方法刪除指定的資源。

|CONNECT
|CONNECT方法建立到由目標資源標識的服務器的隧道。

|OPTIONS
|OPTIONS方法用於描述目標資源的通信選項。

|TRACE
|TRACE方法沿到目標資源的路徑執行消息環回測試。

|PATCH
|PATCH方法用於對資源進行部分修改。
|===
+
RESTFul 主要重用其中的POST、DELETE、PUT和GET來分別表逹增、刪、改和查操作。
* 重用HTTP嚮應狀態碼。重用HTTP嚮應狀態碼來表逹請求的處理結果。HTTP協議定義了五類嚮應狀態碼
+
.. 信息性的嚮應（100-199）
.. 成功的嚮應（200-299）
.. 重定向（300-399）
.. 客戶端錯誤（400-499）
.. 服務端錯誤（500-599）
+
常用的嚮應狀態碼有：
+
|===
|Code|說明

|200 OK
|該請求已成功。

|201 Created
|請求成功，並因此創建了新資源。 這通常是在POST請求或某些PUT請求之後發送的響應。當使用POST請求訪問RESTFul API創建新資源實體後，應返迴嚮應狀態碼200。

|204 No Content
|沒有要發送的內容，但標頭可能有用。 用戶代理可以使用新的代理更新該資源的緩存頭。當使用PUT請求訪問RESTFul API更新資源實體且未在嚮應報文中包含更新後的實體，應使用嚮應狀態碼204。

|400 Bad Request
|由於語法無效，服務器無法理解該請求。

|401 Unauthorized
|儘管HTTP標準指定“未經授權”，但從語義上講，此響應表示“未經驗證”。 也就是說，客戶端必須對自己進行身份驗證才能獲得請求的響應。

|403 Forbidden
|客戶端無權訪問內容； 也就是說，它是未經授權的，因此服務器拒絕提供所請求的資源。 與401不同，服務器知道客戶端的身份。

|404 Not Found
|服務器找不到請求的資源。 在瀏覽器中，這意味著無法識別URL。 在API中，這也可能意味著端點有效，但是資源本身不存在。 服務器也可以發送此響應而不是403，以隱藏來自未授權客戶端的資源。 由於此響應代碼在網絡上經常出現，因此可能是最著名的響應代碼。

|405 Method Not Allowed
|服務器知道該請求方法，但已被禁用，無法使用。比如針對祗讀資源的寫請求（POST、DELETE、PUT），RESTFul API可以嚮應此狀態碼。

|415 Unsupported Media Type
|服務器不支持所請求數據的媒體格式，因此服務器拒絕了該請求。

|500 Internal Server Error
|服務器遇到了不知道如何處理的情況。任何業務邏輯的錯誤都不應該嚮應該狀態碼。祗有真正無法處理或恢復的失效，比如依賴服務不可用等，才可以嚮應該狀態碼。
|===

=== Product RESTFul Web API

REST Web服務以資源為中心，把領域模型Product直接映射為資源product，所以資源product的根URL就為`/products`。因為從語義上講，對資源根URL的操作，如GET、POST，都是作用於資源集合而非單個資源實體，所以使用復數形式更為恰當。（很多人認為使用單數形式是最佳實踐，因為英文名詞的復數形式規則並不統一且大部份人英文不好，硬用復數形式容易出現拚寫錯誤）

|===
|操作|URL|HTTP方法

|創建新Product
|/products
|POST

|更新Product
|/products/<productId>
|PUT

|更新與ProductImage之間的關聯
|/products/<productId>/images
|PUT

|移除Product
|/products/<productId>
|DELETE

|讀取單個Product
|/products/<productId>
|GET

|分頁讀取所有Product
|/products?page=<pageIndex>&size=<pageSize>
|GET

|讀取Product關聯的ProductImage
|/products/<productId>/images
|GET
|===

=== ProductImage RESTFul API

|===
|操作|URL|HTTP方法

|創建新ProductImage
|/productImages
|POST

|更新ProductImage
|/productImages/<productImageId>
|PUT

|移除ProductImage
|/productImages/<productImageId>
|DELETE

|讀取單個ProductImage
|/productImages/<productImageId>
|GET

|分頁讀取所有ProductImage
|/productImages?page=<pageIndex>&size=<pageSize>
|GET
|===

== 理解 JSON

[quote,介紹JSON,https://www.json.org/json-zh.html]
____
JSON(JavaScript Object Notation) 是一種輕量級的數據交換格式。易於人閱讀和編寫。同時也易於機器解析和生成。它基於JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一個子集。 JSON採用完全獨立於語言的文本格式，但是也使用了類似於C語言家族的習慣（包括C, C++, C#, Java, JavaScript, Perl, Python等）。這些特性使JSON成為理想的數據交換語言。

JSON建構於兩種結構：

* “名稱/值”對的集合（A collection of name/value pairs）。不同的語言中，它被理解為對象（object），紀錄（record），結構（struct），字典（dictionary），哈希表（hash table），有鍵列表（keyed list），或者關聯數組（associative array）。
* 值的有序列表（An ordered list of values）。在大部分語言中，它被理解為數組（array）。
____

JSON是一種面嚮字符的、編程語言獨立的、易於人和機器讀寫的數據交換格式。使用JSON作為RESTFul Web服務與消費者之間交換實體內容的數據格格，可以最大限度地提升Web服務的兼容性。但需要注意，JSON是面嚮文本的數據交換格式，所有類型的數據都必須被編碼為文本形式，所以JSON並不適用二進制數據的交換，比如圖像、音頻、視頻。

[NOTE]
====
關於JSON的規範定義，請參閱 http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf[ECMA-404 The JSON Data Interchange Standard]
====

== 理解 Hypermedia-Driven

Hypermedia指代所有包含指向其它媒體（如圖像、視頻和文本等）的鏈接的內容。Hypermedia-Driven的RESTFul Web服務則是指在請求體和嚮應體的內容為Hypermedia。

HATEOAS（Hypermedia as the Engine of Application State）是一組附加在RESTFul風格架構之上的約束，其旨在約束Hypermedia-Driven RESTFul Web服務。HATEOAS沒有嚴格的定義，各個框架都有自己的實現。但大多數HATEOAS實現都參考了以下規範：

* https://tools.ietf.org/html/rfc5988[RFC 5988 Web Linking]
* https://en.wikipedia.org/wiki/Hypertext_Application_Language[Hypertext Application Language]

== 理解 Spring Data REST

[quote,https://spring.io/projects/spring-data-rest]
____
Spring Data REST是Spring Data的一部份，其致力於簡化在Spring Data repository之上構建**超媒體驅動「hypermedia-driven」** REST web微務。

Spring Data REST 構建於 Spring Data repository 之上，分析你的應用領域模型且曝露超媒體驅動HTTP資源。
____

Spring Framework 本身提供了Spring MVC。借助Spring MVC，可以快速構造RESTFul web服務。再加上Spring HATEOAS，就可以構建超媒體驅動的RESTFul web服務了。但是RESTFul web服務是以資源為中心，其為每類資源實現一組有限的動作，如POS創建、PUT更新、DELETE移除。直接使用Spring MVC構建RESTFul web服務會造成很多模板代碼。Spring Data REST就是為了避免使用Spring MVC構建RESTFul web服務時產生冗餘模板代碼而被創造出來。Spring Data REST分析應用中的repository，分揀出領域模型和增刪改查方法，分別曝露為相應的RESTFul URLs.

Spring Data REST 開放出了八個實體事件，應用開發者可以注入自定義的事件監聽器以實現業務邏輯處理。Spring Data REST會釋放出以下八種事件：

* `BeforeCreateEvent`
* `AfterCreateEvent`
* `BeforeSaveEvent`
* `AfterSaveEvent`
* `BeforeDeleteEvent`
* `AfterDeleteEvent`
* `BeforeLinkSaveEvent`
* `AfterLinkSaveEvent`
* `BeforeLinkDeleteEvent`
* `AfterLinkDeleteEvent`

==== `BeforeCreateEvent` and `AfterCreateEvent`

Spring Data REST在創建實體實例時，會釋放出`BeforeCreateEvent`和`AfterCreateEvent`。

.RepositoryEntityController.java
[source, java]
----
...
private ResponseEntity<ResourceSupport> createAndReturn(Object domainObject, RepositoryInvoker invoker,
		PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeCreateEvent(domainObject)); <1>
	Object savedObject = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterCreateEvent(savedObject)); <2>

	...
}
...
----
<1> 在調用repository方法將創建的實體持久化至存儲服務之前，釋放出事件`BeforeCreateEvent`
<2> 在調用repository方法將創建的實體持久化至存儲服務之後，釋放出事件`AfterCreateEvent`

POST和PUT請求都有可能觸發實體的創建。POST在REST語義中就是創建新實體，所以POST請求肯定會觸發實體創建。

.RepositoryEntityController.java
[source, java]
----
...
@ResponseBody
@RequestMapping(value = BASE_MAPPING, method = RequestMethod.POST)
public ResponseEntity<ResourceSupport> postCollectionResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, PersistentEntityResourceAssembler assembler,
		@RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	resourceInformation.verifySupportedMethod(HttpMethod.POST, ResourceType.COLLECTION);

	return createAndReturn(payload.getContent(), resourceInformation.getInvoker(), assembler,
			config.returnBodyOnCreate(acceptHeader)); <1>
}
...
----

PUT請求在REST語義中是更新實體，但若要求更新的目標實體不存在，則更新操作就自動轉化為創建操作。所以，當使用PUT請求更新不存在的實體時，會觸發實體創建。

.RepositoryEntityController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity<? extends ResourceSupport> putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <1>
}
...
----
<1> 若請求創建的實體是新建的即目標實體不存在，則更新請求轉化為創建操作。

==== `BeforeSaveEvent` and `AfterSaveEvent`

Spring Data REST在更新實體時會釋放出`BeforeSaveEvent`和`AfterSaveEvent`。

.RepositoryEntityController.java
[source, java]
----
...
private ResponseEntity<ResourceSupport> saveAndReturn(Object domainObject, RepositoryInvoker invoker,
		HttpMethod httpMethod, PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeSaveEvent(domainObject)); <1>
	Object obj = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterSaveEvent(obj)); <2>

	...
}
...
----
<1> 在調用repository方法將更新的實體持久化至存儲服務之前，釋放出事件`BeforeSaveEvent`
<2> 在調用repository方法將更新的實體持久化至存儲服務之後，釋放出事件`AfterCreateEvent`

PUT和PATCH請求都會觸發實體更新操作。

.RepositoryEntityController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity<? extends ResourceSupport> putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

    ...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <1>
}
...
----
<1> 當請求更新的目標實體存在時，PUT請求觸發更新操作。

.RepositoryEntityController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PATCH)
public ResponseEntity<ResourceSupport> patchItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {

	...

	return saveAndReturn(domainObject, resourceInformation.getInvoker(), PATCH, assembler,
			config.returnBodyOnUpdate(acceptHeader)); <1>
}
...
----

. PATCH請求祗能觸發實體更新。

=== `BeforeDeleteEvent` 和 `AfterDeleteEvent`

Spring Data REST在移除實體時會釋放出事件`BeforeDeleteEvent`和`AfterDeleteEvent`。

.RepositoryEntityController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.DELETE) // <1>
public ResponseEntity<?> deleteItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id,
		ETag eTag) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {

	...
	
	return domainObj.map(it -> {

		PersistentEntity<?, ?> entity = resourceInformation.getPersistentEntity();

		eTag.verify(entity, it);

		publisher.publishEvent(new BeforeDeleteEvent(it)); // <2>
		invoker.invokeDeleteById(entity.getIdentifierAccessor(it).getIdentifier());
		publisher.publishEvent(new AfterDeleteEvent(it)); // <3>

		return new ResponseEntity<Object>(HttpStatus.NO_CONTENT);

	}).orElseThrow(() -> new ResourceNotFoundException());
}
...
----
<1> 針對實體的DELETE請求會觸發實體移除操作。
<2> 在將實體從存儲服務中移除之前，釋放出事件`BeforeDeleteEvent`。
<3> 在將實體從存儲服務中移除之後，釋放出事件`AfterDeleteEvent`。

=== `BeforeLinkSaveEvent` 和 `AfterLinkSaveEvent`

Spring Data REST在創建和變更實體關聯時會釋放出`BeforeLinkSaveEvent`和`AfterLinkSaveEvent`。

.RepositoryPropertyReferenceController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING, method = { PATCH, PUT, POST }, // <1>
		consumes = { MediaType.APPLICATION_JSON_VALUE, SPRING_DATA_COMPACT_JSON_VALUE, TEXT_URI_LIST_VALUE })
public ResponseEntity<? extends ResourceSupport> createPropertyReference(RootResourceInformation resourceInformation,
		HttpMethod requestMethod, @RequestBody(required = false) Resources<Object> incoming, @BackendId Serializable id,
		@PathVariable String property) throws Exception {

	...

	Function<ReferencedProperty, ResourceSupport> handler = prop -> {

        ...

		publisher.publishEvent(new BeforeLinkSaveEvent(prop.accessor.getBean(), prop.propertyValue)); // <2>
		Object result = invoker.invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkSaveEvent(result, prop.propertyValue)); // <3>

		return null;
	};

	doWithReferencedProperty(resourceInformation, id, property, handler, requestMethod);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...
----
<1> PATCH、PUT或POST請求鏈接（LINK）類型的實體屬性都會觸發實體鏈接屬性的創建或變更。
<2> 在將鏈接屬性變更持久化至存儲服務之前，釋放出`BeforeLinkSaveEvent`。
<3> 在將鏈接屬性變更持久化至存儲服務之後，釋放出`AfterLinkSaveEvent`。

=== `BeforeLinkDelete` 和 `AfterLinkDelete`

Spring Data REST在移除實體之間的關聯（LINK）時，會釋放出`BeforeLinkDeleteEvent`和`AfterLinkDeleteEvent`。

.RepositoryPropertyReferenceController.java
[source, java]
----
...
@RequestMapping(value = BASE_MAPPING, method = DELETE) // <1>
public ResponseEntity<? extends ResourceSupport> deletePropertyReference(RootResourceInformation repoRequest,
		@BackendId Serializable id, @PathVariable String property) throws Exception {

	Function<ReferencedProperty, ResourceSupport> handler = prop -> prop.mapValue(it -> {

		...

		publisher.publishEvent(new BeforeLinkDeleteEvent(prop.accessor.getBean(), prop.propertyValue)); // <2>
		Object result = repoRequest.getInvoker().invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkDeleteEvent(result, prop.propertyValue)); // <3>

		return (ResourceSupport) null;

	}).orElse(null);

	doWithReferencedProperty(repoRequest, id, property, handler, HttpMethod.DELETE);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...
----
<1> 目標為鏈接類型的實體屬性的DELETE請求會觸發實體關聯移除操作。
<2> 在將實體關聯移除持久化至存儲服務之前，釋放出事件`BeforeLinkDeleteEvent`。
<3> 在將實體關聯移除持久化至存儲服務之後，釋放出事件`AfterLinkDeleteEvent`。

=== 注入事件處理器

應用開發者可以自定義事件處理器，再使用注解將自定義事件處理器注刪為事件監聽器。Spring Data REST提供了十個注解分別對應上述十個實體事件：

* `@HandleBeforCreate`
* `@HandleAfterCreate`
* `@HandleBeforeSave`
* `@HandleAfterSave`
* `@HandleBeforeDelete`
* `@HandleAfterDelete`
* `@HandleBeforeLinkSave`
* `@HandleAfterLinkSave`
* `@HandleBeforeLinkDelete`
* `@HandleAfterLinkDelete`

== 理解 MongoDB

[quote, What Is MongoDB, https://www.mongodb.com/what-is-mongodb]
____
MongoDB是一個文檔數據庫，具有所需的可伸縮性和靈活性，可用於所需的查詢和索引編制。

* MongoDB將數據存儲在類似於JSON的靈活文檔中，這意味著字段隨文檔的不同而不同，並且數據結構可以隨時間而變化
* 文檔模型映射到應用程序代碼中的對象，從而使數據易於使用
* 臨時查詢，索引編制和實時聚合提供了訪問和分析數據的強大方法
* MongoDB以分佈式數據庫為核心，因此內置了高可用性，水平擴展和地理分佈並且易於使用
* MongoDB是免費使用的。 在AGPL下發布了2018年10月16日之前發布的版本。 2018年10月16日之後發布的所有版本（包括先前版本的修補程序修補程序）均根據服務器端公共許可證（SSPL）v1發布。
____

MongoDB是schema-free的數據庫，其非常適用於同一類別數據結構會隨時間較頻繁變動（增加屬性、減少屬性等）的應用場景。Catalog服務所維護的數據就符合這一特徵。

== 理解 Spring Data MongoDB

[quote,https://spring.io/projects/spring-data]
____
Spring Data的任務是為數據訪問提供一個熟悉且一致的基於Spring的編程模型，同時仍保留基礎數據存儲的特殊特徵。
____

[quote,https://spring.io/projects/spring-data-mongodb]
____
Spring Data MongoDB是Spring Data項目的一部分，該項目旨在為新數據存儲提供熟悉且一致的基於Spring的編程模型，同時保留特定於存儲的功能。

Spring Data MongoDB項目提供了與MongoDB文檔數據庫的集成。 Spring Data MongoDB的關鍵功能區域是一個以POJO為中心的模型，該模型用於與MongoDB DBCollection進行交互並輕鬆編寫存儲庫樣式的數據訪問層。
____

Spring Data的核心模式是倉庫設計模式「Repository Design Pattern」。
倉庫設計模式最早由Eric Evens在他的著作《Domain Driven Design》中提出，其核心概念是倉庫「Repository」。倉庫在業務邏輯層與數據源之間扮演着中間人的⻆色，其解耦了業務邏輯層和數據源，使用業務邏輯層無需關心具體數據源的接口或任何接口變更，甚至無需任何業務邏輯層的代碼變更就可以遷移至不同的數據源上。

[plantuml, repository-pattern, png]
....
@startuml
[Business Logic] --> [Repository]
database Oracle
database MySQL
database MongoDB
database HBase
[Repository] ..> Oracle
[Repository] ..> MySQL
[Repository] ..> MongoDB
[Repository] ..> HBase
@enduml
....

Spring Data提供的核心接口就是`Repository`。應用開發者祗需聲明專用於領域模型的、繼承`Repository`的倉庫接口，針對特定存儲服務實現的Spring Data模塊（如Spring Data MongoDB）會構造相應的倉庫實現Bean。

Spring Data除了`Repository`之外，還提供了其它倉庫接口。這些倉庫口提供了常用的數據訪問操作:

* `org.springframework.data.repository.CrudRepository` 提供了基本的增刪改查操作
* `org.springframework.data.repository.PagingAndSortingRepository` 添加了分頁和排序功能
* `org.springframework.data.repository.query.QueryByExampleExecutor` 提供了相似查詢功能，應用可以按照業務邏輯定義相似算法，查詢相似（不完全相同，或主鍵相同）的實體

[plantuml, repository-interface, png]
....
@startuml
interface Repository<T, ID>
interface CrudRepository<T, ID> {
    save<S extends T>(entity: S): S
    saveAll<S extends T>(entities: Iterable< S>): Iterable<S>
    findById(id: ID): Optional<T>
    existsById(id: ID): boolean
    findAll(): Iterable<T>
    findAllById(Iterable<ID> ids): Iterable<T>
    count(): long
    deleteById(id: ID)
    delete(entity: T)
    deleteAll(entities: Iteable<? extends T>)
    deleteAll()
}
interface PagingAndSortingRepository<T, ID> {
    findAll(sort: Sort): Iterable<T>
    findAll(pageable: Pageable): Page<T>
}
interface QueryByExampleExecutor<T> {
    findOne<S extends T>(example: Example<S>): Optional<S>
    findlAll<S extends T>(example: Example<S>): Iterable<S>
    findAll<S extends T>(example: Example>S>, sort: Sort): Iterable<S>
    findAll<S extends T>(example: Example<S>, pageable: Pageable)
    count<S extends T>(example: Example<S>): long
    exists<S extends T>(example: Example<S>): boolean
}
Repository <|-- CrudRepository
CrudRepository <|-- PagingAndSortingRepository
@enduml
....

Spring Data MongoDB在Spring Data Commons提供的倉庫接口基礎上，還擴展了`org.springframework.data.mongodb.repository.MongoRepository`。

[plantuml, spring-data-mongodb-repository, png]
....
@startuml
interface PagingAndSortingRepository<T, ID>
interface QueryByExampleExecutor<T>
interface MongoRepository<T, ID> {
    {override} save<S extends T>(entities: Iterable< S>): List<S>
    {override} saveAll<S extends T>(entities: Iterable< S>): List<S>
    {override} findAll(): List<T>
    {override} findAll(sort: Sort): List<T>
    insert<S extends T>(entity: S): S
    insert<S extends T>(entities: Iterable< S>):
    {override} findAll<S extends T>(example: Example<S>): List<S>
    {override} findAll<S extends T>(example: Example<S>, sort: Sort): List<S>
}

PagingAndSortingRepository <|-- MongoRepository
QueryByExampleExecutor <|-- MongoRepository
@enduml
....

== 理解JUnit

TBD

== 理解Spring MVC Test Framework

[quote, Spring MVC Test Framework, https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#spring-mvc-test-framework]
____
Spring MVC測試框架提供了一流的支持，可使用可與JUnit，TestNG或任何其他測試框架一起使用的流暢API測試Spring MVC代碼。 它基於spring-test模塊的Servlet API mock objects構建，因此不使用正在運行的Servlet容器。
____

Spring MVC Test框架通過`DispatcherServlet`與Spring MVC代碼直接通信，無需運行Servlet容器。且測試代碼與被測試代碼（服務端代碼）運行在同一個JVM中，所以不僅可以驗證服務端代碼的輸出還可以驗證服務端代碼的內部狀態，即支持服務端代碼的白盒測試。

[plantuml, spring-mvc-architecture, png]
....
@startuml
node ClientSide {
    [browser]
}
[browser] -> HTTP: request/response
node ServerSide {
    frame ServletContainer {
        HTTP - [dispatcherServlet]
        [dispatcherServlet] --> [controller]: dispatch request
    }
}

@enduml
....

在生產環境中，`dispatcherServlet`和`controller`都運行在`Servlet`容器中（Spring Boot應用是內嵌Servlet容器），並通過Servlet容器嚮外曝露HTTP服務。客户端應用（Web瀏器、原生應用等）通過HTTP協議訪問Servlet容器，Servlet容器將請求轉化為`HttpServletRequest`交由`dispatcherServlet`；`dispatcherServlet`再分發給對應的controller。

[plantuml, mockmvc-archotecture, png]
....
@startuml
frame JVM {
    [mockMvc] - [dispatcherServlet]
    [dispatcherServlet] --> [controller]: dispatch request
}
@endnuml
....

Spring MVC Test框架則通過MockMvc（Servlet API mock objects）直接與`dispatcherServlet`通信。我們的測試目標是應用上下文配置和controller及其調用的其它Beans，Servlet容器並不是我們的測試目標（因為它們的代碼不是我們寫的）。使用這種測試方法可以最大限度地排除第三方代碼，僅關注於應用代碼的測試。

== 理解Spring REST Docs

[quote, Spring REST Docs, https://spring.io/projects/spring-restdocs]
____
Spring REST Docs可幫助您記錄RESTful服務。

它結合了用Asciidoctor編寫的手寫文檔和Spring MVC Test生成的自動生成的代碼片段。 這種方法使您擺脫了Swagger之類的工具所產生的文檔限制。

它可以幫助您生成準確，簡潔且結構合理的文檔。 然後，該文檔可讓您的用戶以最少的麻煩獲得他們所需的信息。
____

Spring REST Docs致力於幫助應用開發者生成準確且可讀的RESTFul服務文檔。Spring REST Docs借助測試生成的HTTP請求和响應內容片斷，再組合手工編寫的Asciidoc或Markdown文本，產生HTML格式的文檔。文檔的生成依賴測試的通過。所以當測測未通過時，文檔也不會被生成，從而避免成生與實現不符的文檔。

[graphviz, spring-rest-docs-process, png]
....
digraph d {
  test [shape=box]
  snippets [shape=note]
  test -> snippets
  asciidoc [shape=note, label="*.adoc\l*.asciidoc\l*.ad\l*.asc\l"]
  asciidoctor [shape=box]
  html [shape=note, label=HTML]
  asciidoc -> asciidoctor
  snippets -> asciidoctor
  asciidoctor -> html

  {rank=same;asciidoc,asciidoctor,html}
}
....

Spring REST Docs可以從由Spring MVC Test框架、Spring WebFlux's `WebTestClient`和REST Assured 3編寫的測試中截取HTTP請求和响應片斷。

應用開發者編寫asciidoc文檔（以.adoc, .asciidoc, .ad, .asc山大弓火後綴的），引用Spring REST Docs在測試階段截取的片斷。Asciidoctor讀取asciidoc文檔和請求响應片斷，轉換生成HTML格式的可閱讀文檔（Asciidoctor還支持其它輸出格式，如PDF、EPUB等）。

作為Spring REST Docs的核心，其提供了豐富的HTTP請求响應片斷截取和注釋功能。所有這些截取注釋功能都實現為`org.springframework.restdocs.snippet.Snippet`的實現類，應用開發者通過構造方法穫取這些Snippet實現類實例。

[plantuml, http-message, png]
....
@startuml
class Request {
	Request Line
	--
	Header Fields
	--
	Message Body
}
class Response {
	Status Line
	--
	Header Fields
	--
	Message Body
}
@enduml
....
