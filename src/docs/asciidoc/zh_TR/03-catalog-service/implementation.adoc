實現
====

== Product

=== 領域模型

利用Lombok編譯期生成getter/setter方法，減少重復的模板代碼。

使用Spring Data MongoDB提供的注解描述java類與MongoDB集合、java字段與MongoDB字段之間的映射關系。Spring Data MongoDB會根據映射關系生成對應的Repository實現。

.Product.java
[source,java]
----
@Getter <1>
@Setter <2>
@Document <3>
public class Product {

  @Id <4>
  private String id;
  private String title;
  private List<String> tags;
  @DBRef <5>
  private List<ProductImage> images;
  private Date createdAt;
  private Date updatedAt;
}
----
<1> `lombok.Getter`。Lombok會在編譯期掃描類，為以@Getter注解標注的類中所有成員字段生成getter訪問器。比如針對字段`private String id`，其生成了相當與以下源代碼的Getter訪問器：
+
[source,java]
----
public String getId() {
    return this.id;
}
----
+
為了使使用Gradle構建項目也可處理Lombok注解、生成相應訪問器，我們需要在`build.gradle`中顯式引入Lombok插件：
+
.build.gradle
[source,groovy]
----
plugins {
	...
	id "io.freefair.lombok" version "4.1.5" <1>
	...
}
...
----

<2> `lombok.Setter`。Lombok會在編譯期掃描類，為以@Setter注解標注的類中所有成員字段生成Setter訪問器。比如針對字段`private String id`，其生成了相當與以下代碼的Setter訪問器：
+
[source,java]
....
public void setId(String id) {
    this.id = id;
}
....

<3> 注解`org.springframework.data.mongodb.core.mapping.Document`將一個Java類映射到MongoDB的某個Collection。在MongoDB中，Collection是Document的集合。在Java中，Class是Object的模板，"從某個Class實例出來的Object"是一個Object的集合。所以，在Java Class/Object與MongoDB Collection/Document映射關系中，Class對應Collection，Object對應Document。而Object中的字段對應Document中的字段。
+
[plantuml]
....
digraph d {
    rankdir=LR
    l [shape=record, label="<a>@Document\lpublic class Product \{\l|<b>  @Id\l  private String id;\l|<c>  private String title;\l|<d>  private List\<String\> tags;\l|<e>  @DBRef\l  private List\<ProductImage\> images;|<f>  private Date createdAt;\l|<g>  private Date updatedAt;\l|\}\l"]

    m [shape=record, label="<a>object product:Product \{\l|<b>id = \"5db3a5385cb95ce6e56a9248\"\l|<c>title = \"iMac\"\l|<d>tags = [\"mac\", \"apple\"]\l|<e>images = [objectA, objectB]\l|<f>createdAt = 2019-10-26T01:45:28.703Z\l|<g>updatedAt = 2019-11-03T09:31:00.103Z\l|\}\l"]

    r [shape=record, label="<a>\{\l|<b>	\"_id\" : ObjectId(\"5db3a5385cb95ce6e56a9248\"),\l|<c>	\"title\" : \"iMac\",\l|<d>	\"tags\" : [\l		\"mac\",\l		\"apple\"\l	],\l|<e>	\"images\" : [\l		DBRef(\"productImage\", ObjectId(\"5dabf9ab5cb95c4dad891a95\")),\l		DBRef(\"productImage\", ObjectId(\"5dabf9a05cb95c4dad891a94\")),\l	],\l|<f>	\"createdAt\" : ISODate(\"2019-10-26T01:45:28.703Z\"),\l|<g>	\"updatedAt\" : ISODate(\"2019-11-03T09:31:00.103Z\"),\l|	\"_class\" : \"io.github.rscai.microservices.catalog.model.Product\"\l\}\l"]

    l:b -> m:b -> r:b
    l:c -> m:c -> r:c
    l:d -> m:d -> r:d
    l:e -> m:e -> r:e
    l:f -> m:f -> r:f
    l:g -> m:g -> r:g
}
....
+
其實例object映射為MongoDB中的一個docuemnt。object中的每一個屬性映射為document中的一個字段。比如，object中的字段`id`映射為Mongo document中的字段`id`；object中的字段`title`映射為Mongo document中的字段`title`；object中的字段`tags`映射為Mongo document中的字段`tags`。
<3> @Id `org.springframework.data.annotation.Id` 將對象中的字段`id`映射為文檔的主鍵`id`。
<4> @DBRef `org.springframework.data.mongodb.core.mapping.DBRef` 將對象中的字段`images`映射為一組`com.mongodb.DBRef`。`com.mongodb.DBRef`是指嚮另一個文檔的引用。`@DBRef`可用以標注簡單字段或集合字段。

Spring Data MongoDB提供的映射注解：

|===
|注解|作用目標|說明

|@Id
|字段
|指明該字段是主鍵。

|@MongoId
|字段
|指明該字段是主鍵，與@Id不同的是其接受一個可選的參數`FieldType`用以自定義變換。

|@Document
|類
|指明該類是要映射至數據庫的。同時可以指定對應的collection名穪。

|@DBRef
|字段
|指明該字段會被映射為`com.mongodb.DBRef`。

|@Indexed
|字段
|描述該字段上的索引。

|@CompoundIndex
|類
|描述聯合索引。

|@GeoSpatialIndexed
|字段
|描述該字段上的地理索引。

|@TextIndexed
|字段
|描述該字段上的文本索引。

|@HashIndexed
|字段
|聲明該字段上的HASH索引以用於分片集群上分區數據。

|@Language
|字段
|為文本索引設置語言屬性。

|@Transient
|字段
|默認所有私有字段都被映射到Mongo文檔，該注解可以顯式指明不映射該字段。

|@PersistenceConstructor
|構造器
|指明在從數據庫實例化對象時使用該構造器。構造器的實參則按名穪從數據庫文檔中穫取。

|@Value
|構造器參數
|顯式聲明構造器參數所對應的文檔字段。

|@Field
|字段
|顯式描述字段映射，包括對應文檔中字段的名穪和類型。

|@Version
|字段
|指明該字段將作為樂觀鎖定「Optimistic Locking」機制中的版本屬性，在保存變更之前都會先檢查版本值是否為所期望的。其初始值為`0`，每次變更都會自動加`1`。
|===

==== 倉庫Repository

`Repository`是Spring Data抽象的中心接口。應用開發者以`Repository`子接口的形式聲明模型Repository及其需支持的數據訪問方法，Spring Data的具體數據存儲模塊（本例中是Spring Data MongoDB）將會為其生成相應的實現類。由於這些實現類僅包含模板代碼，所以自動生成可以大幅減少應用開發者重復工作。

.ProductRepository
[source,java]
----
@RepositoryRestResource(collectionResourceRel = "products", path = "products")
public interface ProductRepository extends MongoRepository<Product, String> { // <1>

}
----
<1> 為模型Product創建專屬的ProductRepository接口，繼承至`org.springframework.data.mongodb.repository.MongoRepository`. `MongoRepository`繼承了接口`PagingAndSortingRepository`，Spring Data MongoDB會其生成一個支持增刪改查及分頁排序的MongoDB訪問實現類。因為`ProductRepository`除了繼承的方法聲明外，沒有聲明其它方法，所以Spring Data MongoDB就會直接使用通用的實現類`org.springframework.data.mongodb.repository.support.SimpleMongoRepository<T, ID>`做為其實現。

=== RESTful Web服務

Spring Data REST 是Spring Data的一部份，旨於簡化在Spring Data倉庫上構建hypermedia-driven REST Web服務。應用開發者僅需在依賴中引入`spring-boot-starter-data-rest`，再聲明領域模型的倉庫，Spring Data REST就會將其發佈為 Hypermedia-Driven REST Web服務。

.build.gradle
[source, groovy]
----
...
dependencies {
    ...
    implementation 'org.springframework.boot:spring-boot-starter-data-rest' // <1>
    ...
}
...
----
<1> 將`spring-boot-starter-data-rest`引入至`implemenation`範圍依賴。

.ProductRepository
[source,java]
----
@RepositoryRestResource(collectionResourceRel = "products", path = "products") // <1>
public interface ProductRepository extends MongoRepository<Product, String> { 

}
----
<1> `@RepositoryRestResource` 宣告`ProductRepository`的數據訪問方法需被曝露為RESTful介面。RESTFul風格的API是以resource為中心，repository所專屬的模型就對應為RESTFul中的resource。`@RepositoryRestResource`充許應用開發者自定義模型所對應的resource在URL中及在內容體中的名字。本例中，resource Product的根RESTFul URL定義為`products/`。在HATEOAS標準的內容體中，Product集合會被命名為`products`，例如：
+
[source, json]
----
{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-07T08:04:17.818+0000",
  "updatedAt" : "2019-12-07T08:04:17.818+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6/images"
    }
  }
}
----

Spring Data REST有四種倉庫檢測策略，用以檢測哪些倉庫應被曝露為REST Web服務。其默認的檢測策略是曝露所有公共的倉庫接口（除了通過注解顯式標注不曝露的倉庫），但我推薦使用`ANNOTATION`檢測策略，僅曝露以注解`@RepositoryRestResource`顯式標注的倉庫。以下是Spring Data REST提供的四種倉庫檢測策略：

|===
|名穪|描述

|DEFAULT
|曝露所有公共的倉庫但通過注解`@RestResource`和`@RepositoryRestResource`中的`exported`旗標顯式標記不曝露的倉庫除外。

|ALL
|曝露所有倉庫，不考慮其可見性或被顯式標記為不曝露。

|ANNOTATED
|僅曝露被注解`@RestResource`或`@RepositoryRestResource`標記的，且其`exported`旗標不為`false`的倉庫。

|VISIBILITY
|僅曝露公共的且被注解標記的倉庫。
|===

Spring Data REST的檢測策略可以通過聲明一個`RepositoryRestConfigurer`Bean來自定義。

　.RepositoryRestConfig.java
[source, java]
----
@Configuration // <1>
public class RepositoryRestConfig {

  @Bean // <2>
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurer() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ANNOTATED); // <3>
      }
    };
  }
}
----
<1> `@Configurition`聲明該類為配置類。
<2> 在Spring上下文中聲明個類型為RepositoryRestConfigurer`的Bean。
<3> 構造一個子類，並覆寫方法`configureRepositoryRestConfiguration`，自定義倉庫檢測策略為`ANNOTATED`。

=== 測試

一個典型的軟件測試金字塔自下而上為：

* 單元測測「Unit Test」
* 集成測試「Integration Test」
* 應用編程接口測試「API Test」
* 功能測試「Function Test」
* 性能測試「Performance Test」

單元測試是一種以單個代碼單元（在Java中就是類）為測試目標的測試方法。

我們應權衡考慮測試的覆盖度和編寫維護測試代碼的工作量。鍳於我們的應用大量使用第三框架，應用開發者編寫的代碼實際上很少，且是RESTFul的Web服務。所以跳過單元測試和集成測試，僅做應用編程接口測試是比較合適的。

Spring Test提供了Spring MVC Test框架，其為Spring MVC代碼測試提供了流暢的API，應用開發者可以方便等將其與JUnit、TestNG或其它測試框架集成。

本例中，我們集成JUnit和Spring MVC Test框架，實現應用編程接口測試。

以測試創建和讀取單個Product為例。首先，創建測試目標及MockMvc。

.ProductTest.java
[source, java]
----
@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class) // <1>
@SpringBootTest(classes = CatalogApplication.class) //<2>
@AutoConfigureMockMvc // <3>
@AutoConfigureRestDocs
public class ProductTest {

  private static final String ENDPOINT = "/products";

  @Autowired
  private MockMvc mvc; // <4>
  @Autowired
  private ObjectMapper objectMapper; // <5>
  @Autowired
  private ProductImageRepository imageRepository; // <6>

  ...
}
----
<1> 使用JUnit注解`org.junit.runner.RunWith`指明使用Spring擴展的JUnit Runner`org.springframework.test.context.junit4.SpringRunner`。`SpringRunner`會初始化Spring上下文，從而可以在測試代碼中使用依賴注入、模組掃描等Spring特性。默認的JUnit Runner並不會初始化Spring上下文。
<2> 使用注解`org.springframework.boot.test.context.SpringBootTest`聲明測試用Spring上下文。`@SpringBootTest`可以指定上下文配置類，這點我們使用生產代碼相同的應用入口類配置測試上下文。
<3> 使用注解`org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc`聲明配置MockMvc，然後就可以在測試代碼中注入MockMvc Bean了。
<4> 使用注解`org.springframework.beans.factory.annotation.Autowired`聲明注入MockMvc。
<5> 使用注解`org.springframework.beans.factory.annotation.Autowired`聲明注入ObjectMapper。MockMvc是以包裝了HTTP請求和响應的`HttpServletRequest`和`HttpServletResponse`的形式與DispatcherServlet通信的，所以需要構造和解析JSON格式的請求體和响應體。在測試代碼中使用與被測試代碼相同皂JSON序列化和反序列化實現可以避免編解碼不一致的麻煩。
<6> 使用注解`org.springframework.beans.factory.annotation.Autowired`聲明注入`ProductImageRepository`。在領域模型中，Product關聯ProductImage，所以有些測試用例需要預置ProductImage數據。直接使用`ProductImageRepository`是最直接簡單的預置ProductImage數據的方法。

然後，預置ProductImage數據。

.ProductTest.java
[source, java]
----
...
  @Before // <1>
  public void setUp() {
    ProductImage imageA = new ProductImage(); // <2>
    imageA.setSrc("https://aaa.bbb.ccc/ddd.png");
    imageA.setCreatedAt(new Date());
    imageA.setUpdatedAt(new Date());

    imageAId = imageRepository.save(imageA).getId(); // <3>

    ProductImage imageB = new ProductImage();
    imageB.setSrc("https://bbb.ccc.ddd/eee.png");
    imageB.setCreatedAt(new Date());
    imageB.setUpdatedAt(new Date());

    imageBId = imageRepository.save(imageB).getId();

    ProductImage imageC = new ProductImage();
    imageC.setSrc("https://ccc.ddd.eee/fff.png");
    imageC.setCreatedAt(new Date());
    imageC.setUpdatedAt(new Date());

    imageCId = imageRepository.save(imageC).getId();
  }
...
----
<1> 使用注解`org.junit.Before`聲明在執行每個測試方法之前都預置一遍數據。
<2> 構造預置的ProductImage對象。
<3> 調用ProductImageRepository方法，將預置ProductImage對象持久化至數據庫

再然後，通過MockMvc嚮測試目標發送模擬RESTFul HTTP請求並校驗响應。

.ProductTest.java
[source, java]
----
...
@Test
public void testCreateAndGet() throws Exception {
  final String imageALink = obtainLinkOfImage(imageAId);
  final String imageBLink = obtainLinkOfImage(imageBId);
    
  final String title = "New Product";
  final String ELECTRONICS = "Electronics";
  final String MOBILE = "Mobile";

  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) // <1>
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated()) // <2>
      .andExpect(jsonPath("$.title", is(title))) // <3>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", links(), requestFields(
          fieldWithPath("images").type(JsonFieldType.ARRAY)
              .description("links of referred ProductImage")),responseFields()))
      .andReturn().getResponse().getContentAsString();

  String productId = Stream
      .of(objectMapper.readTree(createResponse).at("/_links/self/href").asText().split("/"))
      .reduce((first, second) -> second).orElse(null); // <4>

  mvc.perform(get(ENDPOINT + "/{id}", productId).accept(MediaType.APPLICATION_JSON)) // <5>
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/getOne", links(),
          pathParameters(parameterWithName("id").description("catalog's id")), responseFields()));

  ...
}
...
----
<1> 使用`org.springframework.test.web.servlet.request.MockMvcRequestBuilders`提供的構造方法構造`MockHttpServletRequestBuilder`，MockMvc的perform方法會從中構造請求實例並發送給DispatcherServlet模擬HTTP請求。（後續為了從測試中生成API文檔，我們會換用兼容的`org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders`提供的構造器方法。`RestDocumentationRequestBuilders`構造方法僅添加了文檔描述功能，HTTP協議相關的部份，如HTTP頭、响應碼等，依舊與`MockMvcRequestBuilders`的構造器相同。）
+
`MockMvcRequestBuilders`提供了對應HTTP協議中定義的九種請求方法中的八種構造方法。
+
[plantuml, MockMvcRequestBuilders, png]
....
@startuml
abstract class MockMvcRequestBuilders {
  {static} +get(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +get(uri: URI): MockHttpServletRequestBuilder
  {static} +post(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +post(uri: URI): MockHttpServletRequestBuilder
  {static} +put(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +put(uri: URI): MockHttpServletRequestBuilder
  {static} +patch(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +patch(uri: URI): MockHttpServletRequestBuilder
  {static} +delete(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +delete(uri: URI): MockHttpServletRequestBuilder
  {static} +options(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +options(uri: URI): MockHttpServletRequestBuilder
  {static} +head(urlTemplate: String, uriVars: Object...): MockHttpServletRequestBuilder
  {static} +head(uri: URI): MockHttpServletRequestBuilder
}
@enduml
....
+
可以發現所有的構造方法都是返回同類型的構造器`MockHttpServletRequestBuilder`，測試代碼在穫取到`MockHttpServletRequestBuilder`實例後，可以繼續設置請求。`MockHttpServletRequestBuilder`提供了很多方法以供設置HTTP請求，這𥚃僅羅列常用的，具體請參閱源代碼：
+
|===
|方法|可設置HTTP請求內容

|accept(MediaType... mediaTypes)
|`Accept`請求頭

|contentType(MediaType mediaType)
|`Content-Type`請求頭

|content(byte[] content)
content(String content)
|請求體
|===
<2> MockMvc的perform方法從構造器中創建mock請求例發送給DispatcherServlet，並將DispatcherServlet的响應包裝成`org.springframework.test.web.servlet.ResultActions`。測試代碼可以通過`ResultActions`提供的`andExpect`方法校驗响應結果；通過`andDo`方法附加一些操作，如打印响應內容等；通過`andReturn`方法讀取响應內容以做進一步操作。
+
[plantuml, ResultActions, png]
....
@startuml
interface ResultActions {
  andExpect(matcher: ResultMatcher): ResultActions
  andDo(handler ResultHandler): ResultActions
  andReturn(): MvcResult
}
@enduml
....
+
Spring MVC Test框架提供了豐富的ResultMatcher供應用開發者檢驗MVC响應的各個部份。所有這些ResultMatcher都通過`org.springframework.test.web.servlet.result.MockMvcResultMatchers`的構造方法穫取。`StatusResultMatchers`是由`MockMvcResultMatchers`提供的一個結果檢驗器，通過方法`status()`穫取，用於檢驗响應狀態碼。POST請求意在創建新的實體，在成功創建新實體後RESTFul Web服務應响應狀態碼`200 Created`。
<3> `JsonPathResultMatchers`是由`MockMvcResultMatchers`提供的一個結果檢驗器，通過方法`jsonPath(String expression, Matcher<T> matcher)`穫取，用於檢驗JSON格式的响應體。`JsonPathResultMatchers`按JSON路徑表逹式從响應體解析出內容，再搭配Hamcrest的檢驗器就可以檢驗JSON格式响應體的任意部份。
<4> 新創建Product實體的唯一標識是由MongoDB生成的，且以自身鏈接的一部份的形式在响應體中返回。（Hypermedia-Driven的RESTFul Web服務在展現實體內容的响應體中包含指hlvlhbr甚它實體或集合的鏈接，其中就包括指嚮自身的鏈接。RESTFul風格的資源URL形式為`/<resources>/<id>`，所以解析單一資源URL最後一部份就可以得到資源唯一標識。）通過`ResultActions`的`andReturn`方法穫取包含所有响應信息的對象，再從中讀取响應體，再從响應體中解析出自身鏈接，最後從自身鏈接中解析出新創建Product實體的唯一標識。
+
Spring Data REST對實體內容的編碼遵循Hypertext Application Language（HAL）約定。按照HAL，表示實體的JSON中應包含object類型的屬性`_links`，而`_links`應包含一個名為`self`的object類型屬性，`self`應包含名為`href`文本類型的屬性，`href`即該實體的自身鏈接。JSON路徑`/_links/self/href`應能解析出實體的自身鏈接。創建Product實體响應體樣例：
+
[source, json]
----
{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-08T07:10:53.091+0000",
  "updatedAt" : "2019-12-08T07:10:53.091+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a/images"
    }
  }
}
----
<5> 使用`org.springframework.test.web.servlet.request.MockMvcRequestBuilders`的`get`構造方法構造get請求構造器。MockMvc從中構造get請求實例並發送給DispatcherServlet。再使用Spring MVC Test框架提供的結果檢驗器檢驗結果。

其它Product應用編程接口測試與此相似，這𥚃就不再贅述，請參閱源碼。

==== 使用嵌入式MongoDB mock MongoDB

我們的應用編程接口測試依賴運行的MongoDB服務，而可重復執行測試的一個重要特性是「不依賴外部資源或服務」。所以內嵌MongoDB服務是最佳解決方案。

.build.gradle
[source, groovy]
----
...
dependencies {
	...
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo' // <1>
}
...
----
<1> 在`de.flapdoodle.embed.mongo`引入Gradle的testImplementation範圍依賴。

spring-boot-autoconfigure担供了嵌入式MongoDB支持，當`de.flapdoodle.embed.mongo`被添加到classpath，`org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration`就會被激活，自動配置嵌入式MongoDB。

.EmbeddedMongoAutoConfiguration.java
[source, java]
----
@Configuration
@EnableConfigurationProperties({ MongoProperties.class, EmbeddedMongoProperties.class })
@AutoConfigureBefore(MongoAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongodStarter.class })
public class EmbeddedMongoAutoConfiguration {
  ...
}
----

=== API文檔

使用Spring REST Docs，從應用編程接口測試中生成API文檔。

首先，引入Spring REST Docs及Asciidoctor依賴，並引入Asciidoctor插件。

.build.gradle
[source, groovy]
----
plugins {
	...
	id 'org.asciidoctor.convert' version '1.5.3' // <1>
}
...
depedencies {
  asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor' // <2>
  ...
  testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc' // <3>
}
...
ext {
	snippetsDir = file('build/generated-snippets') // <4>
	...
}

test {
	outputs.dir snippetsDir // <5>
}

asciidoctor { // <6>
	inputs.dir snippetsDir
	dependsOn test
}
...
bootJar { // <7>
	dependsOn asciidoctor
	from ("${asciidoctor.outputDir}/html5") {
		into 'static/docs'
	}
}
...
----
<1> 引入Asciidoctor的Gradle插件`org.asciidoctor.convert`，其會引入Gradle task `asciidoctor`。
<2> 將`spring-restdocs-asciidoctor`引入至Gradle的asciidoctor範圍依賴，asciidoctor範圍是Asciidoctor插入擴展的，僅對Asciidoctor插件起效。
<3> 將spring-restdocs-mockmvc引入Gradle的testImplementation範圍依賴，版本由Spring Boot Gradle插入統一控制。
<4> 聲明變量`snippetsDir`為Spring REST Docs輸出HTTP請求响應片斷的根目錄。
<5> 設置測試任務的輸出目錄為`snippetsDir`。Spring REST Docs是做為測試的一部份被執行的，其輸出根目錄即測試的輸出相錄即`snippetsDir`。
<6> 配置Gradle任務asciidoctor，將`snippetsDir`添加為輸入目錄，Asciidoc文檔就可以引用Spring REST Docs截取的HTTP請求响應片斷了；並該任務asciidoctor依賴任務test，因為任務asciidoctor所需的請求响應片斷是在任務test中產生的，所以任務asciidoctor必須在任務test之後執行。任務asciidoctor是由Asciidoctor插件提供的。
<7> 配置Gradle任務bootJar，使其依賴任務asciidoctor，並將經asciidoctor轉換後的HTML格式文檔打包至flatjar中，置於路徑`static/docs`。Spring Boot默認將`static/docs`下的內容以靜態文件的形式發佈至URL`/docs/`。

然後，在測試中激活Spring REST Docs配置。

.ProductTest.java
[source, java]
----
@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class)
@SpringBootTest(classes = CatalogApplication.class)
@AutoConfigureMockMvc
@AutoConfigureRestDocs // <1>
public class ProductTest {
...
----
<1> 使用注解`org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs`激活Spring REST Docs自動配置。

再然後，用`org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders`提供的mock請求構造方法替換`org.springframework.test.web.servlet.request.MockMvcRequestBuilders`的mock請求構造方法。`RestDocumentationRequestBuilders`構造方法返回與`MockMvcRequestBuilders`構造方法相同的`MockHttpServletRequestBuilder`。不同的是，`RestDocumentationRequestBuilders`往`MockHttpServletRequestBuilder`中添加了請求屬性`ATTRIBUTE_NAME_URL_TEMPLATE`，使其可以從mock請求的URL模格中解析出實參。

.RestDocumentationRequestBuilders.java
[source, java]
----
...
public static MockHttpServletRequestBuilder get(String urlTemplate,
		Object... urlVariables) {
	return MockMvcRequestBuilders.get(urlTemplate, urlVariables).requestAttr(
			RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE, urlTemplate); // <1>
}
...
----
<1> `RestDocumentationRequestBuilders`在每個接受URL模板的構造方法中都將URL模格注冊為請求屬性，以備`PathParametersSnippet`從穫取請求URL中的參數化部份，如資源唯一標識等。

.PathParametersSnippet.java
[source, java]
----
...
private String extractUrlTemplate(Operation operation) {
	String urlTemplate = (String) operation.getAttributes()
			.get(RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE); // <1>
	Assert.notNull(urlTemplate, "urlTemplate not found. If you are using MockMvc did "
			+ "you use RestDocumentationRequestBuilders to build the request?");
	return urlTemplate;
}
...
----
<1> `PathParametersSnippet`從請求屬性中讀取URL模板。

== ProductImage 

=== 模型

.ProductImage.java
[source,java]
----
@Getter
@Setter
@Document
public class Product {

  @Id
  private String id;
  private String title;
  private List<String> tags;
  @DBRef
  private List<ProductImage> images;
  private Date createdAt;
  private Date updatedAt;
}
----

=== Repository

.ProductImageRepository
[source,java]
----
@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages")
public interface ProductImageRepository extends MongoRepository<ProductImage, String> { <1>

}
----

. 為模型ProductImage創建專屬的ProductImageRepository，繼承至`org.springframework.data.mongodb.repository.MongoRepository`。

=== RESTful API

TBD 