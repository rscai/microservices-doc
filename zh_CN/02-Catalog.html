<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Catalog Service</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Catalog Service</h1>
<div class="details">
<span id="revnumber">version 0.0.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#目标">目标</a></li>
<li><a href="#设计">设计</a>
<ul class="sectlevel2">
<li><a href="#用例">用例</a></li>
<li><a href="#架构">架构</a></li>
<li><a href="#理解-lombok">理解 Lombok</a></li>
<li><a href="#理解-rest">理解 REST</a></li>
<li><a href="#理解-json">理解 JSON</a></li>
<li><a href="#理解-hypermedia-driven">理解 Hypermedia-Driven</a></li>
<li><a href="#理解-spring-data-rest">理解 Spring Data REST</a></li>
<li><a href="#理解-mongodb">理解 MongoDB</a></li>
<li><a href="#理解-spring-data-mongodb">理解 Spring Data MongoDB</a></li>
<li><a href="#理解junit">理解JUnit</a></li>
<li><a href="#理解spring-mvc-test-framework">理解Spring MVC Test Framework</a></li>
<li><a href="#理解-spring-rest-docs">理解 Spring REST Docs</a></li>
</ul>
</li>
<li><a href="#实现">实现</a>
<ul class="sectlevel2">
<li><a href="#构建">构建</a></li>
<li><a href="#领域模型">领域模型</a></li>
<li><a href="#仓库-repository">仓库 Repository</a></li>
<li><a href="#restful-web-服务">RESTful Web 服务</a></li>
</ul>
</li>
<li><a href="#测试">测试</a>
<ul class="sectlevel2">
<li><a href="#product-api-测试">Product API 测试</a></li>
<li><a href="#使用嵌入式mongodb-mock-mongodb">使用嵌入式MongoDB mock MongoDB</a></li>
<li><a href="#productimage-api-测试">ProductImage API 测试</a></li>
</ul>
</li>
<li><a href="#api-文档">API 文档</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="目标">目标</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章中，我们将基于Spring Boot开发提供RESTful API的Catalog微服务。我们将学习：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Lombok在编译器生成Getter和Setter访问器，减少模板代码</p>
</li>
<li>
<p>使用Spring Data/Spring Data MongoDB访问MongoDB</p>
</li>
<li>
<p>使用Spring Data REST从Repository构建RESTful API</p>
</li>
<li>
<p>使用Spring Test/MockMVC测试RESTFul API</p>
</li>
<li>
<p>使用Spring REST Docs生成简洁、准确且结构良好的RESTFul API文档</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="设计">设计</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="用例">用例</h3>
<div class="paragraph">
<p>Catalog微服务负责维护Product和ProductImage两个业务模型实体。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/catalog-model.png" alt="catalog model" width="410" height="148">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Product，可被独立增删改查的业务实体，其可关联一至多个ProductImage</p>
</li>
<li>
<p>ProductImage，可被独立增删改查的业务实体，其可被零至一个Product关联。如若关联其的Product被移除，不会影向ProductImage实体的状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Catalog微服务需支持特性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建新的ProductImage</p>
</li>
<li>
<p>更新ProductImage</p>
</li>
<li>
<p>移除ProductImage</p>
</li>
<li>
<p>分页查询所有ProductImage</p>
</li>
<li>
<p>读取单个ProductImage</p>
</li>
<li>
<p>创建新的Product</p>
</li>
<li>
<p>更新Product</p>
</li>
<li>
<p>移除Product</p>
</li>
<li>
<p>分页查询所有ProductImage</p>
</li>
<li>
<p>读取单个Product</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="架构">架构</h3>
<div class="paragraph">
<p>Catalog微服务採用分层架构，自上往下分为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>展示层。以RESTFul风格向外曝露Catalog支持的领域模型和操作，以JSON格式接受和回应领域模型内容。</p>
</li>
<li>
<p>业务逻辑层，处理应用相关的业务逻辑，比如填充createdAt和updatedAt。</p>
</li>
<li>
<p>数据访问层，处理Java object和具体存储实体之间的映射转换，实现橧删改查等存储访问操作。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/catalog-design.png" alt="catalog design" width="276" height="440">
</div>
</div>
<div class="paragraph">
<p>这𥚃我们採用Spring Data REST实现展现层；供助Spring Data REST开放的实体事件扩展机制，实现业务逻辑；数据存储方案选用MongoDB；数据访问层採用Spring Data MongoDB实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-lombok">理解 Lombok</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。
永远不要再写另一个getter或equals方法，带有一个註释的您的类有一个功能全面的生成器，自动化您的日志记录变量等等。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok<br>
<cite>https://projectlombok.org</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>使用javac（以及netbeans，maven，gradle和大多数其他构建系统）时，lombok作为註释处理器运行。</p>
</div>
<div class="paragraph">
<p>Lombok在classpath中，且javac将在它可以找到的类路径上加载每个 <code>META-INF/services/javax.annotation.processing.Processor</code> 文件，读取每一行并加载该类，然后将其作为註释处理器执行。 <code>lombok.jar</code> 有此文件，它将`lombok.launch.AnnotationProcessorHider$AnnotationProcessor`列为条目。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok Execution Path<br>
<cite>https://projectlombok.org/contributing/lombok-execution-path</cite>
</div>
</div>
<div class="paragraph">
<p>Lombok实现为注解处理器「Annotation Processor」，在编译期被Java编译器调用，扫描代码，读取Lombok注解及关键词标注的类，并执行相应的代码转换。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Lombok官方网站 <a href="https://projectlombok.org/">Lombok Project</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-rest">理解 REST</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>代表性状态转移（REST）是一种软件体系结构样式，它定义了一组用于创建Web服务的约束。 符合REST体系结构样式的Web服务（称为RESTful Web服务）提供Internet上计算机系统之间的互操作性。 RESTful Web服务允许请求系统通过使用统一且预定义的无状态操作集来访问和操纵Web资源的文本表示。 其他类型的Web服务（例如SOAP Web服务）公开其自己的任意操作集。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Representational State Transfer<br>
<cite>https://en.wikipedia.org/wiki/Representational_state_transfer</cite>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服务有以下特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以资源为中心，领域模型在RESTFul API中表现为资源，所有的业务操作都表现为对资源的操作。</p>
</li>
<li>
<p>重用HTTP请求方法。以HTTP请求方法表逹对资源的操作。HTTP协议中定义了九种请求方法：</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET方法请求指定资源的表示形式。 使用GET的请求应仅检索数据。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD方法请求的响应与GET请求的响应相同，但没有响应主体。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST方法用于将实体提交给指定的资源，通常会导致状态更改或对服务器产生副作用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT方法用请求有效负载替换目标资源的所有当前表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE方法删除指定的资源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT方法建立到由目标资源标识的服务器的隧道。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS方法用于描述目标资源的通信选项。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE方法沿到目标资源的路径执行消息环回测试。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH方法用于对资源进行部分修改。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>RESTFul 主要重用其中的POST、DELETE、PUT和GET来分别表逹增、删、改和查操作。</p>
</div>
</li>
<li>
<p>重用HTTP向应状态码。重用HTTP向应状态码来表逹请求的处理结果。HTTP协议定义了五类向应状态码</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>信息性的向应（100-199）</p>
</li>
<li>
<p>成功的向应（200-299）</p>
</li>
<li>
<p>重定向（300-399）</p>
</li>
<li>
<p>客户端错误（400-499）</p>
</li>
<li>
<p>服务端错误（500-599）</p>
<div class="paragraph">
<p>常用的向应状态码有：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Code</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该请求已成功。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">201 Created</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求成功，并因此创建了新资源。 这通常是在POST请求或某些PUT请求之后发送的响应。当使用POST请求访问RESTFul API创建新资源实体后，应返回向应状态码200。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">204 No Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有要发送的内容，但标头可能有用。 用户代理可以使用新的代理更新该资源的缓存头。当使用PUT请求访问RESTFul API更新资源实体且未在向应报文中包含更新后的实体，应使用向应状态码204。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">400 Bad Request</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由于语法无效，服务器无法理解该请求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">401 Unauthorized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">尽管HTTP标准指定“未经授权”，但从语义上讲，此响应表示“未经验证”。 也就是说，客户端必须对自己进行身份验证才能获得请求的响应。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">403 Forbidden</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端无权访问内容； 也就是说，它是未经授权的，因此服务器拒绝提供所请求的资源。 与401不同，服务器知道客户端的身份。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">404 Not Found</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务器找不到请求的资源。 在浏览器中，这意味着无法识别URL。 在API中，这也可能意味着端点有效，但是资源本身不存在。 服务器也可以发送此响应而不是403，以隐藏来自未授权客户端的资源。 由于此响应代码在网络上经常出现，因此可能是最着名的响应代码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">405 Method Not Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务器知道该请求方法，但已被禁用，无法使用。比如针对祗读资源的写请求（POST、DELETE、PUT），RESTFul API可以向应此状态码。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">415 Unsupported Media Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务器不支持所请求数据的媒体格式，因此服务器拒绝了该请求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">500 Internal Server Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服务器遇到了不知道如何处理的情况。任何业务逻辑的错误都不应该向应该状态码。祗有真正无法处理或恢复的失效，比如依赖服务不可用等，才可以向应该状态码。</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="product-restful-web-api">Product RESTFul Web API</h4>
<div class="paragraph">
<p>REST Web服务以资源为中心，把领域模型Product直接映射为资源product，所以资源product的根URL就为 <code>/products</code> 。因为从语义上讲，对资源根URL的操作，如GET、POST，都是作用于资源集合而非单个资源实体，所以使用复数形式更为恰当。（很多人认为使用单数形式是最佳实践，因为英文名词的复数形式规则并不统一且大部份人英文不好，硬用复数形式容易出现拚写错误）</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新与ProductImage之间的关联</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">读取单个Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分页读取所有Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">读取Product关联的ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="productimage-restful-api">ProductImage RESTFul API</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">读取单个ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分页读取所有ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-json">理解 JSON</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON採用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。</p>
</div>
<div class="paragraph">
<p>JSON建构于两种结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组（associative array）。</p>
</li>
<li>
<p>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; 介绍JSON<br>
<cite>https://www.json.org/json-zh.html</cite>
</div>
</div>
<div class="paragraph">
<p>JSON是一种面向字符的、编程语言独立的、易于人和机器读写的数据交换格式。使用JSON作为RESTFul Web服务与消费者之间交换实体内容的数据格格，可以最大限度地提升Web服务的兼容性。但需要注意，JSON是面向文本的数据交换格式，所有类型的数据都必须被编码为文本形式，所以JSON并不适用二进制数据的交换，比如图像、音频、视频。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于JSON的规范定义，请参阅 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404 The JSON Data Interchange Standard</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-hypermedia-driven">理解 Hypermedia-Driven</h3>
<div class="paragraph">
<p>Hypermedia指代所有包含指向其它媒体（如图像、视频和文本等）的链接的内容。Hypermedia-Driven的RESTFul Web服务则是指在请求体和向应体的内容为Hypermedia。</p>
</div>
<div class="paragraph">
<p>HATEOAS（Hypermedia as the Engine of Application State）是一组附加在RESTFul风格架构之上的约束，其旨在约束Hypermedia-Driven RESTFul Web服务。HATEOAS没有严格的定义，各个框架都有自己的实现。但大多数HATEOAS实现都参考了以下规范：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc5988">RFC 5988 Web Linking</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Application_Language">Hypertext Application Language</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-data-rest">理解 Spring Data REST</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data REST是Spring Data的一部份，其致力于简化在Spring Data repository之上构建<strong>超媒体驱动「hypermedia-driven」</strong> REST web微务。</p>
</div>
<div class="paragraph">
<p>Spring Data REST 构建于 Spring Data repository 之上，分析你的应用领域模型且曝露超媒体驱动HTTP资源。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-rest
</div>
</div>
<div class="paragraph">
<p>Spring Framework 本身提供了Spring MVC。借助Spring MVC，可以快速构造RESTFul web服务。再加上Spring HATEOAS，就可以构建超媒体驱动的RESTFul web服务了。但是RESTFul web服务是以资源为中心，其为每类资源实现一组有限的动作，如POS创建、PUT更新、DELETE移除。直接使用Spring MVC构建RESTFul web服务会造成很多模板代码。Spring Data REST就是为了避免使用Spring MVC构建RESTFul web服务时产生冗余模板代码而被创造出来。Spring Data REST分析应用中的repository，分拣出领域模型和增删改查方法，分别曝露为相应的RESTFul URLs.</p>
</div>
<div class="paragraph">
<p>Spring Data REST 开放出了八个实体事件，应用开发者可以注入自定义的事件监听器以实现业务逻辑处理。Spring Data REST会释放出以下八种事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeCreateEvent</code></p>
</li>
<li>
<p><code>AfterCreateEvent</code></p>
</li>
<li>
<p><code>BeforeSaveEvent</code></p>
</li>
<li>
<p><code>AfterSaveEvent</code></p>
</li>
<li>
<p><code>BeforeDeleteEvent</code></p>
</li>
<li>
<p><code>AfterDeleteEvent</code></p>
</li>
<li>
<p><code>BeforeLinkSaveEvent</code></p>
</li>
<li>
<p><code>AfterLinkSaveEvent</code></p>
</li>
<li>
<p><code>BeforeLinkDeleteEvent</code></p>
</li>
<li>
<p><code>AfterLinkDeleteEvent</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beforecreateevent-和-aftercreateevent"><code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在创建实体实例时，会释放出 <code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code>。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; createAndReturn(Object domainObject, RepositoryInvoker invoker,
		PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeCreateEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object savedObject = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterCreateEvent(savedObject)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在调用repository方法将创建的实体持久化至存储服务之前，释放出事件 <code>BeforeCreateEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在调用repository方法将创建的实体持久化至存储服务之后，释放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>POST和PUT请求都有可能触发实体的创建。POST在REST语义中就是创建新实体，所以POST请求肯定会触发实体创建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@ResponseBody
@RequestMapping(value = BASE_MAPPING, method = RequestMethod.POST)
public ResponseEntity&lt;ResourceSupport&gt; postCollectionResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, PersistentEntityResourceAssembler assembler,
		@RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	resourceInformation.verifySupportedMethod(HttpMethod.POST, ResourceType.COLLECTION);

	return createAndReturn(payload.getContent(), resourceInformation.getInvoker(), assembler,
			config.returnBodyOnCreate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>PUT请求在REST语义中是更新实体，但若要求更新的目标实体不存在，则更新操作就自动转化为创建操作。所以，当使用PUT请求更新不存在的实体时，会触发实体创建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>若请求创建的实体是新建的即目标实体不存在，则更新请求转化为创建操作。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforesaveevent-和-aftersaveevent"><code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在更新实体时会释放出 <code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; saveAndReturn(Object domainObject, RepositoryInvoker invoker,
		HttpMethod httpMethod, PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeSaveEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object obj = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterSaveEvent(obj)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在调用repository方法将更新的实体持久化至存储服务之前，释放出事件 <code>BeforeSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在调用repository方法将更新的实体持久化至存储服务之后，释放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>PUT和PATCH请求都会触发实体更新操作。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

    ...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当请求更新的目标实体存在时，PUT请求触发更新操作。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PATCH)
public ResponseEntity&lt;ResourceSupport&gt; patchItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {

	...

	return saveAndReturn(domainObject, resourceInformation.getInvoker(), PATCH, assembler,
			config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>PATCH请求祗能触发实体更新。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="beforedeleteevent-和-afterdeleteevent"><code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在移除实体时会释放出事件 <code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;?&gt; deleteItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id,
		ETag eTag) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {

	...

	return domainObj.map(it -&gt; {

		PersistentEntity&lt;?, ?&gt; entity = resourceInformation.getPersistentEntity();

		eTag.verify(entity, it);

		publisher.publishEvent(new BeforeDeleteEvent(it)); <i class="conum" data-value="2"></i><b>(2)</b>
		invoker.invokeDeleteById(entity.getIdentifierAccessor(it).getIdentifier());
		publisher.publishEvent(new AfterDeleteEvent(it)); <i class="conum" data-value="3"></i><b>(3)</b>

		return new ResponseEntity&lt;Object&gt;(HttpStatus.NO_CONTENT);

	}).orElseThrow(() -&gt; new ResourceNotFoundException());
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>针对实体的DELETE请求会触发实体移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在将实体从存储服务中移除之前，释放出事件 <code>BeforeDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在将实体从存储服务中移除之后，释放出事件 <code>AfterDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforelinksaveevent-和-afterlinksaveevent"><code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在创建和变更实体关联时会释放出 <code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = { PATCH, PUT, POST }, <i class="conum" data-value="1"></i><b>(1)</b>
		consumes = { MediaType.APPLICATION_JSON_VALUE, SPRING_DATA_COMPACT_JSON_VALUE, TEXT_URI_LIST_VALUE })
public ResponseEntity&lt;? extends ResourceSupport&gt; createPropertyReference(RootResourceInformation resourceInformation,
		HttpMethod requestMethod, @RequestBody(required = false) Resources&lt;Object&gt; incoming, @BackendId Serializable id,
		@PathVariable String property) throws Exception {

	...

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; {

        ...

		publisher.publishEvent(new BeforeLinkSaveEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = invoker.invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkSaveEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return null;
	};

	doWithReferencedProperty(resourceInformation, id, property, handler, requestMethod);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>PATCH、PUT或POST请求链接（LINK）类型的实体属性都会触发实体链接属性的创建或变更。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在将链接属性变更持久化至存储服务之前，释放出 <code>BeforeLinkSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在将链接属性变更持久化至存储服务之后，释放出 <code>AfterLinkSaveEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforelinkdelete-和-afterlinkdelete"><code>BeforeLinkDelete</code> 和 <code>AfterLinkDelete</code></h4>
<div class="paragraph">
<p>Spring Data REST在移除实体之间的关联（LINK）时，会释放出 <code>BeforeLinkDeleteEvent</code> 和 <code>AfterLinkDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;? extends ResourceSupport&gt; deletePropertyReference(RootResourceInformation repoRequest,
		@BackendId Serializable id, @PathVariable String property) throws Exception {

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; prop.mapValue(it -&gt; {

		...

		publisher.publishEvent(new BeforeLinkDeleteEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = repoRequest.getInvoker().invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkDeleteEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return (ResourceSupport) null;

	}).orElse(null);

	doWithReferencedProperty(repoRequest, id, property, handler, HttpMethod.DELETE);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>目标为链接类型的实体属性的DELETE请求会触发实体关联移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在将实体关联移除持久化至存储服务之前，释放出事件 <code>BeforeLinkDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在将实体关联移除持久化至存储服务之后，释放出事件 <code>AfterLinkDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="注入事件处理器">注入事件处理器</h4>
<div class="paragraph">
<p>应用开发者可以自定义事件处理器，再使用注解将自定义事件处理器注删为事件监听器。Spring Data REST提供了十个注解分别对应上述十个实体事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@HandleBeforCreate</code></p>
</li>
<li>
<p><code>@HandleAfterCreate</code></p>
</li>
<li>
<p><code>@HandleBeforeSave</code></p>
</li>
<li>
<p><code>@HandleAfterSave</code></p>
</li>
<li>
<p><code>@HandleBeforeDelete</code></p>
</li>
<li>
<p><code>@HandleAfterDelete</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkSave</code></p>
</li>
<li>
<p><code>@HandleAfterLinkSave</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkDelete</code></p>
</li>
<li>
<p><code>@HandleAfterLinkDelete</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解-mongodb">理解 MongoDB</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>MongoDB是一个文档数据库，具有所需的可伸缩性和灵活性，可用于所需的查询和索引编制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MongoDB将数据存储在类似于JSON的灵活文档中，这意味着字段随文档的不同而不同，并且数据结构可以随时间而变化</p>
</li>
<li>
<p>文档模型映射到应用程序代码中的对象，从而使数据易于使用</p>
</li>
<li>
<p>临时查询，索引编制和实时聚合提供了访问和分析数据的强大方法</p>
</li>
<li>
<p>MongoDB以分佈式数据库为核心，因此内置了高可用性，水平扩展和地理分佈并且易于使用</p>
</li>
<li>
<p>MongoDB是免费使用的。 在AGPL下发布了2018年10月16日之前发布的版本。 2018年10月16日之后发布的所有版本（包括先前版本的修补程序修补程序）均根据服务器端公共许可证（SSPL）v1发布。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; What Is MongoDB<br>
<cite>https://www.mongodb.com/what-is-mongodb</cite>
</div>
</div>
<div class="paragraph">
<p>MongoDB是schema-free的数据库，其非常适用于同一类别数据结构会随时间较频繁变动（增加属性、减少属性等）的应用场景。Catalog服务所维护的数据就符合这一特征。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-data-mongodb">理解 Spring Data MongoDB</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data的任务是为数据访问提供一个熟悉且一致的基于Spring的编程模型，同时仍保留基础数据存储的特殊特征。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data MongoDB是Spring Data项目的一部分，该项目旨在为新数据存储提供熟悉且一致的基于Spring的编程模型，同时保留特定于存储的功能。</p>
</div>
<div class="paragraph">
<p>Spring Data MongoDB项目提供了与MongoDB文档数据库的集成。 Spring Data MongoDB的关键功能区域是一个以POJO为中心的模型，该模型用于与MongoDB DBCollection进行交互并轻松编写存储库样式的数据访问层。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-mongodb
</div>
</div>
<div class="paragraph">
<p>Spring Data的核心模式是仓库设计模式「Repository Design Pattern」。
仓库设计模式最早由Eric Evens在他的着作《Domain Driven Design》中提出，其核心概念是仓库「Repository」。仓库在业务逻辑层与数据源之间扮演着中间人的⻆色，其解耦了业务逻辑层和数据源，使用业务逻辑层无需关心具体数据源的接口或任何接口变更，甚至无需任何业务逻辑层的代码变更就可以迁移至不同的数据源上。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/repository-pattern.png" alt="repository pattern" width="406" height="256">
</div>
</div>
<div class="paragraph">
<p>Spring Data提供的核心接口就是 <code>Repository</code> 。应用开发者祗需声明专用于领域模型的、继承 <code>Repository</code> 的仓库接口，针对特定存储服务实现的Spring Data模块（如Spring Data MongoDB）会构造相应的仓库实现Bean。</p>
</div>
<div class="paragraph">
<p>Spring Data除了 <code>Repository</code> 之外，还提供了其它仓库接口。这些仓库口提供了常用的数据访问操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.data.repository.CrudRepository</code> 提供了基本的增删改查操作</p>
</li>
<li>
<p><code>org.springframework.data.repository.PagingAndSortingRepository</code> 添加了分页和排序功能</p>
</li>
<li>
<p><code>org.springframework.data.repository.query.QueryByExampleExecutor</code> 提供了相似查询功能，应用可以按照业务逻辑定义相似算法，查询相似（不完全相同，或主键相同）的实体</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/repository-interface.png" alt="repository interface" width="706" height="525">
</div>
</div>
<div class="paragraph">
<p>Spring Data MongoDB在Spring Data Commons提供的仓库接口基础上，还扩展了 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/spring-data-mongodb-repository.png" alt="spring data mongodb repository" width="495" height="276">
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解junit">理解JUnit</h3>
<div class="paragraph">
<p>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 定义了三层单元测试组织结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TestSuite</p>
</li>
<li>
<p>TestCase</p>
</li>
<li>
<p>Test</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Test</strong> 是单元测试的最小组织单位，多个 <strong>Test</strong> 可以组织为 <strong>TestCase</strong>，多个 <strong>TestCase</strong> 可以组织为 <strong>TestSuite</strong>。在 Java 中，<strong>TestCase</strong> 和 <strong>TestSuite</strong> 实现为类，<strong>Test</strong> 实现为 <strong>TestCase</strong> 的方法。所以在实际应用中，<strong>Test</strong> 和 <strong>TestCase</strong> 是必须的，<strong>TestSuite</strong> 是可选的。</p>
</div>
<div class="paragraph">
<p>Junit 定义了五个单元测试执行阶段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BeforeClass</p>
</li>
<li>
<p>BeforeEach</p>
</li>
<li>
<p>Test</p>
</li>
<li>
<p>AfterEach</p>
</li>
<li>
<p>AfterClass</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong> 为 <strong>TestCase</strong> 的初始阶段，JUnit 在即将执行 <strong>TestCase</strong> 所包含的 <strong>Test</strong> 之前执行 <strong>BeforeClass</strong>；<strong>BeforeEach</strong> 为 <strong>Test</strong> 的前置阶段，JUnit 在每次执行 <strong>Test</strong> 之前执行 <strong>BeforeEach</strong>；<strong>Test</strong> 为单元测试的主要阶段，该阶段应包含向测试对象输入和断言测试对象的输出；<strong>AfterEach</strong> 为 <strong>Test</strong> 的后置阶段，JUnit 在每次执行 <strong>Test</strong> 之后执行 <strong>AfterEach</strong>；<strong>AfterClass</strong> 为 <strong>TestCase</strong> 的善后阶段，JUnit 在执行完 <strong>TestCase</strong> 所包含的所有 <strong>Test</strong> 之后执行 <strong>AfterClass</strong>。</p>
</div>
<div class="paragraph">
<p>举个例子，</p>
</div>
<div class="listingblock">
<div class="title">ExampleTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleTest {
  private Example testObject;
  @BeforeClass
  public void beforeClass() {
    System.out.println("Before test case ExampleTest");
  }
  @AfterClass
  public void afterClass() {
    System.out.println("After test case ExampleTest");
  }
  @BeforeEach
  public void setUp() {
    System.out.println("SetUp for each test");
    testObject = new Example();
  }
  @AfterEach
  public void tearDown() {
    System.out.println("TearDown for each test");
  }
  @Test
  public void testFunA() {
    String actual = testObject.funA();
    assertEqual(actual, "expected value");
  }
  @Test
  public void testFunB() {
    String actual = testObject.funB();
    assertEqual(actual, "expected value");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong>, <strong>AfterClass</strong>, <strong>BeforeEach</strong>, <strong>AfterEach</strong> 和 <strong>Test</strong> 都被实现为 <strong>TestCase</strong> 的方法，通过注解声明。JUnit 在执行上述 <strong>TestCase</strong>，方法调用序列为：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>beforeClass()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunA()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunB()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>afterClass()</code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="理解spring-mvc-test-framework">理解Spring MVC Test Framework</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring MVC测试框架提供了一流的支持，可使用可与JUnit，TestNG或任何其他测试框架一起使用的流畅API测试Spring MVC代码。 它基于spring-test模块的Servlet API mock objects构建，因此不使用正在运行的Servlet容器。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring MVC Test Framework<br>
<cite>https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#spring-mvc-test-framework</cite>
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架通过 <code>DispatcherServlet</code> 与Spring MVC代码直接通信，无需运行Servlet容器。且测试代码与被测试代码（服务端代码）运行在同一个JVM中，所以不仅可以验证服务端代码的输出还可以验证服务端代码的内部状态，即支持服务端代码的白盒测试。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/spring-mvc-architecture.png" alt="spring mvc architecture" width="495" height="309">
</div>
</div>
<div class="paragraph">
<p>在生产环境中， <code>dispatcherServlet</code> 和 <code>controller</code> 都运行在 <code>Servlet</code> 容器中（Spring Boot应用是内嵌Servlet容器），并通过Servlet容器向外曝露HTTP服务。客户端应用（Web浏器、原生应用等）通过HTTP协议访问Servlet容器，Servlet容器将请求转化为 <code>HttpServletRequest</code> 交由 <code>dispatcherServlet</code> ； <code>dispatcherServlet</code> 再分发给对应的 <code>controller</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/mockmvc-archotecture.png" alt="mockmvc archotecture" width="352" height="234">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架则通过MockMvc（Servlet API mock objects）直接与 <code>dispatcherServlet</code> 通信。我们的测试目标是应用上下文配置和 <code>controller</code> 及其调用的其它Beans，Servlet容器并不是我们的测试目标（因为它们的代码不是我们写的）。使用这种测试方法可以最大限度地排除第三方代码，仅关注于应用代码的测试。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-rest-docs">理解 Spring REST Docs</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring REST Docs可帮助您记录RESTful服务。</p>
</div>
<div class="paragraph">
<p>它结合了用Asciidoctor编写的手写文档和Spring MVC Test生成的自动生成的代码片段。 这种方法使您摆脱了Swagger之类的工具所产生的文档限制。</p>
</div>
<div class="paragraph">
<p>它可以帮助您生成准确，简洁且结构合理的文档。 然后，该文档可让您的用户以最少的麻烦获得他们所需的信息。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring REST Docs<br>
<cite>https://spring.io/projects/spring-restdocs</cite>
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs致力于帮助应用开发者生成准确且可读的RESTFul服务文档。Spring REST Docs借助测试生成的HTTP请求和响应内容片断，再组合手工编写的Asciidoc或Markdown文本，产生HTML格式的文档。文档的生成依赖测试的通过。所以当测测未通过时，文档也不会被生成，从而避免成生与实现不符的文档。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/spring-rest-docs-process.png" alt="spring rest docs process" width="388" height="293">
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs可以从由Spring MVC Test框架、Spring WebFlux&#8217;s <code>WebTestClient</code> 和REST Assured 3编写的测试中截取HTTP请求和响应片断。</p>
</div>
<div class="paragraph">
<p>应用开发者编写asciidoc文档（以.adoc, .asciidoc, .ad, .asc山大弓火后缀的），引用Spring REST Docs在测试阶段截取的片断。Asciidoctor读取asciidoc文档和请求响应片断，转换生成HTML格式的可阅读文档（Asciidoctor还支持其它输出格式，如PDF、EPUB等）。</p>
</div>
<div class="paragraph">
<p>作为Spring REST Docs的核心，其提供了丰富的HTTP请求响应片断截取和注释功能。所有这些截取注释功能都实现为 <code>org.springframework.restdocs.snippet.Snippet</code> 的实现类，应用开发者通过构造方法获取这些Snippet实现类实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/http-message.png" alt="http message" width="606" height="313">
</div>
</div>
<div class="paragraph">
<p>HTTP报文分为请求（request）报文和响应（response）报文。请求报文由三部份组成：请求行（Request Line）、头（Header Field）和消息体（Message Body）。响应报文也由三部份组成：状态行（Status Line）、头（Header Field）和消息体（Message Body）。</p>
</div>
<div class="paragraph">
<p>Spring REST Docs为请求行，头和消息体分别提供了Snippet。这些Snippet的构造方法被组织为三个类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.restdocs.request.RequestDocumentation</code> 包含用于截取请求行中各个部份的Snippet的构造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.headers.HeaderDocumentation</code> 包含用于截取请求头和响应头的Snippet的构造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.payload.PayloadDocumentation</code> 包含用于截取请求消息体和响应消息体的Snippet的构造方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除此之外，Spring REST Docs还为Hypermedia-Driven RESTFul Web服务提供了专用的Snippets。这些专用Snippets的构造方法被组织为类 <code>org.springframework.restdocs.hypermedia.HypermediaDocumentation</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>关于Spring REST Docs完整的资料，请参阅官方文档 <a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="实现">实现</h2>
<div class="sectionbody">
<div class="paragraph">
<p>最简单的创建一个新的 Spring Boot 应用方法是使用 <a href="https://start.spring.io">Spring Initializr</a>。使用浏览器访问 <a href="https://start.spring.io" class="bare">https://start.spring.io</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project 选择 Gradle Project，使用 Gradle 构建我们的项目；</p>
</li>
<li>
<p>Language 选择 Java；</p>
</li>
<li>
<p>Spring Boot 撰择 2.2.7 或其它 2.2.x 版本，最新版（讫今为止）的 Spring Cloud Hoxton 兼容 Spring Boot 2.2.x；</p>
</li>
<li>
<p>Project Metadata 部份，Group 填 <code>io.github.rscai.microservices</code>，Artifact 填 <code>catalog</code>，Name 填 <code>catalog</code>，Packaging 撰 Jar，Java 撰择版本 8；</p>
</li>
<li>
<p>Dependencies 选择</p>
<div class="ulist">
<ul>
<li>
<p>Spring Web</p>
</li>
<li>
<p>Spring Data MongoDB</p>
</li>
<li>
<p>Rest Repositories</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/02-Catalog/generate-project-by-spring-initializr.png" alt="generate project by spring initializr">
</div>
</div>
<div class="paragraph">
<p>单击<strong>GENERATE</strong>，Spring initializr 就会生成 ZIP 格式的项目文件。</p>
</div>
<div class="paragraph">
<p>将 <code>catalog.zip</code> 解压后得到一个 Spring Boot 项目。其中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.
├── .gitignore
├── HELP.md
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── settings.gradle
└── src
    ├── main
    │   ├── java
    │   └── resources
    └── test
        └── java
        └── resources</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>.gitignore</code>, 罗列了应被 GIT 忽略的文件和目录。自动生成及临时文件及目录不应被纳入版本控制；</p>
</li>
<li>
<p><code>build.gradle</code>，Gradle 项目文件，定义了项结构及构建过程；</p>
</li>
<li>
<p><code>gradle/wrapper/</code> 包含所有 Gradle Wrapper 相关的文件；</p>
</li>
<li>
<p><code>gradlew</code> 是 UNIX-like 平台版本的 Gradle 命令包装；</p>
</li>
<li>
<p><code>gradlew.bat</code> 是 Windows 平台版本的 Gradle 命令包装；</p>
</li>
<li>
<p><code>HELP.md</code> 顾名思义是帮助文档，与 README 类似；</p>
</li>
<li>
<p><code>setting.gradle</code> Gradle 的属性文件；</p>
</li>
<li>
<p><code>src/</code> 包含所有源代码和资源文件：</p>
</li>
<li>
<p><code>src/main/</code> 包含所有部署至运行环境的源代码文件（以编译后的目标代码形式被部署至运行环境）和资源文件：</p>
</li>
<li>
<p><code>src/main/java/</code> 包含所有部署至运行环境的 Java 源代码文件：</p>
</li>
<li>
<p><code>src/main/resources/</code> 包含所有部署至运行环境的资源文件；</p>
</li>
<li>
<p><code>src/test</code> 包含所有用于测试的源代码和资源文件；</p>
</li>
<li>
<p><code>src/test/java/</code> 包含所有用于测试的 Java 源代码文件；</p>
</li>
<li>
<p><code>src/test/resource/</code> 包含所有用于测试的资源文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将 catalog 项目导入 IntelliJ IDEA。首先，打开 Intellij IDEA，然后，单系 Import Project，选定 catalog 项目目录，再然后选择以 Gradle 项目形式导入。IntelliJ IDEA 会自动初始执行 Gradle 配置，下载 <code>/gradle/wrapper/gradle-wrapper.properties</code> 中指定版本的 Gradle。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/02-Catalog/catalog-import.gif" alt="catalog import">
</div>
</div>
<div class="sect2">
<h3 id="构建">构建</h3>
<div class="paragraph">
<p>本项目使用 Gradle 构建。Gradle 构建过程主要通过 <code>build.gradle</code> 描述。</p>
</div>
<div class="paragraph">
<p>首先，引用必要的 Gradle 插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'org.springframework.boot' version '2.2.2.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
	id 'io.spring.dependency-management' version '1.0.8.RELEASE' <i class="conum" data-value="2"></i><b>(2)</b>
	id 'java'
	id "io.freefair.lombok" version "4.1.6"
	id "org.sonarqube" version "2.7.1"
	id 'jacoco'
	id 'org.asciidoctor.convert' version '1.5.3'
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入 Spring Boot 插件，其版本决定了引入的 Spring Boot 库的版本。所以有了 Spring Boot 插件，就无需显式指定各个 Spring Boot 库的版本了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入 Spring 依赖管理插件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，引入依赖。</p>
</div>
<div class="listingblock">
<div class="title">gradle.build</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
ext {
	snippetsDir = file('build/generated-snippets')
	set('springCloudVersion', "Hoxton.SR1") <i class="conum" data-value="1"></i><b>(1)</b>
}

dependencies {
	asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor'
	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb' <i class="conum" data-value="2"></i><b>(2)</b>
	implementation 'org.springframework.boot:spring-boot-starter-web' <i class="conum" data-value="3"></i><b>(3)</b>
	implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="4"></i><b>(4)</b>
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.security:spring-security-oauth2-resource-server'
	implementation 'org.springframework.security:spring-security-oauth2-jose'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
	testImplementation 'org.springframework.security:spring-security-test'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="5"></i><b>(5)</b>
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将 Spring Cloud 版本定义为变量，便于引用及统一管理。Spring Cloud 与 Spring Boot 之间的版本兼容性发佈在 <a href="https://spring.io/projects/spring-cloud#overview" class="bare">https://spring.io/projects/spring-cloud#overview</a>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Release train Spring Boot compatibility</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Release Train</th>
<th class="tableblock halign-left valign-top">Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hoxton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greenwich</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finchley</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edgware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dalston</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-mongodb</code> 引入 Spring Data MongoDB 相关的库，用以生成访问 MongoDB 的 Repository。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>spring-boot-starter-web</code> 引入了 Spring MVC 相关的库。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-rest</code> 引入 Spring Data REST 相关的库。Spring Data REST 将 Repository 方法发佈为 RESTFul 风格的 Web 服务，以减少模板代码。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>通过引入 <code>org.springframework.cloud:spring-cloud-dependencies</code> BOM 来管理 Spring Cloud 库的版本。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="领域模型">领域模型</h3>
<div class="paragraph">
<p>利用Lombok编译期生成getter/setter方法，减少重复的模板代码。</p>
</div>
<div class="paragraph">
<p>使用Spring Data MongoDB提供的注解描述java类与MongoDB集合、java字段与MongoDB字段之间的映射关系。Spring Data MongoDB会根据映射关系生成对应的Repository实现。</p>
</div>
<div class="sect3">
<h4 id="product">Product</h4>
<div class="listingblock">
<div class="title">Product.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class Product {

  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String title;
  private List&lt;String&gt; tags;
  @DBRef <i class="conum" data-value="5"></i><b>(5)</b>
  private List&lt;ProductImage&gt; images;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok会在编译期扫描类，为以 <code>lombok.Getter</code> 注解标注的类中所有成员字段生成getter访问器。比如针对字段 <code>private String id</code> ，其生成了相当与以下源代码的Getter访问器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String getId() {
    return this.id;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使使用Gradle构建项目也可处理Lombok注解、生成相应访问器，我们需要在 <code>build.gradle</code> 中显式引入Lombok插件：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id "io.freefair.lombok" version "4.1.5" <i class="conum" data-value="1"></i><b>(1)</b>
	...
}
...</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok会在编译期扫描类，为以 <code>lombok.Setter</code> 注解标注的类中所有成员字段生成Setter访问器。比如针对字段 <code>private String id</code> ，其生成了相当与以下代码的Setter访问器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void setId(String id) {
    this.id = id;
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 将一个Java类映射到MongoDB的某个Collection。在MongoDB中，Collection是Document的集合。在Java中，Class是Object的模板，"从某个Class实例出来的Object"是一个Object的集合。所以，在Java Class/Object与MongoDB Collection/Document映射关系中，Class对应Collection，Object对应Document。而Object中的字段对应Document中的字段。
<div class="imageblock">
<div class="content">
<img src="../images/diag-6a64f855599da504ff3b560cf8a9ee20.png" alt="diag 6a64f855599da504ff3b560cf8a9ee20" width="1563" height="397">
</div>
</div>
<div class="paragraph">
<p>其实例object映射为MongoDB中的一个docuemnt。object中的每一个属性映射为document中的一个字段。比如，object中的字段 <code>id</code> 映射为Mongo document中的字段 <code>id</code> ；object中的字段 <code>title</code> 映射为Mongo document中的字段 <code>title</code> ；object中的字段 <code>tags</code> 映射为Mongo document中的字段 <code>tags</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.data.annotation.Id</code> 将对象中的字段`id`映射为文档的主键 <code>id</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.data.mongodb.core.mapping.DBRef</code> 将对象中的字段 <code>images</code> 映射为一组 <code>com.mongodb.DBRef</code> 。 <code>com.mongodb.DBRef</code> 是指向另一个文档的引用。 <code>@DBRef</code> 可用以标注简单字段或集合字段。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data MongoDB提供的映射注解：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">作用目标</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明该字段是主键。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@MongoId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明该字段是主键，与@Id不同的是其接受一个可选的参数 <code>FieldType</code> 用以自定义变换。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Document</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明该类是要映射至数据库的。同时可以指定对应的collection名穪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@DBRef</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明该字段会被映射为 <code>com.mongodb.DBRef</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Indexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述该字段上的索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@CompoundIndex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述联合索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@GeoSpatialIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述该字段上的地理索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@TextIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述该字段上的文本索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@HashIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">声明该字段上的HASH索引以用于分片集群上分区数据。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Language</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为文本索引设置语言属性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Transient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认所有私有字段都被映射到Mongo文档，该注解可以显式指明不映射该字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PersistenceConstructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">构造器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明在从数据库实例化对象时使用该构造器。构造器的实参则按名穪从数据库文档中获取。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">构造器参数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式声明构造器参数所对应的文档字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式描述字段映射，包括对应文档中字段的名穪和类型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明该字段将作为乐观锁定「Optimistic Locking」机制中的版本属性，在保存变更之前都会先检查版本值是否为所期望的。其初始值为 <code>0</code> ，每次变更都会自动加 <code>1</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="productimage">ProductImage</h4>
<div class="listingblock">
<div class="title">ProductImage.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class ProductImage {
  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String src;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok会在编译期扫描类，为以 <code>@lombok.Getter</code> 注解标注的类中所有成员字段生成getter访问器。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok会在编译期扫描类，为以 <code>@lombok.Setter</code> 注解标注的类中所有成员字段生成setter访问器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 将一个类 <code>ProductImage</code> 映射至MongoDB的Collection <code>ProductImage</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.data.annotation.Id</code> 将对象中的字段 <code>id</code> 映射为文档的主键 <code>id</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="仓库-repository">仓库 Repository</h3>
<div class="paragraph">
<p><code>Repository</code> 是Spring Data抽象的中心接口。应用开发者以 <code>Repository</code> 子接口的形式声明模型Repository及其需支持的数据访问方法，Spring Data的具体数据存储模块（本例中是Spring Data MongoDB）将会为其生成相应的实现类。由于这些实现类仅包含模板代码，所以自动生成可以大幅减少应用开发者重复工作。</p>
</div>
<div class="sect3">
<h4 id="productrepository">ProductRepository</h4>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products")
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>为模型 <code>Product</code> 创建专属的 <code>ProductRepository</code> 接口，继承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> . <code>MongoRepository</code> 继承了接口 <code>PagingAndSortingRepository</code> ，Spring Data MongoDB会其生成一个支持增删改查及分页排序的MongoDB访问实现类。因为 <code>ProductRepository</code> 除了继承的方法声明外，没有声明其它方法，所以Spring Data MongoDB就会直接使用通用的实现类 <code>org.springframework.data.mongodb.repository.support.SimpleMongoRepository&lt;T, ID&gt;</code> 做为其实现。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="productimagerepository">ProductImageRepository</h4>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages")
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>为模型 <code>ProductImage</code> 创建专属的 <code>ProductImageRepository</code> ，继承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="restful-web-服务">RESTful Web 服务</h3>
<div class="paragraph">
<p>Spring Data REST 是Spring Data的一部份，旨于简化在Spring Data仓库上构建hypermedia-driven REST Web服务。应用开发者仅需在依赖中引入 <code>spring-boot-starter-data-rest</code> ，再声明领域模型的仓库，Spring Data REST就会将其发佈为 Hypermedia-Driven REST Web服务。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
    ...
    implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="1"></i><b>(1)</b>
    ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将 <code>spring-boot-starter-data-rest</code> 引入至 <code>implemenation</code> 范围依赖。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RepositoryRestResource</code> 宣告 <code>ProductRepository</code> 的数据访问方法需被曝露为RESTful介面。RESTFul风格的API是以resource为中心，repository所专属的模型就对应为RESTFul中的resource。 <code>@RepositoryRestResource</code> 充许应用开发者自定义模型所对应的resource在URL中及在内容体中的名字。本例中，resource Product的根RESTFul URL定义为 <code>products/</code> 。在HATEOAS标准的内容体中，Product集合会被命名为 <code>products</code> ，例如：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-07T08:04:17.818+0000",
  "updatedAt" : "2019-12-07T08:04:17.818+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data REST有四种仓库检测策略，用以检测哪些仓库应被曝露为REST Web服务。其默认的检测策略是曝露所有公共的仓库接口（除了通过注解显式标注不曝露的仓库），但我推荐使用 <code>ANNOTATION</code> 检测策略，仅曝露以注解 <code>@RepositoryRestResource</code> 显式标注的仓库。以下是Spring Data REST提供的四种仓库检测策略：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名穪</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEFAULT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有公共的仓库但通过注解 <code>@RestResource</code> 和 <code>@RepositoryRestResource</code> 中的 <code>exported</code> 旗标显式标记不曝露的仓库除外。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有仓库，不考虑其可见性或被显式标记为不曝露。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANNOTATED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅曝露被注解 <code>@RestResource</code> 或 <code>@RepositoryRestResource</code> 标记的，且其 <code>exported</code> 旗标不为 <code>false</code> 的仓库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VISIBILITY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">仅曝露公共的且被注解标记的仓库。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring Data REST的检测策略可以通过声明一个 <code>RepositoryRestConfigurer</code> Bean来自定义。</p>
</div>
<div class="paragraph">
<p>　.RepositoryRestConfig.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration <i class="conum" data-value="1"></i><b>(1)</b>
public class RepositoryRestConfig {

  @Bean <i class="conum" data-value="2"></i><b>(2)</b>
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurer() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ANNOTATED); <i class="conum" data-value="3"></i><b>(3)</b>
      }
    };
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Configurition</code> 声明该类为配置类。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在Spring上下文中声明个类型为 <code>RepositoryRestConfigurer</code> 的Bean。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>构造一个子类，并覆写方法 <code>configureRepositoryRestConfiguration</code> ，自定义仓库检测策略为 <code>ANNOTATED</code> 。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用注解 <code>org.springframework.data.rest.core.annotation.RepositoryRestResource</code> 宣告 <code>ProductImageRepository</code> 的数据访问方法需被曝露为RESTFul Web服务。RESTFul Web服务是以资源为中心的， <code>ProductImageRepository</code> 所专属于的领域模型 <code>ProductImage</code> 就对应为RESTFul中的资源。 <code>@RepositoryRestResource</code> 允许应用阙发者自定义模型所对应资源名穪。本例中，资源的名穪为`product`。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="测试">测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个典型的软件测试金字塔自下而上为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单元测试「Unit Test」</p>
</li>
<li>
<p>集成测试「Integration Test」</p>
</li>
<li>
<p>契约测试「Contract Test」</p>
</li>
<li>
<p>端到端测试「End-to-End Test」</p>
</li>
<li>
<p>验收测试「Acceptance Test」</p>
</li>
<li>
<p>功能测试「Function Test」</p>
</li>
<li>
<p>性能测试「Performance Test」</p>
<div class="dlist">
<dl>
<dt class="hdlist1">单元测试</dt>
</dl>
</div>
</li>
</ul>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>单元测试将成为你测试的基石。你的单元测试保证了代码库𥚃的某个单元（被测试的主体）能按照预期那样工作。单元测试在你的测试组合𥚃测试试的范围是最窄的。它的数量在测试组合中应该远远多于其他类型的测试。</p>
</div>
</blockquote>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">集成测试</dt>
</dl>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>所有常见的应用都会和一些外部环境做集成（数据库、文件系统，向其他应用发起网络请求）。为了使测试更好地隔离、运行更快，我们通常不会在编写单元测试时涉及这些外部依赖。不过，这些交互始终是存在的，它们也需要被测试覆盖到。这正是集成测试的用处所在。它们测试的是应用与所有外部依赖的集成。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 测试金字塔实战<br>
<cite>https://insights.thoughtworks.cn/practical-test-pyramid/</cite>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">契约测试</dt>
</dl>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>越来越多现代软件组织发现，对于增长的开发需求，可以让不同的团队来开发同一系统的不同部分。每个团队负责构建独立、松耦合的服务，团队间开发不互相影响。最终再将这些服务集成为一个大而全的系统。最近关于微服务的讨论日益热烈，关注的正是这一点。</p>
</div>
<div class="paragraph">
<p>将系统拆分成多个更小的服务，常常意味着这些服务之间需要通过确定的（最好是定义明确的，但有时候会有变动演进）接口通信。</p>
</div>
<div class="paragraph">
<p>不同应用间的接口可能形态各异，或其于不同的技术栈。常见的有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于 HTTPS 使用 JSON 交互的 REST 接口</p>
</li>
<li>
<p>基于类似 gRPC 的 RPC （Remote Procedure Call，远程进程调用）接口</p>
</li>
<li>
<p>使用队列构建的事件驱动架构</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于任意一个接口，一定会涉及两个实体：提供方和消费方。提供方为消费方提供数据。消费方处理来自提供方的数据。在 REST 世界𥚃，提供方为所有要暴露的 API 创建一个 REST API；消费方则调用这些 API 来获取数据，或进一步触发其他的服务。而在一个由异步、事件驱动的世界，提供方（通常被穪为发佈者）发佈数据到一个队列中；消费方（通常被穪为订阅者）订阅这些队列，读取并处理相关数据。</p>
</div>
<div class="paragraph">
<p>当你把服务消费方和服务提供方分散到不同的团队去时，你就需要清楚地了解这些服务之间的接口（也就是我们所讲的契约）。传统的公司一般是通过以下的方式解决这个问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>写一个鉅细靡遗的接口文档（就是契约）</p>
</li>
<li>
<p>根据定义好的契约实现提供方服务</p>
</li>
<li>
<p>把接口文档扔给隔壁的消费团队</p>
</li>
<li>
<p>等。等到消费方团队实现接口消费部分的工作</p>
</li>
<li>
<p>运行一些大型的、手动的系统测试，保证软件能正常工作</p>
</li>
<li>
<p>祈祷双方团队永远都维持接口定义不变，不要把事情搞砸</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>越来越多现代软件开发团队已经把第五步和第六步用更加自动化的方式来替代：自动代契约测试保证了消费方和提供方实现的时候依然遵循契约。这种测试提供了一个良好的回归测试组合，保证契约的变更能被及早发现。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 测试金字塔实战<br>
<cite>https://insights.thoughtworks.cn/practical-test-pyramid/</cite>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">端到端测试</dt>
<dd>
<p>端到端测试又被穪为广域栈测试，其将系统运行所需的一切组装在一起（包括运行时环境、依赖的外部服务），在系统的边界上测试其行为是否符合预期。对于採有图形用户界面的系统而言，包含图形用户界面行为。而对于仅提供 API 界面的系统而言，仅包含 API 行为测试。</p>
</dd>
<dt class="hdlist1">验收测试</dt>
<dd>
<p>以最终用户的⻆度进行的功能及非功能测试。
我们应权衡考虑测试的覆盖度和编写维护测试代码的工作量。鍳于我们的应用大量使用第三框架，应用开发者编写的代码实际上很少，且是RESTFul的Web服务。所以跳过单元测试和集成测试，仅做契约测试是比较合适的。契约测试又穪为应用编程接口测试「API Test」。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="product-api-测试">Product API 测试</h3>
<div class="paragraph">
<p>Spring Test提供了Spring MVC Test框架，其为Spring MVC代码测试提供了流畅的API，应用开发者可以方便等将其与JUnit、TestNG或其它测试框架集成。</p>
</div>
<div class="paragraph">
<p>本例中，我们集成JUnit和Spring MVC Test框架，实现应用编程接口测试。</p>
</div>
<div class="paragraph">
<p>以测试创建和读取单个Product为例。首先，创建测试目标及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductTest {

  private static final String ENDPOINT = "/products";

  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>

  ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring扩展的JUnit Runner <code>org.springframework.test.context.junit4.SpringRunner</code> 。 <code>SpringRunner</code> 会初始化Spring上下文，从而可以在测试代码中使用依赖注入、模组扫描等Spring特性。默认的JUnit Runner并不会初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 声明测试用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置类，这点我们使用生产代码相同的应用入口类配置测试上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 声明配置MockMvc，然后就可以在测试代码中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 声明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 声明注入ObjectMapper。MockMvc是以包装了HTTP请求和响应的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式与DispatcherServlet通信的，所以需要构造和解析JSON格式的请求体和响应体。在测试代码中使用与被测试代码相同皂JSON序列化和反序列化实现可以避免编解码不一致的麻烦。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 声明注入 <code>ProductImageRepository</code> 。在领域模型中，Product关联ProductImage，所以有些测试用例需要预置ProductImage数据。直接使用 <code>ProductImageRepository</code> 是最直接简单的预置ProductImage数据的方法。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，预置ProductImage数据。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @Before <i class="conum" data-value="1"></i><b>(1)</b>
  public void setUp() {
    ProductImage imageA = new ProductImage(); <i class="conum" data-value="2"></i><b>(2)</b>
    imageA.setSrc("https://aaa.bbb.ccc/ddd.png");
    imageA.setCreatedAt(new Date());
    imageA.setUpdatedAt(new Date());

    imageAId = imageRepository.save(imageA).getId(); <i class="conum" data-value="3"></i><b>(3)</b>

    ProductImage imageB = new ProductImage();
    imageB.setSrc("https://bbb.ccc.ddd/eee.png");
    imageB.setCreatedAt(new Date());
    imageB.setUpdatedAt(new Date());

    imageBId = imageRepository.save(imageB).getId();

    ProductImage imageC = new ProductImage();
    imageC.setSrc("https://ccc.ddd.eee/fff.png");
    imageC.setCreatedAt(new Date());
    imageC.setUpdatedAt(new Date());

    imageCId = imageRepository.save(imageC).getId();
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.junit.Before</code> 声明在执行每个测试方法之前都预置一遍数据。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>构造预置的 <code>ProductImage</code> 对象。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>调用 <code>ProductImageRepository</code> 方法，将预置 <code>ProductImage</code> 对象持久化至数据库</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然后，通过MockMvc向测试目标发送模拟RESTFul HTTP请求并校验响应。</p>
</div>
<div class="paragraph">
<p>Hypertexy Transfer Protocol (HTTP)是一种请求/向应架构的通信协议。其共定义了两种消息包：请求包和向应包。请求包由请求行、标头和消息体三部份构成，向应包由状态行、标头和消息体三部份构成。MockMvc提供了丰富的工具构造请求的各个部份，和校验向应的各个部份。MockMVC是直接与DispatcherServlet交互的，所以其是构造和校验 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对象。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  final String imageALink = obtainLinkOfImage(imageAId);
  final String imageBLink = obtainLinkOfImage(imageBId);

  final String title = "New Product";
  final String ELECTRONICS = "Electronics";
  final String MOBILE = "Mobile";

  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="2"></i><b>(2)</b>
      .andExpect(jsonPath("$.title", is(title))) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", links(), requestFields(
          fieldWithPath("images").type(JsonFieldType.ARRAY)
              .description("links of referred ProductImage")),responseFields()))
      .andReturn().getResponse().getContentAsString();

  String productId = Stream
      .of(objectMapper.readTree(createResponse).at("/_links/self/href").asText().split("/"))
      .reduce((first, second) -&gt; second).orElse(null); <i class="conum" data-value="4"></i><b>(4)</b>

  mvc.perform(get(ENDPOINT + "/{id}", productId).accept(MediaType.APPLICATION_JSON)) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/getOne", links(),
          pathParameters(parameterWithName("id").description("catalog's id")), responseFields()));

  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的构造方法构造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法会从中构造请求实例并发送给DispatcherServlet模拟HTTP请求。（后续为了从测试中生成API文档，我们会换用兼容的 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的构造器方法。 <code>RestDocumentationRequestBuilders</code> 构造方法仅添加了文档描述功能，HTTP协议相关的部份，如HTTP头、响应码等，依旧与 <code>MockMvcRequestBuilders</code> 的构造器相同。）
<div class="paragraph">
<p><code>MockMvcRequestBuilders</code> 提供了对应HTTP协议中定义的九种请求方法中的八种构造方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/MockMvcRequestBuilders.png" alt="MockMvcRequestBuilders" width="493" height="244">
</div>
</div>
<div class="paragraph">
<p>可以发现所有的构造方法都是返回同类型的构造器 <code>MockHttpServletRequestBuilder</code> ，测试代码在获取到 <code>MockHttpServletRequestBuilder</code> 实例后，可以继续设置请求。 <code>MockHttpServletRequestBuilder</code> 提供了很多方法以供设置HTTP请求，这𥚃仅罗列常用的，具体请参阅源代码：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">可设置HTTP请求内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">accept(MediaType&#8230;&#8203; mediaTypes)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Accept`请求头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">contentType(MediaType mediaType)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Content-Type`请求头</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">content(byte[] content)
content(String content)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求体</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>MockMvc的perform方法从构造器中创建mock请求例发送给DispatcherServlet，并将DispatcherServlet的响应包装成 <code>org.springframework.test.web.servlet.ResultActions</code> 。测试代码可以通过 <code>ResultActions</code> 提供的 <code>andExpect</code> 方法校验响应结果；通过 <code>andDo</code> 方法附加一些操作，如打印响应内容等；通过 <code>andReturn</code> 方法读取响应内容以做进一步操作。
<div class="imageblock">
<div class="content">
<img src="../images/ResultActions.png" alt="ResultActions" width="314" height="103">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架提供了丰富的ResultMatcher供应用开发者检验MVC响应的各个部份。所有这些ResultMatcher都通过 <code>org.springframework.test.web.servlet.result.MockMvcResultMatchers</code> 的构造方法获取。 <code>StatusResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一个结果检验器，通过方法 <code>status()</code> 获取，用于检验响应状态码。POST请求意在创建新的实体，在成功创建新实体后RESTFul Web服务应响应状态码 <code>200 Created</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>JsonPathResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一个结果检验器，通过方法 <code>jsonPath(String expression, Matcher&lt;T&gt; matcher)</code> 获取，用于检验JSON格式的响应体。 <code>JsonPathResultMatchers</code> 按JSON路径表逹式从响应体解析出内容，再搭配Hamcrest的检验器就可以检验JSON格式响应体的任意部份。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>新创建Product实体的唯一标识是由MongoDB生成的，且以自身链接的一部份的形式在响应体中返回。（Hypermedia-Driven的RESTFul Web服务在展现实体内容的响应体中包含指hlvlhbr甚它实体或集合的链接，其中就包括指向自身的链接。RESTFul风格的资源URL形式为 <code>/&lt;resources&gt;/&lt;id&gt;</code> ，所以解析单一资源URL最后一部份就可以得到资源唯一标识。）通过 <code>ResultActions</code> 的 <code>andReturn</code> 方法获取包含所有响应信息的对象，再从中读取响应体，再从响应体中解析出自身链接，最后从自身链接中解析出新创建Product实体的唯一标识。
<div class="paragraph">
<p>Spring Data REST对实体内容的编码遵循Hypertext Application Language（HAL）约定。按照HAL，表示实体的JSON中应包含object类型的属性 <code>_links</code> ，而 <code>_links</code> 应包含一个名为 <code>self</code> 的object类型属性， <code>self</code> 应包含名为 <code>href</code> 文本类型的属性， <code>href</code> 即该实体的自身链接。JSON路径 <code>/_links/self/href</code> 应能解析出实体的自身链接。创建Product实体响应体样例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-08T07:10:53.091+0000",
  "updatedAt" : "2019-12-08T07:10:53.091+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的 <code>get</code> 构造方法构造get请求构造器。MockMvc从中构造get请求实例并发送给DispatcherServlet。再使用Spring MVC Test框架提供的结果检验器检验结果。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它Product应用编程接口测试与此相似，这𥚃就不再赘述，请参阅源码。</p>
</div>
</div>
<div class="sect2">
<h3 id="使用嵌入式mongodb-mock-mongodb">使用嵌入式MongoDB mock MongoDB</h3>
<div class="paragraph">
<p>我们的应用编程接口测试依赖运行的MongoDB服务，而可重复执行测试的一个重要特性是「不依赖外部资源或服务」。所以内嵌MongoDB服务是最佳解决方案。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
	...
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo' <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在 <code>de.flapdoodle.embed.mongo</code> 引入Gradle的testImplementation范围依赖。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>spring-boot-autoconfigure担供了嵌入式MongoDB支持，当 <code>de.flapdoodle.embed.mongo</code> 被添加到classpath， <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration</code> 就会被激活，自动配置嵌入式MongoDB。</p>
</div>
<div class="listingblock">
<div class="title">EmbeddedMongoAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableConfigurationProperties({ MongoProperties.class, EmbeddedMongoProperties.class })
@AutoConfigureBefore(MongoAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongodStarter.class })
public class EmbeddedMongoAutoConfiguration {
  ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="productimage-api-测试">ProductImage API 测试</h3>
<div class="paragraph">
<p>首先，创建测试目标及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ActiveProfiles({"test"})
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductImageTest {

  private static final String ENDPOINT = "/productImages";
  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>
  ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring扩展的JUnit Runner <code>org.springframework.test.context.junit4,SpringRunner</code> 。 <code>SpringRunner</code> 会初始化Spring上下文，从而可以在测试中使用依赖注入、模组扫描等Spring特性。默认的JUnit Runner不会初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 声明测试用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置类，这𥚃我们使用生产代码相同的应用入口类配置测试上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 声明配置MockMvc，然后就可以在测试代码中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 声明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframeowrk.beans.factory.annotation.Autowired</code> 声明注入ObjectMapper。MockMvc是以包装HTTP请求和响应的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式与DispatcherServlet通信的，所以需要构造和解析JSON格式的请求体和响戈人心土体。在测试代码中使用与被测试代码相同的JSON序列化和反序列化实现可以避免编解码不一致的麻烦。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 声明注入ProductImageRepository，用于在测试之后清理数据库中的ProductImage数据，避免测试之间互相干扰。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，通过MockMvc向测试目标发送模拟RESTFul HTTP请求并检验响应。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testSaveAndGetOne() throws Exception {
  final String src = "https://aaa.bbb.ccc/ddd.png";
  ProductImage newImage = new ProductImage();
  newImage.setSrc(src);

  ArgumentCaptor&lt;String&gt; linkMatcher = ArgumentCaptor.forClass(String.class);
  String responseContent = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(objectMapper.writeValueAsString(newImage))) <i class="conum" data-value="2"></i><b>(2)</b>
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON)) <i class="conum" data-value="4"></i><b>(4)</b>
      .andExpect(jsonPath("$.src", is(src))) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andDo(document("productImage/create",
          links(),
          requestFields(),
          responseFields(
              subsectionWithPath("_links").description("links to other resources"))))
      .andReturn().getResponse().getContentAsString();
  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的构造方法构造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法会从中构造请求实例并发送给DispatcherServlet模拟HTTP请求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <code>objectMapper</code> 将 <code>ProductImage</code> 对象序列化成JSON格式的字符串，填充为请求的消息体。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>status()</code> 检验响应状态码。对应成功处理的创建请求，RESTFul Web服务应响应 <code>201 Created</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用 <code>content()</code> 检验响应头 <code>Content-Type</code> 应为 <code>application/json</code> 或相容的其它媒体类型。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>jsonPath()</code> 检验响应消息体的各个部份。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它ProductImage应用编程接口测试与此类似，这𥚃就不赘述了，详情请参阅源码。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-文档">API 文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用Spring REST Docs，从应用编程接口测试中生成API文档。</p>
</div>
<div class="paragraph">
<p>首先，引入Spring REST Docs及Asciidoctor依赖，并引入Asciidoctor插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id 'org.asciidoctor.convert' version '1.5.3' <i class="conum" data-value="1"></i><b>(1)</b>
}
...
depedencies {
  asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor' <i class="conum" data-value="2"></i><b>(2)</b>
  ...
  testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc' <i class="conum" data-value="3"></i><b>(3)</b>
}
...
ext {
	snippetsDir = file('build/generated-snippets') <i class="conum" data-value="4"></i><b>(4)</b>
	...
}

test {
	outputs.dir snippetsDir <i class="conum" data-value="5"></i><b>(5)</b>
}

asciidoctor { <i class="conum" data-value="6"></i><b>(6)</b>
	inputs.dir snippetsDir
	dependsOn test
}
...
bootJar { <i class="conum" data-value="7"></i><b>(7)</b>
	dependsOn asciidoctor
	from ("${asciidoctor.outputDir}/html5") {
		into 'static/docs'
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入Asciidoctor的Gradle插件 <code>org.asciidoctor.convert</code> ，其会引入Gradle task <code>asciidoctor</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将 <code>spring-restdocs-asciidoctor</code> 引入至Gradle的asciidoctor范围依赖，asciidoctor范围是Asciidoctor插入扩展的，仅对Asciidoctor插件起效。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将 <code>spring-restdocs-mockmvc</code> 引入Gradle的 <code>testImplementation</code> 范围依赖，版本由Spring Boot Gradle插入统一控制。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>声明变量 <code>snippetsDir</code> 为Spring REST Docs输出HTTP请求响应片断的根目录。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>设置测试任务的输出目录为 <code>snippetsDir</code> 。Spring REST Docs是做为测试的一部份被执行的，其输出根目录即测试的输出相录即 <code>snippetsDir</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>配置Gradle任务asciidoctor，将 <code>snippetsDir</code> 添加为输入目录，Asciidoc文档就可以引用Spring REST Docs截取的HTTP请求响应片断了；并该任务 <code>asciidoctor</code> 依赖任务 <code>test</code> ，因为任务 <code>asciidoctor</code> 所需的请求响应片断是在任务 <code>test</code> 中产生的，所以任务 <code>asciidoctor</code> 必须在任务 <code>test</code> 之后执行。任务 <code>asciidoctor</code> 是由Asciidoctor插件提供的。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>配置Gradle任务 <code>bootJar</code>，使其依赖任务 <code>asciidoctor</code> ，并将经 <code>asciidoctor</code> 转换后的HTML格式文档打包至 <code>flatjar</code> 中，置于路径 <code>static/docs</code> 。Spring Boot默认将 <code>static/docs</code> 下的内容以静态文件的形式发佈至URL <code>/docs/</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后，在测试中激活Spring REST Docs配置。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class)
@SpringBootTest(classes = CatalogApplication.class)
@AutoConfigureMockMvc
@AutoConfigureRestDocs <i class="conum" data-value="1"></i><b>(1)</b>
public class ProductTest {
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs</code> 激活Spring REST Docs自动配置。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然后，用 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的mock请求构造方法替换 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的mock请求构造方法。 <code>RestDocumentationRequestBuilders</code> 构造方法返回与 <code>MockMvcRequestBuilders</code> 构造方法相同的 <code>MockHttpServletRequestBuilder</code> 。不同的是， <code>RestDocumentationRequestBuilders</code> 往 <code>MockHttpServletRequestBuilder</code> 中添加了请求属性 <code>ATTRIBUTE_NAME_URL_TEMPLATE</code> ，使其可以从mock请求的URL模格中解析出实参。</p>
</div>
<div class="listingblock">
<div class="title">RestDocumentationRequestBuilders.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
public static MockHttpServletRequestBuilder get(String urlTemplate,
		Object... urlVariables) {
	return MockMvcRequestBuilders.get(urlTemplate, urlVariables).requestAttr(
			RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE, urlTemplate); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>RestDocumentationRequestBuilders</code> 在每个接受URL模板的构造方法中都将URL模格注册为请求属性，以备 <code>PathParametersSnippet</code> 从获取请求URL中的参数化部份，如资源唯一标识等。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">PathParametersSnippet.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private String extractUrlTemplate(Operation operation) {
	String urlTemplate = (String) operation.getAttributes()
			.get(RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE); <i class="conum" data-value="1"></i><b>(1)</b>
	Assert.notNull(urlTemplate, "urlTemplate not found. If you are using MockMvc did "
			+ "you use RestDocumentationRequestBuilders to build the request?");
	return urlTemplate;
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>PathParametersSnippet</code> 从请求属性中读取URL模板。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然后，在测试中截取请求响应片断并注释。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  ...
  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", <i class="conum" data-value="1"></i><b>(1)</b>
              links(), <i class="conum" data-value="2"></i><b>(2)</b>
              requestFields( <i class="conum" data-value="3"></i><b>(3)</b>
                fieldWithPath("images").type(JsonFieldType.ARRAY)
                  .description("links of referred ProductImage")),
              responseFields())) <i class="conum" data-value="4"></i><b>(4)</b>
      .andReturn().getResponse().getContentAsString();
...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document(String identifier, Snippet&#8230;&#8203; snippets)</code> 方法构造一个 <code>org.springframework.restdocs.mockmvc.RestDocumentationResultHandler</code> 实例。 <code>RestDocumentationResultHandler</code> 实现了接口 <code>org.springframework.test.web.servlet.ResultHandler</code> ，可以作为 <code>org.springframework.test.web.servlet.ResultActions.andDo(ResultHandler handler)</code> 的参数，完美地嵌入MockMvc测试。
<div class="olist arabic">
<ol class="arabic">
<li>
<p>参数 <code>identitifer</code> 指明截取片断的输出住置。 <code>document("product/create"</code> 将把该测试过程中截取的片断输出至 <code>$snippetsDir/product/create</code> 。</p>
</li>
<li>
<p><code>document</code> 接受零至多个Snippet。</p>
</li>
</ol>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>构造专用于Hypermedia的 <code>org.springframework.restdocs.hypermedia.LinksSnippet</code> 。本例为了在多个测试中重用 <code>Product</code> 的 <code>LinksSnippet</code> ，而使用自定义构造方法构造 <code>Product</code> 的 <code>LinksSnippet</code>。
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static LinksSnippet links(LinkDescriptor... descriptors) {
  return HypermediaDocumentation.links(halLinks(), linkWithRel("self").description("self link"),
      linkWithRel("product").description("self link"),
      linkWithRel("images").description("related images")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服务是以资源为中心的，Hypermedia-Driven RESTFul Web服务当然依旧是以资源为中心的，资源实例的结构是相对穏定的。再加上HAL定义了一些通用的链接，所以 <code>Product</code> 的链接结构在任何场景下都是相同的。所以我们就可以使用同一构造方法为不同场景构造 <code>LinksSnippet</code> 。 <code>LinksSnippet</code> 由一系列的 <code>org.springframework.restdocs,hypermedia.LinkDescriptor</code> 组成，每一个 <code>LinkDescriptor</code> 截取和注释一个链接。上述 <code>LinksSnippet</code> 截取的片断样例（asciidoc格式的，且包含了注释）：</p>
</div>
<div class="listingblock">
<div class="title">links.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Relation|Description

|`+self+`
|self link

|`+product+`
|self link

|`+images+`
|related images

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>经Asciidoctor渲染后为：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>self</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>product</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">related images</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>构造 <code>org.springframework.restdocs.payload.RequestFieldsSnippet</code> ，以截取和注释请求消息体。因同一类资源在不同场景下结构相同，所以这𥚃也通过自定义构造方法重用请求消息体 <code>Snippet</code>。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static RequestFieldsSnippet requestFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.requestFields(
    fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp").optional()
          .ignored(),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp").optional()
          .ignored()).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RequestFieldsSnippets</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 组成，每个 <code>FieldDescriptor</code> 截取和注释请求消息体的一部份。上述 <code>RequestFieldsSnippet</code> 截取的片断样例（asciidoc格式且包含注释）：</p>
</div>
<div class="listingblock">
<div class="title">request-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog title

|`+tags+`
|`+Array+`
|tags

|`+images+`
|`+Array+`
|links of referred ProductImage

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>经Asciidoctor渲染后为：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links of referred ProductImage</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构造 <code>org.springframework.restdocs.payload.ResponseFieldsSnippet</code> 截取和注释响应消息体。这𥚃依旧通过自定构造方法重用响应消息体 <code>Snippet</code> 。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static ResponseFieldsSnippet responseFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.responseFields(
      fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp"),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp"),
      subsectionWithPath("_links").description("links to other resources")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ResponseFieldsSnippet</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 组成。每个 <code>FieldDescriptor</code> 截取和注释响应消息体的一部份。上述 <code>ResponseFieldSnippet</code> 截取的片断样例（asciidoc格式且包含注释）：</p>
</div>
<div class="listingblock">
<div class="title">response-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog title

|`+tags+`
|`+Array+`
|tags

|`+createdAt+`
|`+Date+`
|create timestamp

|`+updatedAt+`
|`+Date+`
|last update timestamp

|`+_links+`
|`+Object+`
|links to other resources

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>经Asciidoctor渲染后为：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>createdAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">create timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>updatedAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last update timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_links</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links to other resources</p></td>
</tr>
</tbody>
</table></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后，编写asciidoc文档并在其中引用截取的片断。</p>
</div>
<div class="listingblock">
<div class="title">product.adoc</div>
<div class="content">
<pre>== Create

Endpoint `products`.

=== Request

include::{snippets}/product/create/http-request.adoc[]

*Request Fields:*

include::{snippets}/product/create/request-fields.adoc[]

=== Response

include::{snippets}/product/create/http-response.adoc[]

*Response Fields:*

include::{snippets}/product/create/response-fields.adoc[]</pre>
</div>
</div>
<div class="paragraph">
<p>经Asciidoctor渲染后的样例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/spring-rest-docs-product-example.png" alt="spring rest docs product example">
</div>
</div>
<div class="paragraph">
<p>其它API文档生成方式与此相同，这𥚃就不再赘述，请参阅源码。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="总结">总结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章我们使用Spring Data REST从Spring Data仓库上创建领域模型 <code>Product</code> 和 <code>ProductImage</code> 的Hypermedia-Driven RESTFul Web服务，使用Spring Data MongoDB生成领域模型 <code>Product</code> 和 <code>ProductImage</code> 的MongoDB访问仓库实现，使用Spring MVC Test框架测试应用编程接口，使用Spring REST Docs从测试中生成准确、易读的API文档。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="参考">参考</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/">Spring Data Commons - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/">Spring Data MongoDB - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/rest/docs/current/reference/html/">Spring Data REST Reference Guide</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.0.1<br>
Last updated 2020-09-27 05:55:07 UTC
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>