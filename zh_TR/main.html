<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>使用 Spring Boot &amp; Cloud 構建微服務（Microservices）</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>使用 Spring Boot &amp; Cloud 構建微服務（Microservices）</h1>
<div class="details">
<span id="revnumber">version 0.0.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#介紹">介紹</a>
<ul class="sectlevel2">
<li><a href="#概述">概述</a></li>
<li><a href="#用例">用例</a></li>
<li><a href="#架構">架構</a></li>
<li><a href="#參考">參考</a></li>
</ul>
</li>
<li><a href="#工具設置">工具設置</a>
<ul class="sectlevel2">
<li><a href="#概述-2">概述</a></li>
<li><a href="#java-development-kit-jdk">Java Development Kit (JDK)</a></li>
<li><a href="#intellij-idea">Intellij IDEA</a></li>
<li><a href="#docker">Docker</a></li>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#參考-2">參考</a></li>
</ul>
</li>
<li><a href="#catalog-service">Catalog Service</a>
<ul class="sectlevel2">
<li><a href="#目標">目標</a></li>
<li><a href="#設計">設計</a></li>
<li><a href="#實現">實現</a></li>
<li><a href="#測試">測試</a></li>
<li><a href="#api文檔">API文檔</a></li>
<li><a href="#總結">總結</a></li>
<li><a href="#參考-3">參考</a></li>
</ul>
</li>
<li><a href="#服務注冊與發現service-registry-discovery">服務注冊與發現「Service Registry &amp; Discovery」</a>
<ul class="sectlevel2">
<li><a href="#目標-2">目標</a></li>
<li><a href="#理解服務注冊與發現service-registry-discovery">理解服務注冊與發現「Service Registry &amp; Discovery」</a></li>
<li><a href="#理解eureka">理解Eureka</a></li>
<li><a href="#實現-2">實現</a></li>
<li><a href="#總結-2">總結</a></li>
<li><a href="#參考-4">參考</a></li>
</ul>
</li>
<li><a href="#api-gateway">API Gateway</a>
<ul class="sectlevel2">
<li><a href="#目標-3">目標</a></li>
<li><a href="#理解api-gateway模式">理解API Gateway模式</a></li>
<li><a href="#理解spring-cloud-gateway">理解Spring Cloud Gateway</a></li>
<li><a href="#理解cross-origin-resource-sharingcors">理解Cross-Origin Resource Sharing(CORS)</a></li>
<li><a href="#實現-3">實現</a></li>
<li><a href="#總結-3">總結</a></li>
<li><a href="#參考-5">參考</a></li>
</ul>
</li>
<li><a href="#security">Security</a>
<ul class="sectlevel2">
<li><a href="#目標-4">目標</a></li>
<li><a href="#認證與授權">認證與授權</a></li>
<li><a href="#設計-2">設計</a></li>
<li><a href="#實現-4">實現</a></li>
<li><a href="#測試-2">測試</a></li>
<li><a href="#參考-6">參考</a></li>
</ul>
</li>
<li><a href="#inventory">Inventory</a>
<ul class="sectlevel2">
<li><a href="#目標-5">目標</a></li>
<li><a href="#設計-3">設計</a></li>
<li><a href="#實現-5">實現</a></li>
<li><a href="#參考-7">參考</a></li>
</ul>
</li>
<li><a href="#訂單服務order-service">訂單服務「Order Service」</a>
<ul class="sectlevel2">
<li><a href="#目標-6">目標</a></li>
<li><a href="#需求分析">需求分析</a></li>
<li><a href="#設計-4">設計</a></li>
<li><a href="#實現-6">實現</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="介紹"><a class="link" href="#介紹">介紹</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="概述"><a class="link" href="#概述">概述</a></h3>
<div class="paragraph">
<p>本文以線上商店為例，介紹基於 Spring Boot 及 Spring Cloud 開發微服務「Microservices」應用。</p>
</div>
<div class="paragraph">
<p>本文將會囊括技術：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Boot</p>
</li>
<li>
<p>Spring Data MongoDB</p>
</li>
<li>
<p>Spring Data JPA</p>
</li>
<li>
<p>Spring Data REST</p>
</li>
<li>
<p>Spring Security</p>
</li>
<li>
<p>Service Registration &amp; Discovery</p>
</li>
<li>
<p>API Gateway Pattern</p>
</li>
<li>
<p>Single Sign On</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="用例"><a class="link" href="#用例">用例</a></h3>
<div class="imageblock">
<div class="content">
<img src="images/diag-0fe6382e06856f31f75912ca87ada2c5.png" alt="diag 0fe6382e06856f31f75912ca87ada2c5" width="391" height="662">
</div>
<div class="title">Figure 1. use cases</div>
</div>
<div class="paragraph">
<p>整個業務由三個子業務組成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>商品目錄營運</p>
</li>
<li>
<p>倉儲營運</p>
</li>
<li>
<p>訂單交易</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>業務參與者劃分為四個⻆色：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>商品目錄運營</p>
</li>
<li>
<p>倉儲運營</p>
</li>
<li>
<p>訂單運營</p>
</li>
<li>
<p>顧客</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在商品目錄營運子業務中，商品目錄運營參與了三個用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新建商品。作為商品目錄運營，其可以新建商品項。商品拥有名穪、圖片等屬性；</p>
</li>
<li>
<p>修改商品。作為商品目錄運營，其可以修改商品的名穪、圖片等屬性；</p>
</li>
<li>
<p>刪除商品。作為商品目錄運營，其可以刪除不再銷售的商品。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在倉儲營運子業務中，倉儲運營參與了三個用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新建倉儲項。作為倉儲運營，其可以為每一項商品建立相應的倉儲項，倉儲項拥有單價、庫存量等屬性；</p>
</li>
<li>
<p>入庫。作為倉儲運營，其可以增加任意倉儲項的庫存量；</p>
</li>
<li>
<p>出庫。作為倉儲運營，其可以減少任意倉儲項的庫存量。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在訂單交易子業務中，顧客與訂單運營共同參與了七個用例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新建訂單。作為顧客，其可以新建訂單。每個訂單都可以包含若干訂單項，每項指明了商品及購買數量；</p>
</li>
<li>
<p>提交訂單。作為顧客，其可以提交訂單。訂單一但被提交，將從倉儲中消減相應倉儲項的庫存量；</p>
</li>
<li>
<p>取消訂單。作為顧客，其可以取消新建的訂單；</p>
</li>
<li>
<p>支付訂單。作為顧客，其可以支付已提交的訂單；</p>
</li>
<li>
<p>發貨。作為訂單運營，其可以將已支付的訂單標記為「已發貨」；</p>
</li>
<li>
<p>交貨。作為訂單運營，其可以在貨物交至顧客手中之後將訂單標記為「已交貨」；</p>
</li>
<li>
<p>結束訂單。作為顧客，其可以在貨物送逹後，結束訂單。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="架構"><a class="link" href="#架構">架構</a></h3>
<div class="paragraph">
<p>本應用採用微服務架構，同時應用API網關模式。</p>
</div>
<div class="sect3">
<h4 id="微服務"><a class="link" href="#微服務">微服務</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>微服務（Microservices）是一種軟體架構風格，它是以專注於單一責任與功能的小型功能區塊（Small Building Blocks）為基礎，利用模組化的方式組合出複雜的大型應用程式，各功能區塊使用與語言無關（Language-Independent/Language agnostic）的 API 集相互通訊。</p>
</div>
<div class="paragraph">
<p>微服務的起源是由 Peter Rodgers 博士於 2005 年度雲端運算博覽會提出的微 Web 服務（Micro-Web-Service）開始，Juval Löwy 則是與他有類似的前導想法，將類別變成細粒服務（granular services），以作為 Microsoft 下一階段的軟體架構，其核心想法是讓服務是由類似 Unix 管道的存取方式使用，而且複雜的服務背後是使用簡單 URI 來開放介面，任何服務，任何細粒都能被開放（exposed）。這個設計在 HP 的大田大金驗室被實現，具有改變複雜軟體系統的強大力量。</p>
</div>
<div class="paragraph">
<p>2014年，Martin Fowler 與 James Lewis 共同提出了微服務的概念，定義了微服務是由以單一應用程式構成的小服務，自己擁有自己的行程與輕量化處理，服務依業務功能設計，以全自動的方式部署，與其他服務使用 HTTP API 通訊。同時服務會使用最小的規模的集中管理（例如 Docker）能力，服務可以用不同的程式語言與貨料庫等元作實作。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 微服務<br>
<cite>https://zh.wikipedia.org/wiki/微服務</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>微服務是一種以業務功能為主的服務設計概念，每一個服務都具有自主運行的業務功能，對外開放不受語言限制的 API（最常用的是 HTTP），應用程式則是由一個或多個微服務組成。</p>
</div>
<div class="paragraph">
<p>微服務的另一個對比是單體式應用程式。單體式應用表示一個應用程式內包含了所有需要的業務功能，並且使用像主從式架構（Client/Server）或是多層次架構（N-tier）實作，雖然它也是能以分散式應用程序來實作，但是在單體式應用內，每一個業務功能是不可分割的。若要對單體式應用進行擴展則必須將整個應用程式都放到新的運算資源（如：虛擬機器）內，但事實上應用程式中最吃資源、需要運算資源的僅有某個業務部份（例如跑分析報表或是數學演算法分析），但因為單體式應用無法分割該部份，因此無形中會有大量的資源浪費的現象。</p>
</div>
<div class="paragraph">
<p>微服務運用了以業務功能的設計概念，應用程式在設計時就能先以業務功能或流程設計先行分割，將各個業務功能都獨立實作成一個能自主執行的個體服務，然後再利用相同的協定將所有應用程式需要的服務都組合起來，形成一個應用程式。若需要針對特定業務功能進行擴充時，祗要對該業務功能的服務進行擴展就好，不需要整個應用程式都擴展，同時，由於微服務是以業務功能導向的實作，因此不會受到應用程式的干擾，微服務的管理員可以視運算資源的需要來組態微服務到不同的運算資源內，或是布建新的運算資源並將它組態進去。</p>
</div>
<div class="paragraph">
<p>雖然使用一般的伺服器虛擬化技術就能應用於微服務的管理，但容器技術（Container Technology）如 Docker 會更加地適合發展微服務的運算資源管理技術。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 微服務<br>
<cite>https://zh.wikipedia.org/wiki/微服務</cite>
</div>
</div>
<div class="paragraph">
<p>總體業務分為三個部份：商品目錄營運、倉儲營運和訂單交易，每部份業務分別實現為一個微服務：Catalog Service, Inventory Service 和 Order Service。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-f432ac11c8f2d40a97380e7359579d60.png" alt="diag f432ac11c8f2d40a97380e7359579d60" width="301" height="226">
</div>
<div class="title">Figure 2. Map Bounded Context to Service</div>
</div>
<div class="paragraph">
<p>每個微服務有維護獨立的數據庫。微服務以RESTFul API的形式向外曝露服務，同時微服務與微服務之間也通過 RESTFul API 通信。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-6bad0d2a286ea1ebb9f7a942a61cd91b.png" alt="diag 6bad0d2a286ea1ebb9f7a942a61cd91b" width="462" height="268">
</div>
<div class="title">Figure 3. Microservices Architecture</div>
</div>
</div>
<div class="sect3">
<h4 id="api-網關模式"><a class="link" href="#api-網關模式">API 網關模式</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>使用多個客戶端應用來設計和生成基於微服務的大型複雜應用程序時， API 網關是非常不錯的方法。這一服務可為某些微服務組提供單一入口點。這類似於面嚮對象設計的外觀模式，但在此情況下，它是分佈式系統的一部份。因為構建時考慮了客戶端應用的需求，所以 API 網關模式有時也穪為"用於前端的後端"（BFF）。</p>
</div>
<div class="paragraph">
<p>因此，API 網關位於客戶端應用和微服務之間。它充當反嚮代理，將請求從客戶端路由到服務。它還可以提供其他跨領域功能，例如身份驗證、SSL 終止和緩存。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; API 網關模式與客戶端到微服務直接通信<br>
<cite>https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>API 網關可以提供多個功能。然而，根據產品，它可能提供更豐富或更簡單的功能，任何 API 網關最重要和最基本的功能都採用以下設計模式：</p>
</div>
<div class="paragraph">
<p>反嚮代理或網關路由。API 網關提供一個反嚮代理將請求（第 7 層路由，通常是 HTTP 請求）重定嚮或路由到內部微服務的終結點。網關為客戶端應用提供單個終結點或 URL，然後將請求映射到一組內部服務。此路由功能有助於將客戶端應用從微服務中分離出來；而且在升級整體式 API 服務時，將 API 網關置於整體式 API 服務和客戶端應用之間，操作會變得非常方便，然後可以添加新的 API 作為新的微服務，同時仍然可以使用整體式 API 服務，直到將來它拆分成多個微服務為止。由於 API 網關，客戶端應用不會注意到所使用 API 是否已實現為內部微服務或整體式 API，更重要的是，當對整體式 API 進行演進並將其重構為微服務時，得益於 API 網關路由，任何 URI 更改土心山一不會對客戶端應用造成影响。</p>
</div>
<div class="paragraph">
<p>請求聚合。作為網關模式的一部份，你可以將多個針對多個內部微服務的客戶端請求（通常是 HTTP 請求）聚合到單個客戶端請求中。如果客戶端頁面/屏幕需要來算多個微服務的信息，此模式特別方便。通過這種方法，客戶端應用嚮 API 網關發送一個單一請求，該網關嚮內部微服務發送多個請求，然後聚合結果，並將所有內容發送迴客戶端應用。這種設計模式的主要優勢和目標是減少客戶端應用和後端 API 之間的隔閡，這對於微服務所在的數據中心中的遠程應用至關重要，如移動應用或來算客戶端遠程瀏覽器 Javascript 的 SPA 應用發出的請求。對於在服務器環境中執行請求的常規 Web 應用（如 ASP.NET Core MVC Web 應用），這種模式並不重要，因為延遲時間比遠程客戶端應用要小得多。</p>
</div>
<div class="paragraph">
<p>跨領域問題或網關卸載。根據每個 API 網關產品提供的功能，你可以將功能從單個微服務轉移到網關，從而通過將跨領域問題整合到一個層級中來簡化每個微服務的實現。這對於在每個內部微服務中難以正確實現的特殊功能而言特別方便，比如以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>身份驗證和授權</p>
</li>
<li>
<p>服務發現集成</p>
</li>
<li>
<p>响應緩存</p>
</li>
<li>
<p>重試策略、斷路器和 QoS</p>
</li>
<li>
<p>速率限制和遏制</p>
</li>
<li>
<p>負載均衡</p>
</li>
<li>
<p>日志記錄、跟踪、相關性</p>
</li>
<li>
<p>標頭、查詢字符串和聲明轉換</p>
</li>
<li>
<p>IP 允許列表</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; API 網關模式與客戶端到微服務直接通信<br>
<cite>https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern</cite>
</div>
</div>
<div class="paragraph">
<p>本應用採用 API 網關模式實現網關路由及身份驗證、服務發現集成、負載均衡等跨領域問題。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-20fe376f836d9a8487e98a89eb84e19e.png" alt="diag 20fe376f836d9a8487e98a89eb84e19e" width="531" height="443">
</div>
<div class="title">Figure 4. Deployment Architecture</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="參考"><a class="link" href="#參考">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.omg.org/spec/UML/2.5.1/PDF">OMG® Unified Modeling Language® (OMG UML®)</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/微服務">微服務</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="工具設置"><a class="link" href="#工具設置">工具設置</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="概述-2"><a class="link" href="#概述-2">概述</a></h3>
<div class="paragraph">
<p>本章介紹在 MacOS, Windows 和 Ubuntu Linux 三個主流操作系統上安裝設置開發所需的 SDK 和工具。我們所需的 SDK 和工具包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java Development Kit (JDK) 1.8 及以上</p>
</li>
<li>
<p>Intellij IDEA</p>
</li>
<li>
<p>Docker</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="java-development-kit-jdk"><a class="link" href="#java-development-kit-jdk">Java Development Kit (JDK)</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Java Development Kit（JDK）是昇陽電腦針對 Java 開發人員發布的免費軟體開發套件（SDK，Software development kit）。自從 Java 推出以來，JDK 已經成為使用最廣泛的 Java SDK。由於 JDK 的一部份特性採用商業許可證，而非開源。因此，2006年昇陽電腦宣布將發布基於 GPL 的開源 JDK，使 JDK 成為自由軟體。在去掉了少量閉源特性之後，昇陽電腦最終促成了 GPL 的 OpenJDK 的發布。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; JDK<br>
<cite>https://zh.wikipedia.org/wiki/JDK</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>JDK 包含了一批用於 Java 開發的組件，其中包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>javac：編譯器，將字尾名為「.java」的原始碼編譯成字尾名為「.class」的位元組碼</p>
</li>
<li>
<p>java：執行工具，執行「.class」的位元組碼</p>
</li>
<li>
<p>jar：打包工具，將相關的類檔案打包成一個檔案</p>
</li>
<li>
<p>javadoc：文件生成器，從原始碼注釋中提取文件，注釋需符合規範</p>
</li>
<li>
<p>jdb debugger：除錯工具</p>
</li>
<li>
<p>jps：顯示當前 Java 程式執行的行程狀態</p>
</li>
<li>
<p>javap：反編譯程式</p>
</li>
<li>
<p>appletviewer：執行和除錯 applet 程式的工具，不需要使用瀏覽器</p>
</li>
<li>
<p>javah：從 Java 類別生成 C 標頭檔和 C 原始檔。這些檔案提供了連接膠合，使 Java 和 C 代碼可進行互動</p>
</li>
<li>
<p>javaws：執行 JNLP 程式</p>
</li>
<li>
<p>extcheck：一個檢測 jar 包衝突的工具</p>
</li>
<li>
<p>apt：注釋處理工具</p>
</li>
<li>
<p>jhat：Java 堆分析工具</p>
</li>
<li>
<p>jstack：棧跟蹤程式</p>
</li>
<li>
<p>jstat：JVM 檢測統計工具</p>
</li>
<li>
<p>jstatd：jstat 守護行程</p>
</li>
<li>
<p>jinfo：取得正在執行或崩潰的 Java 程式組態資訊</p>
</li>
<li>
<p>jmap：取得 Java 行程記憶體對映資訊</p>
</li>
<li>
<p>idlj：IDL-to-Java 編釋器。將 IDL 語言轉化為 Java 檔案</p>
</li>
<li>
<p>policytool：一個 GUI 的策略檔案建立和管理工具</p>
</li>
<li>
<p>jrunscript：命令行指令碼執行</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>JDK 中還包括完整的 JRE（Java Runtime Environment），Java 執行環境，也被穪為 private runtime。包括了用於產品環境的各種庫類，如基礎類別館 rt.jar，以及給開發人員使用的補充庫，如國際化與在地化的類別館、IDL 庫等等。</p>
</div>
<div class="paragraph">
<p>JDK 中還包括各種樣常式序，用以展示 Java API 中的各部份。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; JDK<br>
<cite>https://zh.wikipedia.org/wiki/JDK</cite>
</div>
</div>
<div class="paragraph">
<p>當前市面上主流的 JDK 實現有 Oracle JDK 和 OpenJDK。兩者皆源自昇陽電腦「Sun Microsustems」。Oracle JDK並非完全開源，Oracle公司通過收購穫得其所有權。OpenJDK是採用 GPL 的完全開源實現。本文使用 Oracle JDK。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Java 語這自 JDK 1.0 版本以來經歷了許多次更新，也在基本程式庫中增加了大量的類別和套件。從 J2SE 1.4 開始，Java 語這的變動由 Java Community Process（JCP）管理，JCP 使用 Java 規範請求（Java Specification Requests，JSRs）來建議和定義對 Java 平台內容的新增和修改。Java 語言由 Java 語言規範（Java Language Specification，JLS）定義，對 JLS 的更改則根據 JSR 901 管理。</p>
</div>
<div class="paragraph">
<p>除了語言上的變化，多年來 Java 標準庫（JCL）發生了巨大的變化，從 JDK 1.0 中的幾百個類暴增到 J2SE 5 中的三千多個類。Swing、Java2D 等全新 API 被加入其中，而許多原本 JDK 1.0 的類和方法已被棄用。當然，仍然有一些程式可以將 Java 程式從新版本的 Java 平台轉換為較舊版本（例如 Java 5.0 降轉到 1.4）。</p>
</div>
<div class="paragraph">
<p>Java 7 發布後，Oracle 承諾回到以前每兩年發布一次的發布週期。但在2013年時，Oracle 卻宣布他們將 Java 8 延遲一年發表，官方表示是為了修復 Java 的安全漏洞。</p>
</div>
<div class="paragraph">
<p>2017年9月，Java 平台的主架構師 Mark Reinhold 發出提議，要求將 Java 的功能更新週期從之前的每兩年一個新版本縮減到每六個月一個新版本。該提議獲得了通過，並在提出後不久生效。</p>
</div>
<div class="paragraph">
<p>Java 8 與 Java 11 為目前提供支援的 LTS（長期支援）版本；Java 10 是上一個快速發布版本，且不再被支援。2018年9月，隨着 Java 11 的發布，Java 10 自當日起不再被支援。Oracle 將在2019年1月前為商業用途的 Java 8 長期支援，而針對非商用的更新將繼續提供，直至2020年12月；此外，AdpotOpenJDK 也為 Java 8 提供免費更新。針對 Java 11 的長期支援將不再由 Oracle 提供，而是改由 OpenJDK 社區的 AdoptOpenJDK 提供。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Java 版本歷史<br>
<cite>https://zh.wikipedia.org/wiki/Java版本歷史</cite>
</div>
</div>
<div class="paragraph">
<p>綜合考量特性和支援，本文選用最後一個由 Oracle 提供長期支持的 Java 8。</p>
</div>
<div class="sect3">
<h4 id="在-windows-上安裝-oracle-jdk"><a class="link" href="#在-windows-上安裝-oracle-jdk">在 Windows 上安裝 Oracle JDK</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-macos-上安裝-oracle-jdk"><a class="link" href="#在-macos-上安裝-oracle-jdk">在 macOS 上安裝 Oracle JDK</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-ubuntu-linux-上安裝-oracle-jdk"><a class="link" href="#在-ubuntu-linux-上安裝-oracle-jdk">在 Ubuntu Linux 上安裝 Oracle JDK</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="intellij-idea"><a class="link" href="#intellij-idea">Intellij IDEA</a></h3>
<div class="paragraph">
<p>IntellJ IDEA 是一種商業化銷售的 Java 整合式開發環境（Integrated Development Environment，IDE）工具軟體，由 JetBrains 軟體公司（前穪 IntellijJ）開發，提供 Apache 2.0 開放式授權的社區版本以及專有軟體的商業版本，開發者可選擇其所需來下載使用。</p>
</div>
<div class="paragraph">
<p>IntelliJ IDEA 針對應用開發，集成了衆多功能，如智能補全、鏈式補全、靜態成員補全、數據流分析、語言注入、跨語言重構、檢測重復項、檢查與快速修復等。有些功能是收費的 Ultimate 版才享有，但其免費的 Community 版所包含的功能已足够豐富，足以滿足大多數開發者的需求。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>若想瞭解更多 IntelliJ IDEA 功能特性及版本差異，請參閱 <a href="https://www.jetbrains.com/zh-cn/idea/features" class="bare">https://www.jetbrains.com/zh-cn/idea/features</a>。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="在-window-上安裝-intellij-idea"><a class="link" href="#在-window-上安裝-intellij-idea">在 Window 上安裝 IntelliJ IDEA</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-macos-上安裝-intellij-idea"><a class="link" href="#在-macos-上安裝-intellij-idea">在 MacOS 上安裝 IntelliJ IDEA</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-ubuntu-linux-上安裝-intellij-idea"><a class="link" href="#在-ubuntu-linux-上安裝-intellij-idea">在 Ubuntu Linux 上安裝 IntelliJ IDEA</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docker"><a class="link" href="#docker">Docker</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Docker 是一個開放原始碼軟體，是一個開放平台，用於開發應用、交付（shipping）應用、執行應用。Docker 允許用戶將基礎設施（Infrastructure）中的應用單獨分割出來，形成更小的顆粒（容器），從而提高交付軟體的速度。</p>
</div>
<div class="paragraph">
<p>Docker 容器與虛擬機器類似，但原理上，容器是將作業系统層虛擬化，虛擬機器則是虛擬硬體，因此容器更具有可攜式性、高效地利用伺服器。容器更多地用於表示軟體的一個標準化單元。由於容器的標準化，因此它可以無視基礎設施（Infrastructure）的差異，部署到任何一個地方。另外，Docker 也為容器提供更強的業界的隔離相容。</p>
</div>
<div class="paragraph">
<p>Docker 利用 Linux 核心中的資源分離機制，例如 cgroups，以及 Linux 核心命名空間（namespaces），來建立獨立的容器（containers）。這可以在單一 Linux 實體下運作，避免啟動一個虛擬機器造成的額外負擔。Linux 核心對命名空間的支援完全隔離了工作環境中應用程式的視野，包括行程樹、網路、用戶 ID 與掛載檔案系統，而核心的 cgroups 提供資源隔離，包括 CPU、記憶體、block I/O 與網路。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Docker<br>
<cite>https://zh.wikipedia.org/wiki/Docker</cite>
</div>
</div>
<div class="paragraph">
<p>服務端軟件如數據庫、消息服務等，一般安裝與配置都較複雜。借由 Docker 技術，應用提供者可以將複雜的依賴、配置與軟件本身打包成鏡像。使用者袛需從鏡像實例化出容器就可以方便快速地創建服務端軟件實例了。在應用開發過程中，常常需要與數據庫或消息服務等中間件集成調試。供由 Docker 技術，開發者就可以快速方便地在本地創建運行各種所需服務。</p>
</div>
<div class="sect3">
<h4 id="在-window-上安裝-docker"><a class="link" href="#在-window-上安裝-docker">在 Window 上安裝 Docker</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-macos-上安裝-docker"><a class="link" href="#在-macos-上安裝-docker">在 MacOS 上安裝 Docker</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="在-ubuntu-linux-上安裝-docker"><a class="link" href="#在-ubuntu-linux-上安裝-docker">在 Ubuntu Linux 上安裝 Docker</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hello-world"><a class="link" href="#hello-world">Hello World</a></h3>
<div class="paragraph">
<p>我們以實作一個 Hello World Spring Boot 應用來檢驗 JDK 和 IntelliJ IDEA 安裝配置是否正確。</p>
</div>
<div class="paragraph">
<p>最簡單的創建一個新的 Spring Boot 應用方法是使用 <a href="https://start.spring.io">Spring Initializr</a>。使用瀏覽器訪問 <a href="https://start.spring.io" class="bare">https://start.spring.io</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project 選擇 Gradle Project，使用 Gradle 構建我們的項目；</p>
</li>
<li>
<p>Language 選擇 Java；</p>
</li>
<li>
<p>Spring Boot 撰擇 2.2.7 或其它 2.2.x 版本，最新版（訖今為止）的 Spring Cloud Hoxton 兼容 Spring Boot 2.2.x；</p>
</li>
<li>
<p>Project Metadata 部份，Group 填 <code>io.github.rscai.microservices</code>，Artifact 填 <code>helloworld</code>，Name 填 <code>helloworld</code>，Packaging 撰 Jar，Java 撰擇版本 8；</p>
</li>
<li>
<p>Dependencies 僅需選定 Spring Web 即可。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/01-Tools-Setup/generate-helloworld-by-spring-initializr.png" alt="generate helloworld by spring initializr">
</div>
</div>
<div class="paragraph">
<p>單擊<strong>GENERATE</strong>，Spring initializr 就會生成 ZIP 格式的項目文件。</p>
</div>
<div class="paragraph">
<p>將 <code>helloworld.zip</code> 解壓後得到一個 Spring Boot 項目。其中：</p>
</div>
<div class="paragraph">
<p>Unresolved directive in zh_TR//01-Tools-Setup.adoc - include::zh_TR/common/gradle-project-structure-basic.adoc[]</p>
</div>
<div class="paragraph">
<p>將 helloworld 項目導入 IntelliJ IDEA。首先，打開 Intellij IDEA，然後，單繫 Import Project，選定 helloworld 項目目錄，再然後選擇以 Gradle 項目形式導入。IntelliJ IDEA 會自動初始執行 Gradle 配置，下載 <code>/gradle/wrapper/gradle-wrapper.properties</code> 中指定版本的 Gradle。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/01-Tools-Setup/Helloworld-import.gif" alt="Helloworld import">
</div>
</div>
<div class="listingblock">
<div class="title">/src/main/java/io/github/rscai/microservices/helloworld/HelloWorldApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.github.rscai.microservices.helloworld;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication <i class="conum" data-value="1"></i><b>(1)</b>
public class HelloWorldApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloWorldApplication.class, args); <i class="conum" data-value="2"></i><b>(2)</b>
	}

}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用注解 <code>@SpringBootApplication</code> 聲明 Spring Boot 應用；</p>
</li>
<li>
<p>將 Spring Boot 應用類傳遞給 <code>SpringApplication.run</code>，其會掃描 Spring Boot 應用類中相關的聲明及 classpath 中的聲明（注解和指標類），裝配並初始化 Spring Bean。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>創建 controller，並添加請求處理方法。</p>
</div>
<div class="literalblock">
<div class="title">src/main/java/io/github/rscai/microservices/helloworld/controller/HelloWorldController.java</div>
<div class="content">
<pre>package io.github.rscai.microservices.helloworld.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController <i class="conum" data-value="1"></i><b>(1)</b>
@RequestMapping("helloworld") <i class="conum" data-value="2"></i><b>(2)</b>
public class HelloWorldController {

  @GetMapping("sayHello") <i class="conum" data-value="3"></i><b>(3)</b>
  public String sayHello(@RequestParam(value = "name", defaultValue = "World") String name) { <i class="conum" data-value="4"></i><b>(4)</b>
    return String.format("Hello %s!", name);
  }
}</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用注解 <code>@RestController</code> 聲明此 Controller 乃 RESTFul 風格的 Controller。RESTFul 風格的 Controller：</p>
<div class="ulist">
<ul>
<li>
<p>方法返回值應被直接編碼為响應體，編碼格式由請求頭 <code>Accept</code> 逐請求指定</p>
</li>
</ul>
</div>
</li>
<li>
<p>使用注解 <code>@RequestMapping</code> 將此 Controller 中所有的處理方法都映射至 URL <code>/helloworld</code> 以下；</p>
</li>
<li>
<p>使用注解 <code>@GetMapping</code> 將針對 URL <code>/helloworld/sayHello</code> 的 GET 請求映射至方法 <code>sayHello</code>；</p>
</li>
<li>
<p>使用注解 <code>@RequestParam</code> 將請求參數 <code>name</code> 的值以參數 <code>name</code> 的形式傳遞給方法 <code>sayHello</code>，若請求中未提供參數 <code>name</code> 則傳遞默認值 <code>world</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在終端中，進入到項目根目錄，執行 <code>./gradlew bootRun</code>。
打開 Web 瀏覽器，在地址欄中輸入 <code><a href="http://localhost:8080/helloworld/sayHello?name=Mike" class="bare">http://localhost:8080/helloworld/sayHello?name=Mike</a></code>，敲繫回車，應顯示：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Hello Mike!</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="參考-2"><a class="link" href="#參考-2">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/JDK">JDK</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/OpenJDK">OpenJDK</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="catalog-service"><a class="link" href="#catalog-service">Catalog Service</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="目標"><a class="link" href="#目標">目標</a></h3>
<div class="paragraph">
<p>本章中，我們將基於Spring Boot開發提供RESTful API的Catalog微服務。我們將學習：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Lombok在編譯器生成Getter和Setter訪問器，減少模板代碼</p>
</li>
<li>
<p>使用Spring Data/Spring Data MongoDB訪問MongoDB</p>
</li>
<li>
<p>使用Spring Data REST從Repository構建RESTful API</p>
</li>
<li>
<p>使用Spring Test/MockMVC測試RESTFul API</p>
</li>
<li>
<p>使用Spring REST Docs生成簡潔、準確且結構良好的RESTFul API文檔</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="設計"><a class="link" href="#設計">設計</a></h3>
<div class="sect3">
<h4 id="用例-2"><a class="link" href="#用例-2">用例</a></h4>
<div class="paragraph">
<p>Catalog微服務負責維護Product和ProductImage兩個業務模型實體。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/catalog-model.png" alt="catalog model" width="410" height="148">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Product，可被獨立增刪改查的業務實體，其可關聯一至多個ProductImage</p>
</li>
<li>
<p>ProductImage，可被獨立增刪改查的業務實體，其可被零至一個Product關聯。如若關聯其的Product被移除，不會影嚮ProductImage實體的狀態。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Catalog微服務需支持特性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>創建新的ProductImage</p>
</li>
<li>
<p>更新ProductImage</p>
</li>
<li>
<p>移除ProductImage</p>
</li>
<li>
<p>分頁查詢所有ProductImage</p>
</li>
<li>
<p>讀取單個ProductImage</p>
</li>
<li>
<p>創建新的Product</p>
</li>
<li>
<p>更新Product</p>
</li>
<li>
<p>移除Product</p>
</li>
<li>
<p>分頁查詢所有ProductImage</p>
</li>
<li>
<p>讀取單個Product</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="架構-2"><a class="link" href="#架構-2">架構</a></h4>
<div class="paragraph">
<p>Catalog微服務採用分層架構，自上往下分為：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>展示層。以RESTFul風格向外曝露Catalog支持的領域模型和操作，以JSON格式接受和迴應領域模型內容。</p>
</li>
<li>
<p>業務邏輯層，處理應用相關的業務邏輯，比如填充createdAt和updatedAt。</p>
</li>
<li>
<p>數據訪問層，處理Java object和具體存儲實體之間的映射轉換，實現橧刪改查等存儲訪問操作。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/catalog-design.png" alt="catalog design" width="276" height="440">
</div>
</div>
<div class="paragraph">
<p>這𥚃我們採用Spring Data REST實現展現層；供助Spring Data REST開放的實體事件擴展機制，實現業務邏輯；數據存儲方案選用MongoDB；數據訪問層採用Spring Data MongoDB實現。</p>
</div>
</div>
<div class="sect3">
<h4 id="理解-lombok"><a class="link" href="#理解-lombok">理解 Lombok</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Lombok項目是一個Java庫，它會自動插入您的編輯器和構建工具中，從而使您的Java更加生動有趣。
永遠不要再寫另一個getter或equals方法，帶有一個註釋的您的類有一個功能全面的生成器，自動化您的日誌記錄變量等等。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok<br>
<cite>https://projectlombok.org</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>使用javac（以及netbeans，maven，gradle和大多數其他構建系統）時，lombok作為註釋處理器運行。</p>
</div>
<div class="paragraph">
<p>Lombok在classpath中，且javac將在它可以找到的類路徑上加載每個 <code>META-INF/services/javax.annotation.processing.Processor</code> 文件，讀取每一行並加載該類，然後將其作為註釋處理器執行。 <code>lombok.jar</code> 有此文件，它將`lombok.launch.AnnotationProcessorHider$AnnotationProcessor`列為條目。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok Execution Path<br>
<cite>https://projectlombok.org/contributing/lombok-execution-path</cite>
</div>
</div>
<div class="paragraph">
<p>Lombok實現為注解處理器「Annotation Processor」，在編譯期被Java編譯器調用，掃描代碼，讀取Lombok注解及關鍵詞標注的類，並執行相應的代碼轉換。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Lombok官方網站 <a href="https://projectlombok.org/">Lombok Project</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="理解-rest"><a class="link" href="#理解-rest">理解 REST</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>代表性狀態轉移（REST）是一種軟件體系結構樣式，它定義了一組用於創建Web服務的約束。 符合REST體系結構樣式的Web服務（稱為RESTful Web服務）提供Internet上計算機系統之間的互操作性。 RESTful Web服務允許請求系統通過使用統一且預定義的無狀態操作集來訪問和操縱Web資源的文本表示。 其他類型的Web服務（例如SOAP Web服務）公開其自己的任意操作集。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Representational State Transfer<br>
<cite>https://en.wikipedia.org/wiki/Representational_state_transfer</cite>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服務有以下特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以資源為中心，領域模型在RESTFul API中表現為資源，所有的業務操作都表現為對資源的操作。</p>
</li>
<li>
<p>重用HTTP請求方法。以HTTP請求方法表逹對資源的操作。HTTP協議中定義了九種請求方法：</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET方法請求指定資源的表示形式。 使用GET的請求應僅檢索數據。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD方法請求的響應與GET請求的響應相同，但沒有響應主體。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST方法用於將實體提交給指定的資源，通常會導致狀態更改或對服務器產生副作用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT方法用請求有效負載替換目標資源的所有當前表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE方法刪除指定的資源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT方法建立到由目標資源標識的服務器的隧道。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS方法用於描述目標資源的通信選項。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE方法沿到目標資源的路徑執行消息環回測試。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH方法用於對資源進行部分修改。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>RESTFul 主要重用其中的POST、DELETE、PUT和GET來分別表逹增、刪、改和查操作。</p>
</div>
</li>
<li>
<p>重用HTTP嚮應狀態碼。重用HTTP嚮應狀態碼來表逹請求的處理結果。HTTP協議定義了五類嚮應狀態碼</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>信息性的嚮應（100-199）</p>
</li>
<li>
<p>成功的嚮應（200-299）</p>
</li>
<li>
<p>重定向（300-399）</p>
</li>
<li>
<p>客戶端錯誤（400-499）</p>
</li>
<li>
<p>服務端錯誤（500-599）</p>
<div class="paragraph">
<p>常用的嚮應狀態碼有：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Code</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">該請求已成功。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">201 Created</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求成功，並因此創建了新資源。 這通常是在POST請求或某些PUT請求之後發送的響應。當使用POST請求訪問RESTFul API創建新資源實體後，應返迴嚮應狀態碼200。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">204 No Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沒有要發送的內容，但標頭可能有用。 用戶代理可以使用新的代理更新該資源的緩存頭。當使用PUT請求訪問RESTFul API更新資源實體且未在嚮應報文中包含更新後的實體，應使用嚮應狀態碼204。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">400 Bad Request</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由於語法無效，服務器無法理解該請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">401 Unauthorized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">儘管HTTP標準指定“未經授權”，但從語義上講，此響應表示“未經驗證”。 也就是說，客戶端必須對自己進行身份驗證才能獲得請求的響應。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">403 Forbidden</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客戶端無權訪問內容； 也就是說，它是未經授權的，因此服務器拒絕提供所請求的資源。 與401不同，服務器知道客戶端的身份。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">404 Not Found</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器找不到請求的資源。 在瀏覽器中，這意味著無法識別URL。 在API中，這也可能意味著端點有效，但是資源本身不存在。 服務器也可以發送此響應而不是403，以隱藏來自未授權客戶端的資源。 由於此響應代碼在網絡上經常出現，因此可能是最著名的響應代碼。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">405 Method Not Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器知道該請求方法，但已被禁用，無法使用。比如針對祗讀資源的寫請求（POST、DELETE、PUT），RESTFul API可以嚮應此狀態碼。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">415 Unsupported Media Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器不支持所請求數據的媒體格式，因此服務器拒絕了該請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">500 Internal Server Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器遇到了不知道如何處理的情況。任何業務邏輯的錯誤都不應該嚮應該狀態碼。祗有真正無法處理或恢復的失效，比如依賴服務不可用等，才可以嚮應該狀態碼。</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="product-restful-web-api"><a class="link" href="#product-restful-web-api">Product RESTFul Web API</a></h5>
<div class="paragraph">
<p>REST Web服務以資源為中心，把領域模型Product直接映射為資源product，所以資源product的根URL就為 <code>/products</code> 。因為從語義上講，對資源根URL的操作，如GET、POST，都是作用於資源集合而非單個資源實體，所以使用復數形式更為恰當。（很多人認為使用單數形式是最佳實踐，因為英文名詞的復數形式規則並不統一且大部份人英文不好，硬用復數形式容易出現拚寫錯誤）</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">創建新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新與ProductImage之間的關聯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取單個Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分頁讀取所有Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取Product關聯的ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="productimage-restful-api"><a class="link" href="#productimage-restful-api">ProductImage RESTFul API</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">創建新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取單個ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分頁讀取所有ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="理解-json"><a class="link" href="#理解-json">理解 JSON</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>JSON(JavaScript Object Notation) 是一種輕量級的數據交換格式。易於人閱讀和編寫。同時也易於機器解析和生成。它基於JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一個子集。 JSON採用完全獨立於語言的文本格式，但是也使用了類似於C語言家族的習慣（包括C, C++, C#, Java, JavaScript, Perl, Python等）。這些特性使JSON成為理想的數據交換語言。</p>
</div>
<div class="paragraph">
<p>JSON建構於兩種結構：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“名稱/值”對的集合（A collection of name/value pairs）。不同的語言中，它被理解為對象（object），紀錄（record），結構（struct），字典（dictionary），哈希表（hash table），有鍵列表（keyed list），或者關聯數組（associative array）。</p>
</li>
<li>
<p>值的有序列表（An ordered list of values）。在大部分語言中，它被理解為數組（array）。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; 介紹JSON<br>
<cite>https://www.json.org/json-zh.html</cite>
</div>
</div>
<div class="paragraph">
<p>JSON是一種面嚮字符的、編程語言獨立的、易於人和機器讀寫的數據交換格式。使用JSON作為RESTFul Web服務與消費者之間交換實體內容的數據格格，可以最大限度地提升Web服務的兼容性。但需要注意，JSON是面嚮文本的數據交換格式，所有類型的數據都必須被編碼為文本形式，所以JSON並不適用二進制數據的交換，比如圖像、音頻、視頻。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>關於JSON的規範定義，請參閱 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404 The JSON Data Interchange Standard</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="理解-hypermedia-driven"><a class="link" href="#理解-hypermedia-driven">理解 Hypermedia-Driven</a></h4>
<div class="paragraph">
<p>Hypermedia指代所有包含指向其它媒體（如圖像、視頻和文本等）的鏈接的內容。Hypermedia-Driven的RESTFul Web服務則是指在請求體和嚮應體的內容為Hypermedia。</p>
</div>
<div class="paragraph">
<p>HATEOAS（Hypermedia as the Engine of Application State）是一組附加在RESTFul風格架構之上的約束，其旨在約束Hypermedia-Driven RESTFul Web服務。HATEOAS沒有嚴格的定義，各個框架都有自己的實現。但大多數HATEOAS實現都參考了以下規範：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc5988">RFC 5988 Web Linking</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Application_Language">Hypertext Application Language</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="理解-spring-data-rest"><a class="link" href="#理解-spring-data-rest">理解 Spring Data REST</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data REST是Spring Data的一部份，其致力於簡化在Spring Data repository之上構建<strong>超媒體驅動「hypermedia-driven」</strong> REST web微務。</p>
</div>
<div class="paragraph">
<p>Spring Data REST 構建於 Spring Data repository 之上，分析你的應用領域模型且曝露超媒體驅動HTTP資源。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-rest
</div>
</div>
<div class="paragraph">
<p>Spring Framework 本身提供了Spring MVC。借助Spring MVC，可以快速構造RESTFul web服務。再加上Spring HATEOAS，就可以構建超媒體驅動的RESTFul web服務了。但是RESTFul web服務是以資源為中心，其為每類資源實現一組有限的動作，如POS創建、PUT更新、DELETE移除。直接使用Spring MVC構建RESTFul web服務會造成很多模板代碼。Spring Data REST就是為了避免使用Spring MVC構建RESTFul web服務時產生冗餘模板代碼而被創造出來。Spring Data REST分析應用中的repository，分揀出領域模型和增刪改查方法，分別曝露為相應的RESTFul URLs.</p>
</div>
<div class="paragraph">
<p>Spring Data REST 開放出了八個實體事件，應用開發者可以注入自定義的事件監聽器以實現業務邏輯處理。Spring Data REST會釋放出以下八種事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeCreateEvent</code></p>
</li>
<li>
<p><code>AfterCreateEvent</code></p>
</li>
<li>
<p><code>BeforeSaveEvent</code></p>
</li>
<li>
<p><code>AfterSaveEvent</code></p>
</li>
<li>
<p><code>BeforeDeleteEvent</code></p>
</li>
<li>
<p><code>AfterDeleteEvent</code></p>
</li>
<li>
<p><code>BeforeLinkSaveEvent</code></p>
</li>
<li>
<p><code>AfterLinkSaveEvent</code></p>
</li>
<li>
<p><code>BeforeLinkDeleteEvent</code></p>
</li>
<li>
<p><code>AfterLinkDeleteEvent</code></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="beforecreateevent-和-aftercreateevent"><a class="link" href="#beforecreateevent-和-aftercreateevent"><code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code></a></h5>
<div class="paragraph">
<p>Spring Data REST在創建實體實例時，會釋放出 <code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code>。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; createAndReturn(Object domainObject, RepositoryInvoker invoker,
		PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeCreateEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object savedObject = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterCreateEvent(savedObject)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在調用repository方法將創建的實體持久化至存儲服務之前，釋放出事件 <code>BeforeCreateEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在調用repository方法將創建的實體持久化至存儲服務之後，釋放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>POST和PUT請求都有可能觸發實體的創建。POST在REST語義中就是創建新實體，所以POST請求肯定會觸發實體創建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@ResponseBody
@RequestMapping(value = BASE_MAPPING, method = RequestMethod.POST)
public ResponseEntity&lt;ResourceSupport&gt; postCollectionResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, PersistentEntityResourceAssembler assembler,
		@RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	resourceInformation.verifySupportedMethod(HttpMethod.POST, ResourceType.COLLECTION);

	return createAndReturn(payload.getContent(), resourceInformation.getInvoker(), assembler,
			config.returnBodyOnCreate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>PUT請求在REST語義中是更新實體，但若要求更新的目標實體不存在，則更新操作就自動轉化為創建操作。所以，當使用PUT請求更新不存在的實體時，會觸發實體創建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>若請求創建的實體是新建的即目標實體不存在，則更新請求轉化為創建操作。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beforesaveevent-和-aftersaveevent"><a class="link" href="#beforesaveevent-和-aftersaveevent"><code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code></a></h5>
<div class="paragraph">
<p>Spring Data REST在更新實體時會釋放出 <code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; saveAndReturn(Object domainObject, RepositoryInvoker invoker,
		HttpMethod httpMethod, PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeSaveEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object obj = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterSaveEvent(obj)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在調用repository方法將更新的實體持久化至存儲服務之前，釋放出事件 <code>BeforeSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在調用repository方法將更新的實體持久化至存儲服務之後，釋放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>PUT和PATCH請求都會觸發實體更新操作。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

    ...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>當請求更新的目標實體存在時，PUT請求觸發更新操作。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PATCH)
public ResponseEntity&lt;ResourceSupport&gt; patchItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {

	...

	return saveAndReturn(domainObject, resourceInformation.getInvoker(), PATCH, assembler,
			config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>PATCH請求祗能觸發實體更新。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="beforedeleteevent-和-afterdeleteevent"><a class="link" href="#beforedeleteevent-和-afterdeleteevent"><code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code></a></h5>
<div class="paragraph">
<p>Spring Data REST在移除實體時會釋放出事件 <code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;?&gt; deleteItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id,
		ETag eTag) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {

	...

	return domainObj.map(it -&gt; {

		PersistentEntity&lt;?, ?&gt; entity = resourceInformation.getPersistentEntity();

		eTag.verify(entity, it);

		publisher.publishEvent(new BeforeDeleteEvent(it)); <i class="conum" data-value="2"></i><b>(2)</b>
		invoker.invokeDeleteById(entity.getIdentifierAccessor(it).getIdentifier());
		publisher.publishEvent(new AfterDeleteEvent(it)); <i class="conum" data-value="3"></i><b>(3)</b>

		return new ResponseEntity&lt;Object&gt;(HttpStatus.NO_CONTENT);

	}).orElseThrow(() -&gt; new ResourceNotFoundException());
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>針對實體的DELETE請求會觸發實體移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將實體從存儲服務中移除之前，釋放出事件 <code>BeforeDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將實體從存儲服務中移除之後，釋放出事件 <code>AfterDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beforelinksaveevent-和-afterlinksaveevent"><a class="link" href="#beforelinksaveevent-和-afterlinksaveevent"><code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code></a></h5>
<div class="paragraph">
<p>Spring Data REST在創建和變更實體關聯時會釋放出 <code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = { PATCH, PUT, POST }, <i class="conum" data-value="1"></i><b>(1)</b>
		consumes = { MediaType.APPLICATION_JSON_VALUE, SPRING_DATA_COMPACT_JSON_VALUE, TEXT_URI_LIST_VALUE })
public ResponseEntity&lt;? extends ResourceSupport&gt; createPropertyReference(RootResourceInformation resourceInformation,
		HttpMethod requestMethod, @RequestBody(required = false) Resources&lt;Object&gt; incoming, @BackendId Serializable id,
		@PathVariable String property) throws Exception {

	...

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; {

        ...

		publisher.publishEvent(new BeforeLinkSaveEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = invoker.invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkSaveEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return null;
	};

	doWithReferencedProperty(resourceInformation, id, property, handler, requestMethod);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>PATCH、PUT或POST請求鏈接（LINK）類型的實體屬性都會觸發實體鏈接屬性的創建或變更。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將鏈接屬性變更持久化至存儲服務之前，釋放出 <code>BeforeLinkSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將鏈接屬性變更持久化至存儲服務之後，釋放出 <code>AfterLinkSaveEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beforelinkdelete-和-afterlinkdelete"><a class="link" href="#beforelinkdelete-和-afterlinkdelete"><code>BeforeLinkDelete</code> 和 <code>AfterLinkDelete</code></a></h5>
<div class="paragraph">
<p>Spring Data REST在移除實體之間的關聯（LINK）時，會釋放出 <code>BeforeLinkDeleteEvent</code> 和 <code>AfterLinkDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;? extends ResourceSupport&gt; deletePropertyReference(RootResourceInformation repoRequest,
		@BackendId Serializable id, @PathVariable String property) throws Exception {

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; prop.mapValue(it -&gt; {

		...

		publisher.publishEvent(new BeforeLinkDeleteEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = repoRequest.getInvoker().invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkDeleteEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return (ResourceSupport) null;

	}).orElse(null);

	doWithReferencedProperty(repoRequest, id, property, handler, HttpMethod.DELETE);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>目標為鏈接類型的實體屬性的DELETE請求會觸發實體關聯移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將實體關聯移除持久化至存儲服務之前，釋放出事件 <code>BeforeLinkDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將實體關聯移除持久化至存儲服務之後，釋放出事件 <code>AfterLinkDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="注入事件處理器"><a class="link" href="#注入事件處理器">注入事件處理器</a></h5>
<div class="paragraph">
<p>應用開發者可以自定義事件處理器，再使用注解將自定義事件處理器注刪為事件監聽器。Spring Data REST提供了十個注解分別對應上述十個實體事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@HandleBeforCreate</code></p>
</li>
<li>
<p><code>@HandleAfterCreate</code></p>
</li>
<li>
<p><code>@HandleBeforeSave</code></p>
</li>
<li>
<p><code>@HandleAfterSave</code></p>
</li>
<li>
<p><code>@HandleBeforeDelete</code></p>
</li>
<li>
<p><code>@HandleAfterDelete</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkSave</code></p>
</li>
<li>
<p><code>@HandleAfterLinkSave</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkDelete</code></p>
</li>
<li>
<p><code>@HandleAfterLinkDelete</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="理解-mongodb"><a class="link" href="#理解-mongodb">理解 MongoDB</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>MongoDB是一個文檔數據庫，具有所需的可伸縮性和靈活性，可用於所需的查詢和索引編制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MongoDB將數據存儲在類似於JSON的靈活文檔中，這意味著字段隨文檔的不同而不同，並且數據結構可以隨時間而變化</p>
</li>
<li>
<p>文檔模型映射到應用程序代碼中的對象，從而使數據易於使用</p>
</li>
<li>
<p>臨時查詢，索引編制和實時聚合提供了訪問和分析數據的強大方法</p>
</li>
<li>
<p>MongoDB以分佈式數據庫為核心，因此內置了高可用性，水平擴展和地理分佈並且易於使用</p>
</li>
<li>
<p>MongoDB是免費使用的。 在AGPL下發布了2018年10月16日之前發布的版本。 2018年10月16日之後發布的所有版本（包括先前版本的修補程序修補程序）均根據服務器端公共許可證（SSPL）v1發布。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; What Is MongoDB<br>
<cite>https://www.mongodb.com/what-is-mongodb</cite>
</div>
</div>
<div class="paragraph">
<p>MongoDB是schema-free的數據庫，其非常適用於同一類別數據結構會隨時間較頻繁變動（增加屬性、減少屬性等）的應用場景。Catalog服務所維護的數據就符合這一特徵。</p>
</div>
</div>
<div class="sect3">
<h4 id="理解-spring-data-mongodb"><a class="link" href="#理解-spring-data-mongodb">理解 Spring Data MongoDB</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data的任務是為數據訪問提供一個熟悉且一致的基於Spring的編程模型，同時仍保留基礎數據存儲的特殊特徵。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data MongoDB是Spring Data項目的一部分，該項目旨在為新數據存儲提供熟悉且一致的基於Spring的編程模型，同時保留特定於存儲的功能。</p>
</div>
<div class="paragraph">
<p>Spring Data MongoDB項目提供了與MongoDB文檔數據庫的集成。 Spring Data MongoDB的關鍵功能區域是一個以POJO為中心的模型，該模型用於與MongoDB DBCollection進行交互並輕鬆編寫存儲庫樣式的數據訪問層。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-mongodb
</div>
</div>
<div class="paragraph">
<p>Spring Data的核心模式是倉庫設計模式「Repository Design Pattern」。
倉庫設計模式最早由Eric Evens在他的著作《Domain Driven Design》中提出，其核心概念是倉庫「Repository」。倉庫在業務邏輯層與數據源之間扮演着中間人的⻆色，其解耦了業務邏輯層和數據源，使用業務邏輯層無需關心具體數據源的接口或任何接口變更，甚至無需任何業務邏輯層的代碼變更就可以遷移至不同的數據源上。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/repository-pattern.png" alt="repository pattern" width="406" height="256">
</div>
</div>
<div class="paragraph">
<p>Spring Data提供的核心接口就是 <code>Repository</code> 。應用開發者祗需聲明專用於領域模型的、繼承 <code>Repository</code> 的倉庫接口，針對特定存儲服務實現的Spring Data模塊（如Spring Data MongoDB）會構造相應的倉庫實現Bean。</p>
</div>
<div class="paragraph">
<p>Spring Data除了 <code>Repository</code> 之外，還提供了其它倉庫接口。這些倉庫口提供了常用的數據訪問操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.data.repository.CrudRepository</code> 提供了基本的增刪改查操作</p>
</li>
<li>
<p><code>org.springframework.data.repository.PagingAndSortingRepository</code> 添加了分頁和排序功能</p>
</li>
<li>
<p><code>org.springframework.data.repository.query.QueryByExampleExecutor</code> 提供了相似查詢功能，應用可以按照業務邏輯定義相似算法，查詢相似（不完全相同，或主鍵相同）的實體</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/repository-interface.png" alt="repository interface" width="706" height="525">
</div>
</div>
<div class="paragraph">
<p>Spring Data MongoDB在Spring Data Commons提供的倉庫接口基礎上，還擴展了 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-data-mongodb-repository.png" alt="spring data mongodb repository" width="495" height="276">
</div>
</div>
</div>
<div class="sect3">
<h4 id="理解junit"><a class="link" href="#理解junit">理解JUnit</a></h4>
<div class="paragraph">
<p>JUnit 是一個 Java 編程語言的單元測試框架。JUnit 定義了三層單元測試組織結構：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TestSuite</p>
</li>
<li>
<p>TestCase</p>
</li>
<li>
<p>Test</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Test</strong> 是單元測試的最小組織單位，多個 <strong>Test</strong> 可以組織為 <strong>TestCase</strong>，多個 <strong>TestCase</strong> 可以組織為 <strong>TestSuite</strong>。在 Java 中，<strong>TestCase</strong> 和 <strong>TestSuite</strong> 實現為類，<strong>Test</strong> 實現為 <strong>TestCase</strong> 的方法。所以在實際應用中，<strong>Test</strong> 和 <strong>TestCase</strong> 是必須的，<strong>TestSuite</strong> 是可選的。</p>
</div>
<div class="paragraph">
<p>Junit 定義了五個單元測試執行階段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BeforeClass</p>
</li>
<li>
<p>BeforeEach</p>
</li>
<li>
<p>Test</p>
</li>
<li>
<p>AfterEach</p>
</li>
<li>
<p>AfterClass</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong> 為 <strong>TestCase</strong> 的初始階段，JUnit 在即將執行 <strong>TestCase</strong> 所包含的 <strong>Test</strong> 之前執行 <strong>BeforeClass</strong>；<strong>BeforeEach</strong> 為 <strong>Test</strong> 的前置階段，JUnit 在每次執行 <strong>Test</strong> 之前執行 <strong>BeforeEach</strong>；<strong>Test</strong> 為單元測試的主要階段，該階段應包含嚮測試對象輸入和斷言測試對象的輸出；<strong>AfterEach</strong> 為 <strong>Test</strong> 的後置階段，JUnit 在每次執行 <strong>Test</strong> 之後執行 <strong>AfterEach</strong>；<strong>AfterClass</strong> 為 <strong>TestCase</strong> 的善後階段，JUnit 在執行完 <strong>TestCase</strong> 所包含的所有 <strong>Test</strong> 之後執行 <strong>AfterClass</strong>。</p>
</div>
<div class="paragraph">
<p>舉個例子，</p>
</div>
<div class="listingblock">
<div class="title">ExampleTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleTest {
  private Example testObject;
  @BeforeClass
  public void beforeClass() {
    System.out.println("Before test case ExampleTest");
  }
  @AfterClass
  public void afterClass() {
    System.out.println("After test case ExampleTest");
  }
  @BeforeEach
  public void setUp() {
    System.out.println("SetUp for each test");
    testObject = new Example();
  }
  @AfterEach
  public void tearDown() {
    System.out.println("TearDown for each test");
  }
  @Test
  public void testFunA() {
    String actual = testObject.funA();
    assertEqual(actual, "expected value");
  }
  @Test
  public void testFunB() {
    String actual = testObject.funB();
    assertEqual(actual, "expected value");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong>, <strong>AfterClass</strong>, <strong>BeforeEach</strong>, <strong>AfterEach</strong> 和 <strong>Test</strong> 都被實現為 <strong>TestCase</strong> 的方法，通過注解聲明。JUnit 在執行上述 <strong>TestCase</strong>，方法調用序列為：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>beforeClass()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunA()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunB()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>afterClass()</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="理解spring-mvc-test-framework"><a class="link" href="#理解spring-mvc-test-framework">理解Spring MVC Test Framework</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring MVC測試框架提供了一流的支持，可使用可與JUnit，TestNG或任何其他測試框架一起使用的流暢API測試Spring MVC代碼。 它基於spring-test模塊的Servlet API mock objects構建，因此不使用正在運行的Servlet容器。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring MVC Test Framework<br>
<cite>https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#spring-mvc-test-framework</cite>
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架通過 <code>DispatcherServlet</code> 與Spring MVC代碼直接通信，無需運行Servlet容器。且測試代碼與被測試代碼（服務端代碼）運行在同一個JVM中，所以不僅可以驗證服務端代碼的輸出還可以驗證服務端代碼的內部狀態，即支持服務端代碼的白盒測試。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-mvc-architecture.png" alt="spring mvc architecture" width="495" height="309">
</div>
</div>
<div class="paragraph">
<p>在生產環境中， <code>dispatcherServlet</code> 和 <code>controller</code> 都運行在 <code>Servlet</code> 容器中（Spring Boot應用是內嵌Servlet容器），並通過Servlet容器嚮外曝露HTTP服務。客户端應用（Web瀏器、原生應用等）通過HTTP協議訪問Servlet容器，Servlet容器將請求轉化為 <code>HttpServletRequest</code> 交由 <code>dispatcherServlet</code> ； <code>dispatcherServlet</code> 再分發給對應的 <code>controller</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mockmvc-archotecture.png" alt="mockmvc archotecture" width="352" height="234">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架則通過MockMvc（Servlet API mock objects）直接與 <code>dispatcherServlet</code> 通信。我們的測試目標是應用上下文配置和 <code>controller</code> 及其調用的其它Beans，Servlet容器並不是我們的測試目標（因為它們的代碼不是我們寫的）。使用這種測試方法可以最大限度地排除第三方代碼，僅關注於應用代碼的測試。</p>
</div>
</div>
<div class="sect3">
<h4 id="理解-spring-rest-docs"><a class="link" href="#理解-spring-rest-docs">理解 Spring REST Docs</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring REST Docs可幫助您記錄RESTful服務。</p>
</div>
<div class="paragraph">
<p>它結合了用Asciidoctor編寫的手寫文檔和Spring MVC Test生成的自動生成的代碼片段。 這種方法使您擺脫了Swagger之類的工具所產生的文檔限制。</p>
</div>
<div class="paragraph">
<p>它可以幫助您生成準確，簡潔且結構合理的文檔。 然後，該文檔可讓您的用戶以最少的麻煩獲得他們所需的信息。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring REST Docs<br>
<cite>https://spring.io/projects/spring-restdocs</cite>
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs致力於幫助應用開發者生成準確且可讀的RESTFul服務文檔。Spring REST Docs借助測試生成的HTTP請求和响應內容片斷，再組合手工編寫的Asciidoc或Markdown文本，產生HTML格式的文檔。文檔的生成依賴測試的通過。所以當測測未通過時，文檔也不會被生成，從而避免成生與實現不符的文檔。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-rest-docs-process.png" alt="spring rest docs process" width="388" height="293">
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs可以從由Spring MVC Test框架、Spring WebFlux&#8217;s <code>WebTestClient</code> 和REST Assured 3編寫的測試中截取HTTP請求和响應片斷。</p>
</div>
<div class="paragraph">
<p>應用開發者編寫asciidoc文檔（以.adoc, .asciidoc, .ad, .asc山大弓火後綴的），引用Spring REST Docs在測試階段截取的片斷。Asciidoctor讀取asciidoc文檔和請求响應片斷，轉換生成HTML格式的可閱讀文檔（Asciidoctor還支持其它輸出格式，如PDF、EPUB等）。</p>
</div>
<div class="paragraph">
<p>作為Spring REST Docs的核心，其提供了豐富的HTTP請求响應片斷截取和注釋功能。所有這些截取注釋功能都實現為 <code>org.springframework.restdocs.snippet.Snippet</code> 的實現類，應用開發者通過構造方法穫取這些Snippet實現類實例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/http-message.png" alt="http message" width="606" height="313">
</div>
</div>
<div class="paragraph">
<p>HTTP報文分為請求（request）報文和响應（response）報文。請求報文由三部份組成：請求行（Request Line）、頭（Header Field）和消息體（Message Body）。响應報文也由三部份組成：狀態行（Status Line）、頭（Header Field）和消息體（Message Body）。</p>
</div>
<div class="paragraph">
<p>Spring REST Docs為請求行，頭和消息體分別提供了Snippet。這些Snippet的構造方法被組織為三個類：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.restdocs.request.RequestDocumentation</code> 包含用於截取請求行中各個部份的Snippet的構造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.headers.HeaderDocumentation</code> 包含用於截取請求頭和响應頭的Snippet的構造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.payload.PayloadDocumentation</code> 包含用於截取請求消息體和响應消息體的Snippet的構造方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除此之外，Spring REST Docs還為Hypermedia-Driven RESTFul Web服務提供了專用的Snippets。這些專用Snippets的構造方法被組織為類 <code>org.springframework.restdocs.hypermedia.HypermediaDocumentation</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>關於Spring REST Docs完整的資料，請參閱官方文檔 <a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="實現"><a class="link" href="#實現">實現</a></h3>
<div class="paragraph">
<p>最簡單的創建一個新的 Spring Boot 應用方法是使用 <a href="https://start.spring.io">Spring Initializr</a>。使用瀏覽器訪問 <a href="https://start.spring.io" class="bare">https://start.spring.io</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project 選擇 Gradle Project，使用 Gradle 構建我們的項目；</p>
</li>
<li>
<p>Language 選擇 Java；</p>
</li>
<li>
<p>Spring Boot 撰擇 2.2.7 或其它 2.2.x 版本，最新版（訖今為止）的 Spring Cloud Hoxton 兼容 Spring Boot 2.2.x；</p>
</li>
<li>
<p>Project Metadata 部份，Group 填 <code>io.github.rscai.microservices</code>，Artifact 填 <code>catalog</code>，Name 填 <code>catalog</code>，Packaging 撰 Jar，Java 撰擇版本 8；</p>
</li>
<li>
<p>Dependencies 選擇</p>
</li>
<li>
<p>Spring Web</p>
</li>
<li>
<p>Spring Data MongoDB</p>
</li>
<li>
<p>Rest Repositories</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/02-Catalog/generate-project-by-spring-initializr.png" alt="generate project by spring initializr">
</div>
</div>
<div class="paragraph">
<p>單擊<strong>GENERATE</strong>，Spring initializr 就會生成 ZIP 格式的項目文件。</p>
</div>
<div class="paragraph">
<p>將 <code>catalog.zip</code> 解壓後得到一個 Spring Boot 項目。其中：</p>
</div>
<div class="paragraph">
<p>Unresolved directive in zh_TR//02-Catalog.adoc - include::zh_TR/common/gradle-project-structure-basic.adoc[]</p>
</div>
<div class="paragraph">
<p>將 catalog 項目導入 IntelliJ IDEA。首先，打開 Intellij IDEA，然後，單繫 Import Project，選定 catalog 項目目錄，再然後選擇以 Gradle 項目形式導入。IntelliJ IDEA 會自動初始執行 Gradle 配置，下載 <code>/gradle/wrapper/gradle-wrapper.properties</code> 中指定版本的 Gradle。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/02-Catalog/catalog-import.gif" alt="catalog import">
</div>
</div>
<div class="sect3">
<h4 id="構建"><a class="link" href="#構建">構建</a></h4>
<div class="paragraph">
<p>本項目使用 Gradle 構建。Gradle 構建過程主要通過 <code>build.gradle</code> 描述。</p>
</div>
<div class="paragraph">
<p>首先，引用必要的 Gradle 插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'org.springframework.boot' version '2.2.2.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
	id 'io.spring.dependency-management' version '1.0.8.RELEASE' <i class="conum" data-value="2"></i><b>(2)</b>
	id 'java'
	id "io.freefair.lombok" version "4.1.6"
	id "org.sonarqube" version "2.7.1"
	id 'jacoco'
	id 'org.asciidoctor.convert' version '1.5.3'
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入 Spring Boot 插件，其版本決定了引入的 Spring Boot 庫的版本。所以有了 Spring Boot 插件，就無需顯式指定各個 Spring Boot 庫的版本了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入 Spring 依賴管理插件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，引入依賴。</p>
</div>
<div class="listingblock">
<div class="title">gradle.build</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
ext {
	snippetsDir = file('build/generated-snippets')
	set('springCloudVersion', "Hoxton.SR1") <i class="conum" data-value="1"></i><b>(1)</b>
}

dependencies {
	asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor'
	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb' <i class="conum" data-value="2"></i><b>(2)</b>
	implementation 'org.springframework.boot:spring-boot-starter-web' <i class="conum" data-value="3"></i><b>(3)</b>
	implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="4"></i><b>(4)</b>
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.security:spring-security-oauth2-resource-server'
	implementation 'org.springframework.security:spring-security-oauth2-jose'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
	testImplementation 'org.springframework.security:spring-security-test'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="5"></i><b>(5)</b>
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>將 Spring Cloud 版本定義為變量，便於引用及統一管理。Spring Cloud 與 Spring Boot 之間的版本兼容性發佈在 <a href="https://spring.io/projects/spring-cloud#overview" class="bare">https://spring.io/projects/spring-cloud#overview</a>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Release train Spring Boot compatibility</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Release Train</th>
<th class="tableblock halign-left valign-top">Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hoxton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greenwich</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finchley</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edgware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dalston</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-mongodb</code> 引入 Spring Data MongoDB 相關的庫，用以生成訪問 MongoDB 的 Repository。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>spring-boot-starter-web</code> 引入了 Spring MVC 相關的庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-rest</code> 引入 Spring Data REST 相關的庫。Spring Data REST 將 Repository 方法發佈為 RESTFul 風格的 Web 服務，以減少模板代碼。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>通過引入 <code>org.springframework.cloud:spring-cloud-dependencies</code> BOM 來管理 Spring Cloud 庫的版本。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="領域模型"><a class="link" href="#領域模型">領域模型</a></h4>
<div class="paragraph">
<p>利用Lombok編譯期生成getter/setter方法，減少重復的模板代碼。</p>
</div>
<div class="paragraph">
<p>使用Spring Data MongoDB提供的注解描述java類與MongoDB集合、java字段與MongoDB字段之間的映射關系。Spring Data MongoDB會根據映射關系生成對應的Repository實現。</p>
</div>
<div class="sect4">
<h5 id="product"><a class="link" href="#product">Product</a></h5>
<div class="listingblock">
<div class="title">Product.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class Product {

  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String title;
  private List&lt;String&gt; tags;
  @DBRef <i class="conum" data-value="5"></i><b>(5)</b>
  private List&lt;ProductImage&gt; images;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>lombok.Getter</code> 注解標注的類中所有成員字段生成getter訪問器。比如針對字段 <code>private String id</code> ，其生成了相當與以下源代碼的Getter訪問器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String getId() {
    return this.id;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>為了使使用Gradle構建項目也可處理Lombok注解、生成相應訪問器，我們需要在 <code>build.gradle</code> 中顯式引入Lombok插件：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id "io.freefair.lombok" version "4.1.5" <i class="conum" data-value="1"></i><b>(1)</b>
	...
}
...</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>lombok.Setter</code> 注解標注的類中所有成員字段生成Setter訪問器。比如針對字段 <code>private String id</code> ，其生成了相當與以下代碼的Setter訪問器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void setId(String id) {
    this.id = id;
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 將一個Java類映射到MongoDB的某個Collection。在MongoDB中，Collection是Document的集合。在Java中，Class是Object的模板，"從某個Class實例出來的Object"是一個Object的集合。所以，在Java Class/Object與MongoDB Collection/Document映射關系中，Class對應Collection，Object對應Document。而Object中的字段對應Document中的字段。
<div class="imageblock">
<div class="content">
<img src="images/diag-6a64f855599da504ff3b560cf8a9ee20.png" alt="diag 6a64f855599da504ff3b560cf8a9ee20" width="1563" height="397">
</div>
</div>
<div class="paragraph">
<p>其實例object映射為MongoDB中的一個docuemnt。object中的每一個屬性映射為document中的一個字段。比如，object中的字段 <code>id</code> 映射為Mongo document中的字段 <code>id</code> ；object中的字段 <code>title</code> 映射為Mongo document中的字段 <code>title</code> ；object中的字段 <code>tags</code> 映射為Mongo document中的字段 <code>tags</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.data.annotation.Id</code> 將對象中的字段`id`映射為文檔的主鍵 <code>id</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.data.mongodb.core.mapping.DBRef</code> 將對象中的字段 <code>images</code> 映射為一組 <code>com.mongodb.DBRef</code> 。 <code>com.mongodb.DBRef</code> 是指嚮另一個文檔的引用。 <code>@DBRef</code> 可用以標注簡單字段或集合字段。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data MongoDB提供的映射注解：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">作用目標</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段是主鍵。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@MongoId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段是主鍵，與@Id不同的是其接受一個可選的參數 <code>FieldType</code> 用以自定義變換。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Document</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該類是要映射至數據庫的。同時可以指定對應的collection名穪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@DBRef</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段會被映射為 <code>com.mongodb.DBRef</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Indexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@CompoundIndex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述聯合索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@GeoSpatialIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的地理索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@TextIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的文本索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@HashIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">聲明該字段上的HASH索引以用於分片集群上分區數據。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Language</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">為文本索引設置語言屬性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Transient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默認所有私有字段都被映射到Mongo文檔，該注解可以顯式指明不映射該字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PersistenceConstructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">構造器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明在從數據庫實例化對象時使用該構造器。構造器的實參則按名穪從數據庫文檔中穫取。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">構造器參數</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">顯式聲明構造器參數所對應的文檔字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">顯式描述字段映射，包括對應文檔中字段的名穪和類型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段將作為樂觀鎖定「Optimistic Locking」機制中的版本屬性，在保存變更之前都會先檢查版本值是否為所期望的。其初始值為 <code>0</code> ，每次變更都會自動加 <code>1</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="productimage"><a class="link" href="#productimage">ProductImage</a></h5>
<div class="listingblock">
<div class="title">ProductImage.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class ProductImage {
  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String src;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>@lombok.Getter</code> 注解標注的類中所有成員字段生成getter訪問器。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>@lombok.Setter</code> 注解標注的類中所有成員字段生成setter訪問器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 將一個類 <code>ProductImage</code> 映射至MongoDB的Collection <code>ProductImage</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.data.annotation.Id</code> 將對象中的字段 <code>id</code> 映射為文檔的主鍵 <code>id</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="倉庫-repository"><a class="link" href="#倉庫-repository">倉庫 Repository</a></h4>
<div class="paragraph">
<p><code>Repository</code> 是Spring Data抽象的中心接口。應用開發者以 <code>Repository</code> 子接口的形式聲明模型Repository及其需支持的數據訪問方法，Spring Data的具體數據存儲模塊（本例中是Spring Data MongoDB）將會為其生成相應的實現類。由於這些實現類僅包含模板代碼，所以自動生成可以大幅減少應用開發者重復工作。</p>
</div>
<div class="sect4">
<h5 id="productrepository"><a class="link" href="#productrepository">ProductRepository</a></h5>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products")
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>為模型 <code>Product</code> 創建專屬的 <code>ProductRepository</code> 接口，繼承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> . <code>MongoRepository</code> 繼承了接口 <code>PagingAndSortingRepository</code> ，Spring Data MongoDB會其生成一個支持增刪改查及分頁排序的MongoDB訪問實現類。因為 <code>ProductRepository</code> 除了繼承的方法聲明外，沒有聲明其它方法，所以Spring Data MongoDB就會直接使用通用的實現類 <code>org.springframework.data.mongodb.repository.support.SimpleMongoRepository&lt;T, ID&gt;</code> 做為其實現。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="productimagerepository"><a class="link" href="#productimagerepository">ProductImageRepository</a></h5>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages")
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>為模型 <code>ProductImage</code> 創建專屬的 <code>ProductImageRepository</code> ，繼承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="restful-web-服務"><a class="link" href="#restful-web-服務">RESTful Web 服務</a></h4>
<div class="paragraph">
<p>Spring Data REST 是Spring Data的一部份，旨於簡化在Spring Data倉庫上構建hypermedia-driven REST Web服務。應用開發者僅需在依賴中引入 <code>spring-boot-starter-data-rest</code> ，再聲明領域模型的倉庫，Spring Data REST就會將其發佈為 Hypermedia-Driven REST Web服務。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
    ...
    implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="1"></i><b>(1)</b>
    ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>將 <code>spring-boot-starter-data-rest</code> 引入至 <code>implemenation</code> 範圍依賴。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RepositoryRestResource</code> 宣告 <code>ProductRepository</code> 的數據訪問方法需被曝露為RESTful介面。RESTFul風格的API是以resource為中心，repository所專屬的模型就對應為RESTFul中的resource。 <code>@RepositoryRestResource</code> 充許應用開發者自定義模型所對應的resource在URL中及在內容體中的名字。本例中，resource Product的根RESTFul URL定義為 <code>products/</code> 。在HATEOAS標準的內容體中，Product集合會被命名為 <code>products</code> ，例如：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-07T08:04:17.818+0000",
  "updatedAt" : "2019-12-07T08:04:17.818+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data REST有四種倉庫檢測策略，用以檢測哪些倉庫應被曝露為REST Web服務。其默認的檢測策略是曝露所有公共的倉庫接口（除了通過注解顯式標注不曝露的倉庫），但我推薦使用 <code>ANNOTATION</code> 檢測策略，僅曝露以注解 <code>@RepositoryRestResource</code> 顯式標注的倉庫。以下是Spring Data REST提供的四種倉庫檢測策略：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名穪</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEFAULT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有公共的倉庫但通過注解 <code>@RestResource</code> 和 <code>@RepositoryRestResource</code> 中的 <code>exported</code> 旗標顯式標記不曝露的倉庫除外。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有倉庫，不考慮其可見性或被顯式標記為不曝露。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANNOTATED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">僅曝露被注解 <code>@RestResource</code> 或 <code>@RepositoryRestResource</code> 標記的，且其 <code>exported</code> 旗標不為 <code>false</code> 的倉庫。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VISIBILITY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">僅曝露公共的且被注解標記的倉庫。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring Data REST的檢測策略可以通過聲明一個 <code>RepositoryRestConfigurer</code> Bean來自定義。</p>
</div>
<div class="paragraph">
<p>　.RepositoryRestConfig.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration <i class="conum" data-value="1"></i><b>(1)</b>
public class RepositoryRestConfig {

  @Bean <i class="conum" data-value="2"></i><b>(2)</b>
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurer() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ANNOTATED); <i class="conum" data-value="3"></i><b>(3)</b>
      }
    };
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Configurition</code> 聲明該類為配置類。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在Spring上下文中聲明個類型為 <code>RepositoryRestConfigurer</code> 的Bean。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>構造一個子類，並覆寫方法 <code>configureRepositoryRestConfiguration</code> ，自定義倉庫檢測策略為 <code>ANNOTATED</code> 。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用注解 <code>org.springframework.data.rest.core.annotation.RepositoryRestResource</code> 宣告 <code>ProductImageRepository</code> 的數據訪問方法需被曝露為RESTFul Web服務。RESTFul Web服務是以資源為中心的， <code>ProductImageRepository</code> 所專屬於的領域模型 <code>ProductImage</code> 就對應為RESTFul中的資源。 <code>@RepositoryRestResource</code> 允許應用闕發者自定義模型所對應資源名穪。本例中，資源的名穪為`product`。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="測試"><a class="link" href="#測試">測試</a></h3>
<div class="paragraph">
<p>一個典型的軟件測試金字塔自下而上為：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>單元測測「Unit Test」</p>
</li>
<li>
<p>集成測試「Integration Test」</p>
</li>
<li>
<p>應用編程接口測試「API Test」</p>
</li>
<li>
<p>功能測試「Function Test」</p>
</li>
<li>
<p>性能測試「Performance Test」</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>單元測試是一種以單個代碼單元（在Java中就是類）為測試目標的測試方法。</p>
</div>
<div class="paragraph">
<p>我們應權衡考慮測試的覆盖度和編寫維護測試代碼的工作量。鍳於我們的應用大量使用第三框架，應用開發者編寫的代碼實際上很少，且是RESTFul的Web服務。所以跳過單元測試和集成測試，僅做應用編程接口測試是比較合適的。</p>
</div>
<div class="sect3">
<h4 id="應用編程接口測試api-test"><a class="link" href="#應用編程接口測試api-test">應用編程接口測試「API Test」</a></h4>
<div class="paragraph">
<p>Spring Test提供了Spring MVC Test框架，其為Spring MVC代碼測試提供了流暢的API，應用開發者可以方便等將其與JUnit、TestNG或其它測試框架集成。</p>
</div>
<div class="paragraph">
<p>本例中，我們集成JUnit和Spring MVC Test框架，實現應用編程接口測試。</p>
</div>
<div class="paragraph">
<p>以測試創建和讀取單個Product為例。首先，創建測試目標及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductTest {

  private static final String ENDPOINT = "/products";

  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>

  ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring擴展的JUnit Runner <code>org.springframework.test.context.junit4.SpringRunner</code> 。 <code>SpringRunner</code> 會初始化Spring上下文，從而可以在測試代碼中使用依賴注入、模組掃描等Spring特性。默認的JUnit Runner並不會初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 聲明測試用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置類，這點我們使用生產代碼相同的應用入口類配置測試上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 聲明配置MockMvc，然後就可以在測試代碼中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入ObjectMapper。MockMvc是以包裝了HTTP請求和响應的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式與DispatcherServlet通信的，所以需要構造和解析JSON格式的請求體和响應體。在測試代碼中使用與被測試代碼相同皂JSON序列化和反序列化實現可以避免編解碼不一致的麻煩。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入 <code>ProductImageRepository</code> 。在領域模型中，Product關聯ProductImage，所以有些測試用例需要預置ProductImage數據。直接使用 <code>ProductImageRepository</code> 是最直接簡單的預置ProductImage數據的方法。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，預置ProductImage數據。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @Before <i class="conum" data-value="1"></i><b>(1)</b>
  public void setUp() {
    ProductImage imageA = new ProductImage(); <i class="conum" data-value="2"></i><b>(2)</b>
    imageA.setSrc("https://aaa.bbb.ccc/ddd.png");
    imageA.setCreatedAt(new Date());
    imageA.setUpdatedAt(new Date());

    imageAId = imageRepository.save(imageA).getId(); <i class="conum" data-value="3"></i><b>(3)</b>

    ProductImage imageB = new ProductImage();
    imageB.setSrc("https://bbb.ccc.ddd/eee.png");
    imageB.setCreatedAt(new Date());
    imageB.setUpdatedAt(new Date());

    imageBId = imageRepository.save(imageB).getId();

    ProductImage imageC = new ProductImage();
    imageC.setSrc("https://ccc.ddd.eee/fff.png");
    imageC.setCreatedAt(new Date());
    imageC.setUpdatedAt(new Date());

    imageCId = imageRepository.save(imageC).getId();
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.junit.Before</code> 聲明在執行每個測試方法之前都預置一遍數據。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>構造預置的 <code>ProductImage</code> 對象。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>調用 <code>ProductImageRepository</code> 方法，將預置 <code>ProductImage</code> 對象持久化至數據庫</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，通過MockMvc嚮測試目標發送模擬RESTFul HTTP請求並校驗响應。</p>
</div>
<div class="paragraph">
<p>Hypertexy Transfer Protocol (HTTP)是一種請求/嚮應架構的通信協議。其共定義了兩種消息包：請求包和嚮應包。請求包由請求行、標頭和消息體三部份構成，嚮應包由狀態行、標頭和消息體三部份構成。MockMvc提供了豐富的工具構造請求的各個部份，和校驗嚮應的各個部份。MockMVC是直接與DispatcherServlet交互的，所以其是構造和校驗 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 對象。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  final String imageALink = obtainLinkOfImage(imageAId);
  final String imageBLink = obtainLinkOfImage(imageBId);

  final String title = "New Product";
  final String ELECTRONICS = "Electronics";
  final String MOBILE = "Mobile";

  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="2"></i><b>(2)</b>
      .andExpect(jsonPath("$.title", is(title))) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", links(), requestFields(
          fieldWithPath("images").type(JsonFieldType.ARRAY)
              .description("links of referred ProductImage")),responseFields()))
      .andReturn().getResponse().getContentAsString();

  String productId = Stream
      .of(objectMapper.readTree(createResponse).at("/_links/self/href").asText().split("/"))
      .reduce((first, second) -&gt; second).orElse(null); <i class="conum" data-value="4"></i><b>(4)</b>

  mvc.perform(get(ENDPOINT + "/{id}", productId).accept(MediaType.APPLICATION_JSON)) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/getOne", links(),
          pathParameters(parameterWithName("id").description("catalog's id")), responseFields()));

  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的構造方法構造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法會從中構造請求實例並發送給DispatcherServlet模擬HTTP請求。（後續為了從測試中生成API文檔，我們會換用兼容的 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的構造器方法。 <code>RestDocumentationRequestBuilders</code> 構造方法僅添加了文檔描述功能，HTTP協議相關的部份，如HTTP頭、响應碼等，依舊與 <code>MockMvcRequestBuilders</code> 的構造器相同。）
<div class="paragraph">
<p><code>MockMvcRequestBuilders</code> 提供了對應HTTP協議中定義的九種請求方法中的八種構造方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/MockMvcRequestBuilders.png" alt="MockMvcRequestBuilders" width="493" height="244">
</div>
</div>
<div class="paragraph">
<p>可以發現所有的構造方法都是返回同類型的構造器 <code>MockHttpServletRequestBuilder</code> ，測試代碼在穫取到 <code>MockHttpServletRequestBuilder</code> 實例後，可以繼續設置請求。 <code>MockHttpServletRequestBuilder</code> 提供了很多方法以供設置HTTP請求，這𥚃僅羅列常用的，具體請參閱源代碼：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">可設置HTTP請求內容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">accept(MediaType&#8230;&#8203; mediaTypes)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Accept`請求頭</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">contentType(MediaType mediaType)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Content-Type`請求頭</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">content(byte[] content)
content(String content)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求體</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>MockMvc的perform方法從構造器中創建mock請求例發送給DispatcherServlet，並將DispatcherServlet的响應包裝成 <code>org.springframework.test.web.servlet.ResultActions</code> 。測試代碼可以通過 <code>ResultActions</code> 提供的 <code>andExpect</code> 方法校驗响應結果；通過 <code>andDo</code> 方法附加一些操作，如打印响應內容等；通過 <code>andReturn</code> 方法讀取响應內容以做進一步操作。
<div class="imageblock">
<div class="content">
<img src="images/ResultActions.png" alt="ResultActions" width="314" height="103">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架提供了豐富的ResultMatcher供應用開發者檢驗MVC响應的各個部份。所有這些ResultMatcher都通過 <code>org.springframework.test.web.servlet.result.MockMvcResultMatchers</code> 的構造方法穫取。 <code>StatusResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一個結果檢驗器，通過方法 <code>status()</code> 穫取，用於檢驗响應狀態碼。POST請求意在創建新的實體，在成功創建新實體後RESTFul Web服務應响應狀態碼 <code>200 Created</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>JsonPathResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一個結果檢驗器，通過方法 <code>jsonPath(String expression, Matcher&lt;T&gt; matcher)</code> 穫取，用於檢驗JSON格式的响應體。 <code>JsonPathResultMatchers</code> 按JSON路徑表逹式從响應體解析出內容，再搭配Hamcrest的檢驗器就可以檢驗JSON格式响應體的任意部份。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>新創建Product實體的唯一標識是由MongoDB生成的，且以自身鏈接的一部份的形式在响應體中返回。（Hypermedia-Driven的RESTFul Web服務在展現實體內容的响應體中包含指hlvlhbr甚它實體或集合的鏈接，其中就包括指嚮自身的鏈接。RESTFul風格的資源URL形式為 <code>/&lt;resources&gt;/&lt;id&gt;</code> ，所以解析單一資源URL最後一部份就可以得到資源唯一標識。）通過 <code>ResultActions</code> 的 <code>andReturn</code> 方法穫取包含所有响應信息的對象，再從中讀取响應體，再從响應體中解析出自身鏈接，最後從自身鏈接中解析出新創建Product實體的唯一標識。
<div class="paragraph">
<p>Spring Data REST對實體內容的編碼遵循Hypertext Application Language（HAL）約定。按照HAL，表示實體的JSON中應包含object類型的屬性 <code>_links</code> ，而 <code>_links</code> 應包含一個名為 <code>self</code> 的object類型屬性， <code>self</code> 應包含名為 <code>href</code> 文本類型的屬性， <code>href</code> 即該實體的自身鏈接。JSON路徑 <code>/_links/self/href</code> 應能解析出實體的自身鏈接。創建Product實體响應體樣例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-08T07:10:53.091+0000",
  "updatedAt" : "2019-12-08T07:10:53.091+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的 <code>get</code> 構造方法構造get請求構造器。MockMvc從中構造get請求實例並發送給DispatcherServlet。再使用Spring MVC Test框架提供的結果檢驗器檢驗結果。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它Product應用編程接口測試與此相似，這𥚃就不再贅述，請參閱源碼。</p>
</div>
</div>
<div class="sect3">
<h4 id="使用嵌入式mongodb-mock-mongodb"><a class="link" href="#使用嵌入式mongodb-mock-mongodb">使用嵌入式MongoDB mock MongoDB</a></h4>
<div class="paragraph">
<p>我們的應用編程接口測試依賴運行的MongoDB服務，而可重復執行測試的一個重要特性是「不依賴外部資源或服務」。所以內嵌MongoDB服務是最佳解決方案。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
	...
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo' <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在 <code>de.flapdoodle.embed.mongo</code> 引入Gradle的testImplementation範圍依賴。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>spring-boot-autoconfigure担供了嵌入式MongoDB支持，當 <code>de.flapdoodle.embed.mongo</code> 被添加到classpath， <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration</code> 就會被激活，自動配置嵌入式MongoDB。</p>
</div>
<div class="listingblock">
<div class="title">EmbeddedMongoAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableConfigurationProperties({ MongoProperties.class, EmbeddedMongoProperties.class })
@AutoConfigureBefore(MongoAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongodStarter.class })
public class EmbeddedMongoAutoConfiguration {
  ...
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="productimage-api-test"><a class="link" href="#productimage-api-test">ProductImage API Test</a></h5>
<div class="paragraph">
<p>首先，創建測試目標及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ActiveProfiles({"test"})
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductImageTest {

  private static final String ENDPOINT = "/productImages";
  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>
  ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring擴展的JUnit Runner <code>org.springframework.test.context.junit4,SpringRunner</code> 。 <code>SpringRunner</code> 會初始化Spring上下文，從而可以在測試中使用依賴注入、模組掃描等Spring特性。默認的JUnit Runner不會初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 聲明測試用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置類，這𥚃我們使用生產代碼相同的應用入口類配置測試上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 聲明配置MockMvc，然後就可以在測試代碼中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframeowrk.beans.factory.annotation.Autowired</code> 聲明注入ObjectMapper。MockMvc是以包裝HTTP請求和响應的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式與DispatcherServlet通信的，所以需要構造和解析JSON格式的請求體和响戈人心土體。在測試代碼中使用與被測試代碼相同的JSON序列化和反序列化實現可以避免編解碼不一致的麻煩。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入ProductImageRepository，用於在測試之後清理數據庫中的ProductImage數據，避免測試之間互相干擾。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，通過MockMvc嚮測試目標發送模擬RESTFul HTTP請求並檢驗响應。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testSaveAndGetOne() throws Exception {
  final String src = "https://aaa.bbb.ccc/ddd.png";
  ProductImage newImage = new ProductImage();
  newImage.setSrc(src);

  ArgumentCaptor&lt;String&gt; linkMatcher = ArgumentCaptor.forClass(String.class);
  String responseContent = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(objectMapper.writeValueAsString(newImage))) <i class="conum" data-value="2"></i><b>(2)</b>
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON)) <i class="conum" data-value="4"></i><b>(4)</b>
      .andExpect(jsonPath("$.src", is(src))) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andDo(document("productImage/create",
          links(),
          requestFields(),
          responseFields(
              subsectionWithPath("_links").description("links to other resources"))))
      .andReturn().getResponse().getContentAsString();
  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的構造方法構造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法會從中構造請求實例並發送給DispatcherServlet模擬HTTP請求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <code>objectMapper</code> 將 <code>ProductImage</code> 對象序列化成JSON格式的字符串，填充為請求的消息體。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>status()</code> 檢驗响應狀態碼。對應成功處理的創建請求，RESTFul Web服務應响應 <code>201 Created</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用 <code>content()</code> 檢驗响應頭 <code>Content-Type</code> 應為 <code>application/json</code> 或相容的其它媒體類型。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>jsonPath()</code> 檢驗响應消息體的各個部份。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它ProductImage應用編程接口測試與此類似，這𥚃就不贅述了，詳情請參閱源碼。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="api文檔"><a class="link" href="#api文檔">API文檔</a></h3>
<div class="paragraph">
<p>使用Spring REST Docs，從應用編程接口測試中生成API文檔。</p>
</div>
<div class="paragraph">
<p>首先，引入Spring REST Docs及Asciidoctor依賴，並引入Asciidoctor插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id 'org.asciidoctor.convert' version '1.5.3' <i class="conum" data-value="1"></i><b>(1)</b>
}
...
depedencies {
  asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor' <i class="conum" data-value="2"></i><b>(2)</b>
  ...
  testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc' <i class="conum" data-value="3"></i><b>(3)</b>
}
...
ext {
	snippetsDir = file('build/generated-snippets') <i class="conum" data-value="4"></i><b>(4)</b>
	...
}

test {
	outputs.dir snippetsDir <i class="conum" data-value="5"></i><b>(5)</b>
}

asciidoctor { <i class="conum" data-value="6"></i><b>(6)</b>
	inputs.dir snippetsDir
	dependsOn test
}
...
bootJar { <i class="conum" data-value="7"></i><b>(7)</b>
	dependsOn asciidoctor
	from ("${asciidoctor.outputDir}/html5") {
		into 'static/docs'
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入Asciidoctor的Gradle插件 <code>org.asciidoctor.convert</code> ，其會引入Gradle task <code>asciidoctor</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>將 <code>spring-restdocs-asciidoctor</code> 引入至Gradle的asciidoctor範圍依賴，asciidoctor範圍是Asciidoctor插入擴展的，僅對Asciidoctor插件起效。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>將 <code>spring-restdocs-mockmvc</code> 引入Gradle的 <code>testImplementation</code> 範圍依賴，版本由Spring Boot Gradle插入統一控制。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>聲明變量 <code>snippetsDir</code> 為Spring REST Docs輸出HTTP請求响應片斷的根目錄。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>設置測試任務的輸出目錄為 <code>snippetsDir</code> 。Spring REST Docs是做為測試的一部份被執行的，其輸出根目錄即測試的輸出相錄即 <code>snippetsDir</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>配置Gradle任務asciidoctor，將 <code>snippetsDir</code> 添加為輸入目錄，Asciidoc文檔就可以引用Spring REST Docs截取的HTTP請求响應片斷了；並該任務 <code>asciidoctor</code> 依賴任務 <code>test</code> ，因為任務 <code>asciidoctor</code> 所需的請求响應片斷是在任務 <code>test</code> 中產生的，所以任務 <code>asciidoctor</code> 必須在任務 <code>test</code> 之後執行。任務 <code>asciidoctor</code> 是由Asciidoctor插件提供的。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>配置Gradle任務 <code>bootJar</code>，使其依賴任務 <code>asciidoctor</code> ，並將經 <code>asciidoctor</code> 轉換後的HTML格式文檔打包至 <code>flatjar</code> 中，置於路徑 <code>static/docs</code> 。Spring Boot默認將 <code>static/docs</code> 下的內容以靜態文件的形式發佈至URL <code>/docs/</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，在測試中激活Spring REST Docs配置。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class)
@SpringBootTest(classes = CatalogApplication.class)
@AutoConfigureMockMvc
@AutoConfigureRestDocs <i class="conum" data-value="1"></i><b>(1)</b>
public class ProductTest {
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs</code> 激活Spring REST Docs自動配置。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，用 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的mock請求構造方法替換 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的mock請求構造方法。 <code>RestDocumentationRequestBuilders</code> 構造方法返回與 <code>MockMvcRequestBuilders</code> 構造方法相同的 <code>MockHttpServletRequestBuilder</code> 。不同的是， <code>RestDocumentationRequestBuilders</code> 往 <code>MockHttpServletRequestBuilder</code> 中添加了請求屬性 <code>ATTRIBUTE_NAME_URL_TEMPLATE</code> ，使其可以從mock請求的URL模格中解析出實參。</p>
</div>
<div class="listingblock">
<div class="title">RestDocumentationRequestBuilders.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
public static MockHttpServletRequestBuilder get(String urlTemplate,
		Object... urlVariables) {
	return MockMvcRequestBuilders.get(urlTemplate, urlVariables).requestAttr(
			RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE, urlTemplate); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>RestDocumentationRequestBuilders</code> 在每個接受URL模板的構造方法中都將URL模格注冊為請求屬性，以備 <code>PathParametersSnippet</code> 從穫取請求URL中的參數化部份，如資源唯一標識等。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">PathParametersSnippet.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private String extractUrlTemplate(Operation operation) {
	String urlTemplate = (String) operation.getAttributes()
			.get(RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE); <i class="conum" data-value="1"></i><b>(1)</b>
	Assert.notNull(urlTemplate, "urlTemplate not found. If you are using MockMvc did "
			+ "you use RestDocumentationRequestBuilders to build the request?");
	return urlTemplate;
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>PathParametersSnippet</code> 從請求屬性中讀取URL模板。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，在測試中截取請求响應片斷並注釋。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  ...
  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", <i class="conum" data-value="1"></i><b>(1)</b>
              links(), <i class="conum" data-value="2"></i><b>(2)</b>
              requestFields( <i class="conum" data-value="3"></i><b>(3)</b>
                fieldWithPath("images").type(JsonFieldType.ARRAY)
                  .description("links of referred ProductImage")),
              responseFields())) <i class="conum" data-value="4"></i><b>(4)</b>
      .andReturn().getResponse().getContentAsString();
...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document(String identifier, Snippet&#8230;&#8203; snippets)</code> 方法構造一個 <code>org.springframework.restdocs.mockmvc.RestDocumentationResultHandler</code> 實例。 <code>RestDocumentationResultHandler</code> 實現了接口 <code>org.springframework.test.web.servlet.ResultHandler</code> ，可以作為 <code>org.springframework.test.web.servlet.ResultActions.andDo(ResultHandler handler)</code> 的參數，完美地嵌入MockMvc測試。
<div class="olist arabic">
<ol class="arabic">
<li>
<p>參數 <code>identitifer</code> 指明截取片斷的輸出住置。 <code>document("product/create"</code> 將把該測試過程中截取的片斷輸出至 <code>$snippetsDir/product/create</code> 。</p>
</li>
<li>
<p><code>document</code> 接受零至多個Snippet。</p>
</li>
</ol>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>構造專用於Hypermedia的 <code>org.springframework.restdocs.hypermedia.LinksSnippet</code> 。本例為了在多個測試中重用 <code>Product</code> 的 <code>LinksSnippet</code> ，而使用自定義構造方法構造 <code>Product</code> 的 <code>LinksSnippet</code>。
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static LinksSnippet links(LinkDescriptor... descriptors) {
  return HypermediaDocumentation.links(halLinks(), linkWithRel("self").description("self link"),
      linkWithRel("product").description("self link"),
      linkWithRel("images").description("related images")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服務是以資源為中心的，Hypermedia-Driven RESTFul Web服務當然依舊是以資源為中心的，資源實例的結構是相對穏定的。再加上HAL定義了一些通用的鏈接，所以 <code>Product</code> 的鏈接結構在任何場景下都是相同的。所以我們就可以使用同一構造方法為不同場景構造 <code>LinksSnippet</code> 。 <code>LinksSnippet</code> 由一系列的 <code>org.springframework.restdocs,hypermedia.LinkDescriptor</code> 組成，每一個 <code>LinkDescriptor</code> 截取和注釋一個鏈接。上述 <code>LinksSnippet</code> 截取的片斷樣例（asciidoc格式的，且包含了注釋）：</p>
</div>
<div class="listingblock">
<div class="title">links.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Relation|Description

|`+self+`
|self link

|`+product+`
|self link

|`+images+`
|related images

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>self</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>product</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">related images</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>構造 <code>org.springframework.restdocs.payload.RequestFieldsSnippet</code> ，以截取和注釋請求消息體。因同一類資源在不同場景下結構相同，所以這𥚃也通過自定義構造方法重用請求消息體 <code>Snippet</code>。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static RequestFieldsSnippet requestFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.requestFields(
    fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp").optional()
          .ignored(),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp").optional()
          .ignored()).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RequestFieldsSnippets</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 組成，每個 <code>FieldDescriptor</code> 截取和注釋請求消息體的一部份。上述 <code>RequestFieldsSnippet</code> 截取的片斷樣例（asciidoc格式且包含注釋）：</p>
</div>
<div class="listingblock">
<div class="title">request-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog's title

|`+tags+`
|`+Array+`
|tags

|`+images+`
|`+Array+`
|links of referred ProductImage

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog&#8217;s title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links of referred ProductImage</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>構造 <code>org.springframework.restdocs.payload.ResponseFieldsSnippet</code> 截取和注釋响應消息體。這𥚃依舊通過自定構造方法重用响應消息體 <code>Snippet</code> 。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static ResponseFieldsSnippet responseFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.responseFields(
      fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp"),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp"),
      subsectionWithPath("_links").description("links to other resources")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ResponseFieldsSnippet</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 組成。每個 <code>FieldDescriptor</code> 截取和注釋响應消息體的一部份。上述 <code>ResponseFieldSnippet</code> 截取的片斷樣例（asciidoc格式且包含注釋）：</p>
</div>
<div class="listingblock">
<div class="title">response-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog's title

|`+tags+`
|`+Array+`
|tags

|`+createdAt+`
|`+Date+`
|create timestamp

|`+updatedAt+`
|`+Date+`
|last update timestamp

|`+_links+`
|`+Object+`
|links to other resources

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog&#8217;s title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>createdAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">create timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>updatedAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last update timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_links</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links to other resources</p></td>
</tr>
</tbody>
</table></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，編寫asciidoc文檔並在其中引用截取的片斷。</p>
</div>
<div class="listingblock">
<div class="title">product.adoc</div>
<div class="content">
<pre>== Create

Endpoint `products`.

=== Request

include::{snippets}/product/create/http-request.adoc[]

*Request Fields:*

include::{snippets}/product/create/request-fields.adoc[]

=== Response

include::{snippets}/product/create/http-response.adoc[]

*Response Fields:*

include::{snippets}/product/create/response-fields.adoc[]</pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後的樣例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-rest-docs-product-example.png" alt="spring rest docs product example">
</div>
</div>
<div class="paragraph">
<p>其它API文檔生成方式與此相同，這𥚃就不再贅述，請參閱源碼。</p>
</div>
</div>
<div class="sect2">
<h3 id="總結"><a class="link" href="#總結">總結</a></h3>
<div class="paragraph">
<p>本章我們使用Spring Data REST從Spring Data倉庫上創建領域模型 <code>Product</code> 和 <code>ProductImage</code> 的Hypermedia-Driven RESTFul Web服務，使用Spring Data MongoDB生成領域模型 <code>Product</code> 和 <code>ProductImage</code> 的MongoDB訪問倉庫實現，使用Spring MVC Test框架測試應用編程接口，使用Spring REST Docs從測試中生成準確、易讀的API文檔。</p>
</div>
</div>
<div class="sect2">
<h3 id="參考-3"><a class="link" href="#參考-3">參考</a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/">Spring Data Commons - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/">Spring Data MongoDB - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/rest/docs/current/reference/html/">Spring Data REST Reference Guide</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="服務注冊與發現service-registry-discovery"><a class="link" href="#服務注冊與發現service-registry-discovery">服務注冊與發現「Service Registry &amp; Discovery」</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="目標-2"><a class="link" href="#目標-2">目標</a></h3>
<div class="ulist">
<ul>
<li>
<p>理解服務注冊與發現「Service Registry and Discovery」模式</p>
</li>
<li>
<p>使用Eureka實現服務注冊與發現</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="理解服務注冊與發現service-registry-discovery"><a class="link" href="#理解服務注冊與發現service-registry-discovery">理解服務注冊與發現「Service Registry &amp; Discovery」</a></h3>
<div class="paragraph">
<p>服務注冊與發現「Service Registry and Discovery」（有時穪為服務注冊「Service Registry」或服務發現「Service Discovery」是微服務架構中常用的模式。</p>
</div>
<div class="paragraph">
<p>由於微服務架構的固有特性，生產環境中的服務都是不斷地變化的，服務實例也是不斷地被創建和銷毁的。消費者服務需要一種機制去實時地發現可用的服務實例，服務注冊與發現就是其中一種解決方案。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/service-registry-discovery.png" alt="service registry discovery" width="489" height="162">
</div>
</div>
<div class="paragraph">
<p>服務注冊維護着服務實例的元數據（包含服務名穪、實例的主機地址、監聽的端口等）。服務實例啟動時主動嚮服務注冊注冊自身元數據，在停止時主動嚮服務注冊注銷自身元數據。</p>
</div>
<div class="paragraph">
<p>消費者服務通過服務名穪從服務注冊穫取可用的服務實例信息，然後直接與服務實例通信。</p>
</div>
<div class="paragraph">
<p>舉個例子，Service Registry &amp; Discovery 服務是一直存活着的，微服務的實例 instanceA 和 instanceB 存活的時間較短且其啟動與停止皆是不可預知的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>instanceA 啟動之後會主動嚮 Service Registry &amp; Discovery 注冊自身；</p>
</li>
<li>
<p>Consumer 先從 Service Registry &amp; Discovery 發現（discover）微服務的實例；</p>
</li>
<li>
<p>Service Registry &amp; Discovery 從自已維謢的服務實例元信息中尋找一個可用的服務實例，將其IP及端口等信息返回給 Consumer；</p>
</li>
<li>
<p>Consumer 通過服務實例的IP及端口訪問服務實例；</p>
</li>
<li>
<p>instanceA 在常規停止時可以將自身從 Service Registry &amp; Discovery 處注銷，但大多數情況下服務實例是被強制停止的，來不及主動注銷，所以 Service Registry &amp; Discovery 要有能力處理已死但未注銷的服務實例；</p>
</li>
<li>
<p>新的 instanceB 啟動時也會嚮 Service Registry &amp; Discovery 注冊；</p>
</li>
<li>
<p>Consumer 再一次從 Service Registry &amp; Discovery 發現服務實例；</p>
</li>
<li>
<p>Service Registry &amp; Discovery 從自己維護的服務實例元信息中尋找一個可用的服務實例 instanceB，將其 IP 及端口等信息返回給 Consumer；</p>
</li>
<li>
<p>Consumer 通過服務實例的 IP 及端口訪問服務實例。</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="images/service-registry-and-discovery-example.png" alt="service registry and discovery example" width="712" height="359">
</div>
<div class="title">Figure 5. 服務注冊與發現</div>
</div>
</div>
<div class="sect2">
<h3 id="理解eureka"><a class="link" href="#理解eureka">理解Eureka</a></h3>
<div class="paragraph">
<p>Eureka是由Netflix捐贈給開源社區的基於Spring Boot的服務注冊與發現實現。</p>
</div>
<div class="paragraph">
<p>Eureka服務端提供服務注冊服務，其沒有將服務元數據持久化至磁盤。而且也沒有必要將服務元數據持久化，因為服務實例的狀態是隨時變化的，持久化的狀態毫無意義。</p>
</div>
<div class="paragraph">
<p>Eureka服務端提供了單獨「Standalone」和結對「Peer」兩種運行模式。默認情況下，Eureka服務端運行在結對模式。以下Spring Boot應用配置文件配置一組兩節點結對的Eureka服務端：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1
  client:
    serviceUrl:
      defaultZone: https://peer2/eureka/
---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2
  client:
    serviceUrl:
      defaultZone: https://peer1/eureka/</code></pre>
</div>
</div>
<div class="paragraph">
<p>當Eureka服務端以profile <code>peer1</code> 運行在結點 <code>peer1</code> 時，將自己做為客戶端注冊至 <code>peer2</code>；當Eureka服務端以profile <code>peer2</code> 運行在結點 <code>peer2</code> 時，將自己做為客戶端注冊至 <code>peer1</code>。<code>peer1</code> 和 <code>peer2</code> 實時同步注冊務元數據，當其中一個實例重啟時，會從另一個實例同步元數據，從而實現高可用性「High Availability」。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/two-peer-aware-eureka-server.png" alt="two peer aware eureka server" width="444" height="127">
</div>
</div>
<div class="paragraph">
<p>結對模式也可用於多於兩個Eureka服務端實例結對。以下Spring Boot應用配置文件配置了一組三節點Eureka服務端結對：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">eureka:
  client:
    serviceUrl:
      defaultZone: https://peer1/eureka/,https://peer2/eureka,https://peer3/eureka
---
spring:
  profiles: peer1
eureka:
  instance:
    hostname: peer1

---
spring:
  profiles: peer2
eureka:
  instance:
    hostname: peer2

---
spring:
  profiles: peer3
eureka:
  instance:
    hostname: peer3</code></pre>
</div>
</div>
<div class="paragraph">
<p>當以profile <code>peer1</code>、<code>peer2</code> 和 <code>peer3</code> 分別運行三個Eureka服務端實例在三個主機上時，它們各自將自身注冊至三個Eureka服務端。任一實例都實時與其它兩個實例同步元數據。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/three-peer-aware-eureka-server.png" alt="three peer aware eureka server" width="387" height="243">
</div>
</div>
<div class="paragraph">
<p>Eureka服務端默認以結對模式運行，若要以單獨「Standalone」模式運行，需顯示關閉其客戶端注冊特性。</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">eureka:
  instance:
    hostname: localhost
  client:
    registerWithEureka: false <i class="conum" data-value="1"></i><b>(1)</b>
    fetchRegistry: false <i class="conum" data-value="2"></i><b>(2)</b>
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>顯式關閉服務注冊。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>顯式關閉從對方同步服務注冊元數據。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>即使以單獨模式運行，依舊要顯式聲明服務諯（即自身）URL。</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="協議"><a class="link" href="#協議">協議</a></h4>
<div class="paragraph">
<p>Eureka服務端開放RESTFul風格的Web服務，客戶端和結對的其它服務端可以通過此RESTFul Web服務注冊和發現服務。Eureka維護的核心元數據是應用「application」和實例「instance」。</p>
</div>
<div class="paragraph">
<p>應用「application」僅維護一個屬性 <code>appName</code>。</p>
</div>
<div class="paragraph">
<p>實例「instance」以 <code>InstanceInfo</code> 的形式維護。<code>InstanceInfo</code> 維護着很多屬性，其中服務消費者最常用的有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ipAddr</code>，服務實例的 IP 地址；</p>
</li>
<li>
<p><code>port</code>，服務實例監聽的端口；</p>
</li>
<li>
<p><code>securePort</code>，服務實例監聽的安全端口（HTTPS 服務監聽的端口）。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/InstanceInfo-class.png" alt="InstanceInfo class" width="851" height="631">
</div>
<div class="title">Figure 6. InstanceInfo</div>
</div>
<div class="sect4">
<h5 id="注冊服務"><a class="link" href="#注冊服務">注冊服務</a></h5>
<div class="paragraph">
<p>客戶端通過 <code>POST</code> 請求嚮服務端注冊服務，請求目標 URL 的格式為 <code>/eureka/apps/{appName}</code>。</p>
</div>
<div class="listingblock">
<div class="title">注冊服務請求樣例</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">POST /eureka/apps/CATALOG HTTP/1.1
Accept-Encoding: gzip
Content-Type: application/json
Accept: application/json
DiscoveryIdentity-Name: DefaultClient
DiscoveryIdentity-Version: 1.4
DiscoveryIdentity-Id: 192.168.199.141
User-Agent: Java-EurekaClient/v1.9.13

{
   "instance":{
      "instanceId":"macbook-pro.lan:catalog:8081",
      "hostName":"macbook-pro.lan",
      "app":"CATALOG",
      "ipAddr":"192.168.199.141",
      "status":"DOWN",
      "overriddenStatus":"UNKNOWN",
      "port":{
         "$":8081,
         "@enabled":"true"
      },
      "securePort":{
         "$":443,
         "@enabled":"false"
      },
      "countryId":1,
      "dataCenterInfo":{
         "@class":"com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo",
         "name":"MyOwn"
      },
      "leaseInfo":{
         "renewalIntervalInSecs":30,
         "durationInSecs":90,
         "registrationTimestamp":0,
         "lastRenewalTimestamp":0,
         "evictionTimestamp":0,
         "serviceUpTimestamp":0
      },
      "metadata":{
         "management.port":"8081"
      },
      "homePageUrl":"http://macbook-pro.lan:8081/",
      "statusPageUrl":"http://macbook-pro.lan:8081/actuator/info",
      "healthCheckUrl":"http://macbook-pro.lan:8081/actuator/health",
      "vipAddress":"catalog",
      "secureVipAddress":"catalog",
      "isCoordinatingDiscoveryServer":"false",
      "lastUpdatedTimestamp":"1576139530623",
      "lastDirtyTimestamp":"1576139611782"
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="服務實例心跳狀態"><a class="link" href="#服務實例心跳狀態">服務實例心跳狀態</a></h5>
<div class="paragraph">
<p>服務實例應定時嚮服務端發送心跳狀態。心跳狀態通過 <code>PUT</code> 請求發送給服務端。心跳請求 URL 格式為 <code>/eureka/apps/{appName}/{instanceId}</code>。</p>
</div>
<div class="listingblock">
<div class="title">心跳狀態請求樣例</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">PUT /eureka/apps/CATALOG/macbook-pro.lan:catalog:8081?status=UP&amp;lastDirtyTimestamp=1576139630424 HTTP/1.1
DiscoveryIdentity-Name: DefaultClient
DiscoveryIdentity-Version: 1.4
DiscoveryIdentity-Id: 192.168.199.141
Accept-Encoding: gzip
User-Agent: Java-EurekaClient/v1.9.13</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="注銷服務"><a class="link" href="#注銷服務">注銷服務</a></h5>
<div class="paragraph">
<p>客戶端通 <code>DELETE</code> 請求注銷服務實例，請求的目標URL格式為 <code>/eureka/apps/{appName}/{instanceId}</code>。</p>
</div>
<div class="listingblock">
<div class="title">注銷服務實例請求樣例</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">DELETE /eureka/apps/CATALOG/macbook-pro.lan:catalog:8081 HTTP/1.1
DiscoveryIdentity-Name: DefaultClient
DiscoveryIdentity-Version: 1.4
DiscoveryIdentity-Id: 192.168.199.141
Accept-Encoding: gzip
User-Agent: Java-EurekaClient/v1.9.13</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="發現服務"><a class="link" href="#發現服務">發現服務</a></h5>
<div class="paragraph">
<p>其定期從服務注冊與發現服務處理獲取全部注冊的服務實例，再本地搜尋某個應用的實例。</p>
</div>
<div class="paragraph">
<p>獲取全部注冊服務實例的請求樣例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">GET /eureka/apps/delta HTTP/1.1
Accept: application/json
DiscoveryIdentity-Name: DefaultClient
DiscoveryIdentity-Version: 1.4
DiscoveryIdentity-Id: 192.168.199.141
Accept-Encoding: gzip
Host: localhost:9001
Connection: Keep-Alive
User-Agent: Java-EurekaClient/v1.9.13</code></pre>
</div>
</div>
<div class="paragraph">
<p>响應樣例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">HTTP/1.1 200
Content-Encoding: gzip
Content-Type: application/json
Content-Length: 617
Date: Mon, 22 Jun 2020 07:48:34 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{
    "applications": {
        "versions__delta": "2",
        "apps__hashcode": "UP_2_",
        "application": [
            {
                "name": "CATALOG",
                "instance": [
                    {
                        "instanceId": "192.168.199.141:catalog:8081",
                        "hostName": "192.168.199.141",
                        "app": "CATALOG",
                        "ipAddr": "192.168.199.141",
                        "status": "UP",
                        "overriddenStatus": "UNKNOWN",
                        "port": {
                            "$": 8081,
                            "@enabled": "true"
                        },
                        "securePort": {
                            "$": 443,
                            "@enabled": "false"
                        },
                        "countryId": 1,
                        "dataCenterInfo": {
                            "@class": "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo",
                            "name": "MyOwn"
                        },
                        "leaseInfo": {
                            "renewalIntervalInSecs": 30,
                            "durationInSecs": 90,
                            "registrationTimestamp": 1592811966623,
                            "lastRenewalTimestamp": 1592812146532,
                            "evictionTimestamp": 0,
                            "serviceUpTimestamp": 1592811966623
                        },
                        "metadata": {
                            "management.port": "8081"
                        },
                        "homePageUrl": "http://192.168.199.141:8081/",
                        "statusPageUrl": "http://192.168.199.141:8081/actuator/info",
                        "healthCheckUrl": "http://192.168.199.141:8081/actuator/health",
                        "vipAddress": "catalog",
                        "secureVipAddress": "catalog",
                        "isCoordinatingDiscoveryServer": "false",
                        "lastUpdatedTimestamp": "1592811966624",
                        "lastDirtyTimestamp": "1592811966498",
                        "actionType": "ADDED"
                    }
                ]
            }
        ]
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="實現-2"><a class="link" href="#實現-2">實現</a></h3>
<div class="paragraph">
<p>供由 Spring Cloud Netflix，可以輕鬆地實現基於 Eureka 的服務注冊與發現。</p>
</div>
<div class="sect3">
<h4 id="創建eureka服務端"><a class="link" href="#創建eureka服務端">創建Eureka服務端</a></h4>
<div class="paragraph">
<p>首先，創建一個獨立的Spring Boot應用實現Eureka服務端。</p>
</div>
<div class="paragraph">
<p>然後，配置 <code>build.gradle</code>。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'org.springframework.boot' version '2.1.0.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
	id 'io.spring.dependency-management' version '1.0.8.RELEASE' <i class="conum" data-value="2"></i><b>(2)</b>
	id 'java'
}

group = 'io.github.rscai.microservices'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '1.8'

repositories {
	mavenCentral()
	maven { url 'https://repo.spring.io/milestone' } <i class="conum" data-value="3"></i><b>(3)</b>
}

ext {
	set('springCloudVersion', "Greenwich.SR3") <i class="conum" data-value="4"></i><b>(4)</b>
}

dependencies {
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-server' <i class="conum" data-value="5"></i><b>(5)</b>
	testImplementation('org.springframework.boot:spring-boot-starter-test') {
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="6"></i><b>(6)</b>
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入Spring Boot的Gradle插件。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入Spring依賴管理插件。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>添加Spring里程碑倉庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>統一聲明Spring Cloud的版本，Eureka是做為Spring Cloud Netflix項目的一部份編護和發佈的，Spring Cloud的版本也作用於Eureka。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>將 <code>spring-cloud-starter-netflix-eureka-server</code> 引入至 <code>implementation</code> 範圍的依賴。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>通過 <code>dependencyManagement</code> 統一管理Spring Cloud包的版本。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，在Spring Boot應用配置類上添加注解 <code>@EnableEurekaServer</code> 激活Eureka服務端配置。</p>
</div>
<div class="listingblock">
<div class="title">EurekaApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringBootApplication
@EnableEurekaServer <i class="conum" data-value="1"></i><b>(1)</b>
public class EurekaApplication {

	public static void main(String[] args) {
		SpringApplication.run(EurekaApplication.class, args);
	}

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.springframework.cloud.netflix.eureka.server.EnbaleEurekaServer</code> 標注應用入口類，激活Eureka服務端自動配置。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，在應用配置文件中配置監聽端口及Eureka相關屬性。</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">server:
  port: 9001 <i class="conum" data-value="1"></i><b>(1)</b>

eureka:
  instance:
    hostname: localhost <i class="conum" data-value="2"></i><b>(2)</b>
  client:
    registerWithEureka: false <i class="conum" data-value="3"></i><b>(3)</b>
    fetchRegistry: false
    serviceUrl:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>設置監聽端口為 <code>9001</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>顯示設置服務端主機名。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>本例Eureka服務端以單獨模式運行，所以顯示關閉服務注冊（以客戶端身份）和注冊信息同步。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>將服務端地址指嚮自身。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在命令行中執行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">./gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>就會啟動Eureka服務端。其提供了一個基於Web的控制面版，在瀏覧器地址欗中輸入 <code><a href="http://localhost:9001" class="bare">http://localhost:9001</a></code> 就可以訪問。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/eureka-dashboard.png" alt="Eureka Server Dashboard">
</div>
</div>
</div>
<div class="sect3">
<h4 id="注冊服務-2"><a class="link" href="#注冊服務-2">注冊服務</a></h4>
<div class="paragraph">
<p>以 catalog 服務為例。首先，在 <code>build.gradle</code> 中引入Eureka客戶端依賴。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
ext {
	snippetsDir = file('build/generated-snippets')
	set('springCloudVersion', "Greenwich.SR3") <i class="conum" data-value="1"></i><b>(1)</b>
}

dependencies {
    ...
    implementation 'org.springframework.boot:spring-boot-starter-actuator' <i class="conum" data-value="2"></i><b>(2)</b>
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client' <i class="conum" data-value="3"></i><b>(3)</b>
	...
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="4"></i><b>(4)</b>
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>跟服務端項目相似，統一設置變量 <code>springCloudVersion</code> 管理Eureka及其它Spring Cloud模組的版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入依賴 <code>spring-boot-starter-actuator</code>，以提供狀態頁 <code>/info</code> 和健康指示 <code>/health</code>。做為服務實例元數據的一部份，服務實例需嚮Eureka服務端注冊狀態頁和健康指示的URL，而Spring Boot Actuator正好實現了它們。引入 spring-boot-starter-actuator` 是最快的實現符合Eureka規範狀態頁和健康指示的方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>引入依賴 <code>spring-cloud-start-netflix-eureka-client</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>統一管理Eureka及其它Spring Cloud模組版本。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，使用注解 <code>@EnableEurekaClient</code> 激活Eureka客戶端自動配置。</p>
</div>
<div class="listingblock">
<div class="title">CatalogApplication.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SpringBootApplication
@EnableEurekaClient <i class="conum" data-value="1"></i><b>(1)</b>
public class CatalogApplication {

  public static void main(String[] args) {
    SpringApplication.run(CatalogApplication.class, args);
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.springframework.cloud.netflix.eureka.EnableEurekaClient</code> 激活Eureka客戶端自動配置。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，在應用配置文件中配置Eureka相關屬性。</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">...
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:9001/eureka/ <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>本例中，Eureka服務端以單獨模式運行，客戶端祗需要與一個服務端通信、注冊和發現服務。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>打開命令行，進入Catalog項目根目錄，執行命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">.gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>就可以啟動Catalog服務，並嚮Eureka服務端注冊自身。</p>
</div>
</div>
<div class="sect3">
<h4 id="發現服務-2"><a class="link" href="#發現服務-2">發現服務</a></h4>
<div class="paragraph">
<p>將在 API Gateway 章節中介紹。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="總結-2"><a class="link" href="#總結-2">總結</a></h3>
<div class="paragraph">
<p>通過本章的學習，我們理解了服務注冊與發現模式；使用Eureka實現服務注冊服務；使用Eureka將Spring Boot應用嚮Eureka注冊服務注冊，並從Eureka注冊服務發現服務實例。</p>
</div>
</div>
<div class="sect2">
<h3 id="參考-4"><a class="link" href="#參考-4">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://dzone.com/articles/getting-started-with-microservices-2">Microservices: Service Registration and Discovery</a></p>
</li>
<li>
<p><a href="https://github.com/Netflix/eureka/wiki">Netflix Eureka</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-netflix/reference/html/">Spring Cloud Netflix</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api-gateway"><a class="link" href="#api-gateway">API Gateway</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="目標-3"><a class="link" href="#目標-3">目標</a></h3>
<div class="ulist">
<ul>
<li>
<p>理解API Gateway模式</p>
</li>
<li>
<p>使用Spring Cloud Gateway實現API Gateway</p>
</li>
<li>
<p>集成 Spring Cloud Gateway 與 Eureka，自動發現服務並路由</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="理解api-gateway模式"><a class="link" href="#理解api-gateway模式">理解API Gateway模式</a></h3>
<div class="paragraph">
<p>在微服務架構中，每一個微服務都曝露一組細粒度的通信終點。在此架構下，客戶端與微服務之間的通信方式有客戶端微服務直接通信和API Gateway模式兩種。</p>
</div>
<div class="sect3">
<h4 id="客戶端與微服務直接通信"><a class="link" href="#客戶端與微服務直接通信">客戶端與微服務直接通信</a></h4>
<div class="paragraph">
<p>在客戶端與微服務直接通信模式中，微服務運行在受信任網絡中，客戶端（如運行在Web瀏覧器中的網頁腳本、移動設備中的應用等）運行在非受信任網絡中。微服務與微服務之間直接通過REST終點通信，客戶端與微服務之間也直接通過REST終點通信。所有的微服務都運行在受信任網絡中，所以來自微服務的請求都是可信的。但是來自微服務的請求和來自客戶端（運行在不受信任網絡）的請求共用通信終點，微服務無法區分它們，所以微服務祗能把所有請求都當作不可信請求處理，校驗所有請求的認證信息。</p>
</div>
<div class="paragraph">
<p>在實際生產環境中，微服務實例是不斷地被創建和銷毁的。所以客戶端在和微服務直接通信之前，需要發現服務實例。實際的服務部署應如下圖所示，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/client-microservices-direct-communication.png" alt="client microservices direct communication" width="684" height="527">
</div>
</div>
<div class="paragraph">
<p>每個客戶端都需先訪問服務注冊服務，發現服務實例，再與服務實例直接通信。且因服務實例是被不斷創建和銷毁的，客戶端而不時地重新發現服務實例。以運行在Web瀏覧器中的頁面訪問Catalog微服務為例，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/client-discover-service.png" alt="client discover service" width="413" height="214">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>首先，Web瀏覧器先請求服務注冊服務，發現Catalog服務實例。</p>
</li>
<li>
<p>服務注冊服務訪問一個可用的Catalog服務實例信息，包括IP、端口等。</p>
</li>
<li>
<p>然後，Web瀏覧器再直接請求Catalog服務實例。</p>
</li>
<li>
<p>Catalog微服務直接响應結果給Web瀏覧器。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>因為微服務實例是不斷被創建和更新，所以Web瀏覧器不時地重新發現服務實例（重新發現策略有每次請求前重新發現、一段時間後定時發現、服務實例响應不可用後重新發現等）。</p>
</div>
<div class="paragraph">
<p>該模式的優點有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>客戶端與微服務直接通信，沒有延遲，沒有單點故障。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>該模式的缺點有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>客戶端邏輯複雜，需顯式處理服務發現及負載均衡。</p>
</li>
<li>
<p>服務端與客戶端網絡沒有有效隔離，應用需承担更多的安全職責。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="api-gateway模式"><a class="link" href="#api-gateway模式">API Gateway模式</a></h4>
<div class="paragraph">
<p>API Gateway模式在微服務和客戶端之間增加一個服務。微服務依舊是運行在受信任的網絡中，客戶端運行在受信任網絡之外。從受信任網絡之外不能直接訪問任何微服務，客戶端僅能訪問API Gateway，API Gateway從服務注冊處發現微服務，再將請求路由給微服務。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/api-gateway-deployment.png" alt="api gateway deployment" width="843" height="536">
</div>
</div>
<div class="paragraph">
<p>以運行在Web瀏覧器中的頁面請求Catalog微服務為例，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/api-gateway-communication.png" alt="api gateway communication" width="525" height="272">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Web 瀏覧器發送請求給 API Gateway；</p>
</li>
<li>
<p>API Gateway 請求服務注冊服務，發現 Catalog 微服務的實例；</p>
</li>
<li>
<p>服務注冊服務响應一個可用的 Catalog 微服務實例；</p>
</li>
<li>
<p>API Gateway 將 Web 瀏覧器的請求路由給 Catalog 微服務實例；</p>
</li>
<li>
<p>Catalog 微服務實例處理請求，再將响應發回 API Gateway；</p>
</li>
<li>
<p>API Gateway 將微服務响應返迴給Web瀏覧器。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>該模式優點：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>統一請求入口，方便進行認證、鍳權、審計等通用處理。</p>
</li>
<li>
<p>嚮客戶端隠藏服務端實現，便於微服務變更。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>該模式缺點：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>增加通信延遲。</p>
</li>
<li>
<p>有單點故障風險。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解spring-cloud-gateway"><a class="link" href="#理解spring-cloud-gateway">理解Spring Cloud Gateway</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>該項目提供了一個用於在Spring MVC之上構建API網關的庫。 Spring Cloud Gateway旨在提供一種簡單而有效的方法來路由到API，並為它們提供跨領域的關注，例如：安全性，監視/指標和彈性。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring Cloud Gateway<br>
<cite>https://spring.io/projects/spring-cloud-gateway</cite>
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway的主要特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>構建於Spring Framework 5、Project Reactor和Spring Boot 2.0之上</p>
</li>
<li>
<p>能按任意請求屬性匹配路由</p>
</li>
<li>
<p>路由特定的斷言「predicate」和過濾器「filter」</p>
</li>
<li>
<p>Hystrix Circuit Breaker集成</p>
</li>
<li>
<p>Spring Cloud DiscoveryClient集成</p>
</li>
<li>
<p>容易編寫預判「Predicate」和過濾器「Filter」</p>
</li>
<li>
<p>請求速率限制</p>
</li>
<li>
<p>路徑重寫</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway中三個重要概念：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>路由「Route」</strong>：路由是構建網關的基本單位。其由一個唯一標識、一個目的URI、一組斷言「predicate」和一組過濾器「filter」定義。當所有斷逼都為真時匹配route。</p>
</li>
<li>
<p><strong>斷言「Predicate」</strong>：斷言是Java 8函數斷言「Function Predicate」。其接受類型為Spring Framework <code>ServerWebExchange</code> 的輸入。其允許應用開發者匹配HTTP請求的任何部份，例如請求頭或請求參數。</p>
</li>
<li>
<p><strong>過濾器「Filter」</strong>：這些是使用特定工廠構造的Spring Framework <code>GatewayFilter</code> 實例。 通過它們，可以在發送下游請求之前或之後修改請求和響應。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-cloud-gateway-process.png" alt="spring cloud gateway process" width="522" height="506">
</div>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway核心工作由路由完成。客戶端嚮網關發送請求，網關檢測匹配的路由（當路由中所有斷言都為真時匹配），網關再讓請求穿過過濾器鏈，最終發送給目的服務。</p>
</div>
<div class="paragraph">
<p>請求與路由之間的匹配是通過斷言定義的。由於HTTP請求報文的結構特性，應用程序可以高效地解析請求行和請求頭，但不能高效解析請求消息體（因其是變長的，且相較與請求報文其它部份體積巨大）。所以路由斷言應僅斷言請求行及請求頭。</p>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway提供了豐富的斷言，應用開發者可以通過斷言工廠構造斷言，匹配請求行或頭的任意部份。</p>
</div>
<div class="paragraph">
<p>斷言實現為Java 8的 <code>java.util.function.Predicate&lt;T&gt;</code>，斷言工廠其實就是構造 <code>Predicate&lt;ServerWebExchange&gt;</code> 對象。以 <code>org.springframework.cloud.gateway.handler.predicate.AfterRouteRedicateFactory</code> 為例，其以annoymous內部類的形式定義了兼容 <code>Predicate&lt;ServeWebExchange&gt;</code> 的斷言類，並構造其對象實例。</p>
</div>
<div class="listingblock">
<div class="title">AfterRoutePredicateFactory.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class AfterRoutePredicateFactory
		extends AbstractRoutePredicateFactory&lt;AfterRoutePredicateFactory.Config&gt; {

	...
	@Override
	public Predicate&lt;ServerWebExchange&gt; apply(Config config) {
		return new GatewayPredicate() {
			@Override
			public boolean test(ServerWebExchange serverWebExchange) {
				final ZonedDateTime now = ZonedDateTime.now();
				return now.isAfter(config.getDatetime());
			}

			@Override
			public String toString() {
				return String.format("After: %s", config.getDatetime());
			}
		};
	}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>路由過濾器可以修改進的HTTP請求或出的HTTP响應。過濾器一般僅作用於單個路由，但Spring Cloud Gateway也支持全局過濾器。全局過濾器作用於所有路由。</p>
</div>
<div class="paragraph">
<p>過濾器的實現與斷言類似，路由特定的過濾器實現為兼容接口 <code>org.springframework.cloud.gateway.filter.GatewayFilter</code> 的對象，全局過濾器則是實現接口 <code>org.springframework.cloud.gateway.filter.GlobalFilter</code> 的對象。以路由特性過濾器工廠 <code>org.springframework.cloud.gateway.filter.factory.AddRequest&#8217;HeaderGatewayFilterFactory</code> 為例，過濾器工廠以annoymous內部類的形式定義兼容類，再構造對象。</p>
</div>
<div class="listingblock">
<div class="title">AddRequestHeaderGatewayFilterFactory.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class AddRequestHeaderGatewayFilterFactory extends AbstractNameValueGatewayFilterFactory {
  public AddRequestHeaderGatewayFilterFactory() {
  }

  public GatewayFilter apply(NameValueConfig config) {
    return new GatewayFilter() {
      public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        String value = ServerWebExchangeUtils.expand(exchange, config.getValue());
        ServerHttpRequest request = exchange.getRequest().mutate().header(config.getName(), value).build();
        return chain.filter(exchange.mutate().request(request).build());
      }

      public String toString() {
        return GatewayToStringStyler.filterToStringCreator(AddRequestHeaderGatewayFilterFactory.this).append(config.getName(), config.getValue()).toString();
      }
    };
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>全局過濾器以接口 <code>GlobalFilter</code> 的實現類形式實現。以 <code>org.springframework.cloud.gateway.filter.ForwardRoutingFilter</code> 為例，其實現接口 <code>GlobalFilter</code> 且實現方法 <code>Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain)</code>。</p>
</div>
<div class="listingblock">
<div class="title">ForwardRoutingFilter.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ForwardRoutingFilter implements GlobalFilter, Ordered {

        ...
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}

	@Override
	public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
		URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);

		String scheme = requestUrl.getScheme();
		if (isAlreadyRouted(exchange) || !"forward".equals(scheme)) {
			return chain.filter(exchange);
		}

		// TODO: translate url?

		if (log.isTraceEnabled()) {
			log.trace("Forwarding to URI: " + requestUrl);
		}

		return this.getDispatcherHandler().handle(exchange);
	}

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解cross-origin-resource-sharingcors"><a class="link" href="#理解cross-origin-resource-sharingcors">理解Cross-Origin Resource Sharing(CORS)</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>跨來源資源共用（Cross-Origin Resource Sharing (CORS)）是一種使用額外 HTTP 標頭令目前瀏覽網站的使用者代理取得存取其他來源（網域）伺服器特定資源權限的機制。當使用者代理請求一個不是目前文件來源——例如來自於不同網域（domain）、通訊協定（protocol）或通訊埠（port）的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 跨來源資源共用（CORS）<br>
<cite>https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS</cite>
</div>
</div>
<div class="paragraph">
<p>受「同源政策（Same-Origin policy）」限制，網頁中的腳本祗能請求與網頁相同網域的HTTP資源。「跨來源資源共用機制提供了Web應用跨網域的存取控制，增加跨網域資料傳輸的安全性。</p>
</div>
<div class="paragraph">
<p>CORS以網域、請求方法和請求頭三個方面控制跨來源資源共用，其在HTTP請求和响應報文中加入一組擴展頭來交換存取控制信息。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">頭</th>
<th class="tableblock halign-left valign-top">作用域</th>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Origin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS請求，CORS預檢請求</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">網域</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明請求者（網頁腳本）的來源網域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Request-Method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS預檢請求</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP請求方法，多個值之間用逗號分隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求者將要發送的請求方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Request-Headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS預檢請求</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP頭名穪，多個值之間用逗號分隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求者將要發送的請求中携帶的頭。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Allow-Origin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應，CORS預檢响應</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">網域</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允許與之共用資源的網域。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Allow-Credentials</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明當請求的凭證模式「credentials mode」是 <code>include</code> 的時候是否可共用資源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Allow-Methods</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應，CORS預檢响應</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP請求方法，多個值之間用逗號分隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被允許在CORS請求中使用的HTTP方法。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Allow-Headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應，CORS預檢响應</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP頭，多個值之間用逗號分隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">被允許在CORS請求中使用的HTTP標頭。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Max-Age</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應，CORS預檢响應</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">秒數</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Access-Control-Allow-Methods</code> 和 <code>Access-'control-Allow-Headers</code> 的有效期限。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access-Control-Expose-Headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CORS响應，CORS預檢响應</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP標頭，多個值之間用逗號分隔</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通過列出標題的名稱來指示哪些標題可以作為響應的一部分公開。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一個典型的CORS請求由CORS預檢「CORS-preflight request」和CORS請求兩步組成。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cors-request.png" alt="cors request" width="468" height="261">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶端以 <code>OPTIONS</code> 方法嚮服務端發送CORS預檢。CORS預檢通過CORS擴展HTTP頭嚮服務端表明預檢項。</p>
</li>
<li>
<p>服務端响應CORS預檢，以HTTP頭形式表明允許的跨來源共用。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>對於一些「簡單請求（simple requests）」，可以省略CORS預檢。一個不觸發CORS預檢的簡單請求需滿足以下所有條件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>僅允許下列HTTP方法</p>
<div class="ulist">
<ul>
<li>
<p><code>GET</code></p>
</li>
<li>
<p><code>HEAD</code></p>
</li>
<li>
<p><code>POST</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>僅可包含「CORS安全列表請求標頭（CORS-safelisted request-header）」</p>
<div class="ulist">
<ul>
<li>
<p><code>Acccept</code></p>
</li>
<li>
<p><code>Accept-Language</code></p>
</li>
<li>
<p><code>Content-Type</code></p>
</li>
<li>
<p><code>Last-Event-Id</code></p>
</li>
<li>
<p><code>DPR</code></p>
</li>
<li>
<p><code>Save-Data</code></p>
</li>
<li>
<p><code>Viewport-Width</code></p>
</li>
<li>
<p><code>Width</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>僅允許以下 <code>Content-Type</code> 標頭值：</p>
<div class="ulist">
<ul>
<li>
<p><code>application/x-www-form-urlencoded</code></p>
</li>
<li>
<p><code>multupart/form-data</code></p>
</li>
<li>
<p><code>text/plain</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>沒有事件監聽器被注冊到任何用來發出請求的 <code>XMLHttpRequestUpload</code> 物件上。</p>
</li>
<li>
<p>請求中沒有 <code>ReadableStream</code> 物件被用於上傳。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cors-simple-request.png" alt="cors simple request" width="300" height="201">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>簡單請求無需CORS預檢，可直接發送CORS請求。</p>
</li>
<li>
<p>服務務器在响應中需添加CORS標頭。</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="實現-3"><a class="link" href="#實現-3">實現</a></h3>
<div class="paragraph">
<p>首先，借助Spring Initializr生成項目骨架。</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="paragraph">
<p>然後，打開 <code>build.gradle</code> 做一些必要的配置。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'org.springframework.boot' version '2.1.0.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
}
apply plugin: 'java'
apply plugin: 'io.spring.dependency-management' <i class="conum" data-value="2"></i><b>(2)</b>

group = 'io.github.rscai.microservices'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '1.8'

repositories {
	mavenCentral()
	maven { url 'https://repo.spring.io/milestone' } <i class="conum" data-value="3"></i><b>(3)</b>
}

ext {
	set('springCloudVersion', "Greenwich.SR3") <i class="conum" data-value="4"></i><b>(4)</b>
}

dependencies {
	implementation 'org.springframework.cloud:spring-cloud-starter-gateway' <i class="conum" data-value="5"></i><b>(5)</b>
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client' <i class="conum" data-value="6"></i><b>(6)</b>
	testImplementation('org.springframework.boot:spring-boot-starter-test') {
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="7"></i><b>(7)</b>
	}
}

test {
	useJUnitPlatform()
}

bootRun {
	String springProfilesActive = System.properties['spring.profiles.active'] <i class="conum" data-value="8"></i><b>(8)</b>
	systemProperty "spring.profiles.active", springProfilesActive
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入Spring Boot的Gradle插件 <code>org.springframework.boot</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入Spring依賴插件 <code>io.spring.dependency-management</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>添加Spring里程碑倉庫，以便引用里程碑版本庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>將Spring Cloud版本提取出來設置為變量，從而統一控制Spring Cloud庫的版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>引入 <code>spring-cloud-starter-gateway</code> 至 <code>implementation</code> 範圍依賴。<code>spring-cloud-starter-gateway</code> 引用了Spring Cloud Gateway所有依賴的庫，引用 <code>spring-cloud-starter-gateway</code> 就等同於將所有Spring Cloud Gateway依賴庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>引入 <code>spring-cloud-starter-netflix-eureka-client</code> 至 <code>implementation</code> 範圍依賴。Spring Cloud Gateway支持從Eureka發現服務並通過Eureka維護的微服務元數據自動配置路由。Spring Cloud Gateway依賴Eureka DiscoveryClient實現與Eureka的集成。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>通過Gradle的dependencyManagement功能統一管理Spring Cloud庫的版本。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>將Gradle接受到的 <code>spring.profiles.active</code> 系統屬性傳遞給任務 <code>bootRun</code>。通過Gradle運行Spring Boot應用時，就可以以系統屬性的方式指定profile了。
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">./gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Cloud Gateway的自動配置是通過配置屬性 <code>spring.cloud.gateway.enabled</code> 及類 <code>org.springframework.web.reactive.DispatchHandler</code> 激活的，且 <code>spring.cloud.gateway.enabled</code> 缺省值為 <code>true</code> ，<code>DispatchHandler</code> 則被包含在 spring-cloud-starter-gateway` 閶接引用的 <code>spring-webflux</code> 中，所以引入 <code>spring-cloud-starter-gateway</code> 就會激活自動配置，無需使用特定的注解。</p>
</div>
<div class="listingblock">
<div class="title">GatewayAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ConditionalOnProperty(name = "spring.cloud.gateway.enabled", matchIfMissing = true) <i class="conum" data-value="1"></i><b>(1)</b>
@EnableConfigurationProperties
@AutoConfigureBefore({ HttpHandlerAutoConfiguration.class,
		WebFluxAutoConfiguration.class })
@AutoConfigureAfter({ GatewayLoadBalancerClientAutoConfiguration.class,
		GatewayClassPathWarningAutoConfiguration.class })
@ConditionalOnClass(DispatcherHandler.class) <i class="conum" data-value="2"></i><b>(2)</b>
public class GatewayAutoConfiguration {
  ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>當屬性 <code>spring.cloud.gateway.enabled</code> 被設置為 <code>true</code> 時或缺失時，激活自動配置（需結合其它條件）。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>當類 <code>org.springframework.web.reactive.DispatchHandler</code> 出現在classpath時，激活自動配置。Spring Cloud Gateway是構建於Spring WebFlux（Spring的Reactive Web MVC框架）之上的，Spring Cloud Gateway以 <code>DispatchHandler</code> 為指標，當Spring WebFlux存在於classpath時才配置自身。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，通過應用配置文件配置Eureka集成和CORS。</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml(gateway)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">server:
  port: 9101 <i class="conum" data-value="1"></i><b>(1)</b>
spring:
  application:
    name: gateway <i class="conum" data-value="2"></i><b>(2)</b>
  cloud:
    compatibility-verifier:
      enabled: true
    gateway:
      discovery:
        locator:
          enabled: true <i class="conum" data-value="3"></i><b>(3)</b>
          lowerCaseServiceId: true
      forwarded:
        enabled: true <i class="conum" data-value="4"></i><b>(4)</b>
      x-forwarded:
        enabled: true
        forEnabled: true
        portEnabled: true
        prefixEnabled: true
      globalcors: <i class="conum" data-value="5"></i><b>(5)</b>
        corsConfigurations:
          '[/**]':
            allowedOrigins: '*'
            allowedHeaders: '*'
            allowedMethods: '*'
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:9001/eureka/ <i class="conum" data-value="6"></i><b>(6)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>設置網關監聽的端口。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>設置應用名穪。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>設置屬性 <code>spring.cloud.gateway.discovery.locator.enabled</code> 為 <code>true</code> 將激活配置Bean <code>org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator</code>。
<div class="listingblock">
<div class="title">GatewayDiscoveryClientAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Bean
@ConditionalOnBean(DiscoveryClient.class)
@ConditionalOnProperty(name = "spring.cloud.gateway.discovery.locator.enabled")
public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator(
    DiscoveryClient discoveryClient, DiscoveryLocatorProperties properties) {
  return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DiscoveryClientRouteDefinitionLocator</code> 用於構造一個路由，該路由由一個 <code>PathRoutePredicate</code> 和一個 <code>RewritePathGatewayFilter</code> 組成。該路由匹配符合模式 <code>'/'+serviceId+'/<strong>*'`的請求路徑，從Eureka發現名穪為 `serviceId</code> 的服務，並將請求路徑改寫為 <code>'/' + serviceId + '/(?&lt;remaining&gt;.</strong>)'</code> 後發送給目的微服務。</p>
</div>
<div class="listingblock">
<div class="title">GatewayDiscoveryClientAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
public static List&lt;PredicateDefinition&gt; initPredicates() {
	ArrayList&lt;PredicateDefinition&gt; definitions = new ArrayList&lt;&gt;();
	// TODO: add a predicate that matches the url at /serviceId?

	// add a predicate that matches the url at /serviceId/**
	PredicateDefinition predicate = new PredicateDefinition();
	predicate.setName(normalizeRoutePredicateName(PathRoutePredicateFactory.class));
	predicate.addArg(PATTERN_KEY, "'/'+serviceId+'/**'");
	definitions.add(predicate);
	return definitions;
}

public static List&lt;FilterDefinition&gt; initFilters() {
	ArrayList&lt;FilterDefinition&gt; definitions = new ArrayList&lt;&gt;();

	// add a filter that removes /serviceId by default
	FilterDefinition filter = new FilterDefinition();
	filter.setName(normalizeFilterFactoryName(RewritePathGatewayFilterFactory.class));
	String regex = "'/' + serviceId + '/(?&lt;remaining&gt;.*)'";
	String replacement = "'/${remaining}'";
	filter.addArg(REGEXP_KEY, regex);
	filter.addArg(REPLACEMENT_KEY, replacement);
	definitions.add(filter);

        return definitions;
}
...</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>設置屬性 <code>spring.cloud.gateway.forwarded.enabled</code> 為 <code>true</code> （缺省值為 <code>true</code> ）激活 <code>org.springframework.cloud.gateway.filter.headers.ForwardedHeadersFilter</code> 配置。<code>ForwardedHeadersFilter</code> 將請求中的所有頭都分發給目的微服務。
<div class="listingblock">
<div class="title">GatewayAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Bean
@ConditionalOnProperty(name = "spring.cloud.gateway.forwarded.enabled", matchIfMissing = true)
public ForwardedHeadersFilter forwardedHeadersFilter() {
	return new ForwardedHeadersFilter();
}
...</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>設置屬性 <code>spring.cloud.gateway.x-forwarded.enabled</code> 為 <code>true</code> （缺省值為 <code>true</code> ）激活 <code>org.springframework.cloud.gateway.filter.XForwardedHeadersFilter</code> 配置。<code>XForwardedHeadersFilter</code> 將在將請求分發給目的微服務之前嚮其中添加 <code>X-Forward-*</code> 標頭。
<div class="listingblock">
<div class="title">GatewayAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Bean
@ConditionalOnProperty(name = "spring.cloud.gateway.x-forwarded.enabled", matchIfMissing = true)
public XForwardedHeadersFilter xForwardedHeadersFilter() {
	return new XForwardedHeadersFilter();
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>還得我們的目的微服務是Hypermedia-Driven RESTFul Web服務，其會在响應體中帶上絕對路徑的資源URL。但是目的微服務的根上下文跟網關的根上下不同，網關是重寫了請求路徑才匹配目的微服務的URL路徑的。以請求所有Catalog Product為例，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/gateway-rewrite-path.png" alt="gateway rewrite path" width="923" height="500">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶端嚮網關發送 <code>GET <a href="http://localhost:9101/catalog/products" class="bare">http://localhost:9101/catalog/products</a></code>；</p>
</li>
<li>
<p>網關從請求路徑中解析出服務名穪 <code>catalog</code>，從Eureka處發現其實例主機地址為 <code>localhost</code>，端口為 <code>8081</code>。網關將請求路徑改寫為 <code>/products</code>，再分發給發現的目的Catalog服務。網關發送給Catalog服務實例的完整路徑為 <code><a href="http://localhost:8081/products" class="bare">http://localhost:8081/products</a></code>。</p>
</li>
<li>
<p>Catalog服務實例响應HAL格式的資源內容，其中資源URL主機地址、端口和根路徑都使用自身配置的。所有Product集合資源URL被編為 <code><a href="http://localhost:8081/products" class="bare">http://localhost:8081/products</a></code>；</p>
</li>
<li>
<p>很明顯客戶端並不能訪問响應的資源鏈接 <code><a href="http://localhost:8081/products" class="bare">http://localhost:8081/products</a></code>。在API Gateway架構模式中，Catalog服務沒有直接曝露給客戶端。</p>
<div class="paragraph">
<p>為了使目的微服務能穫取網關的主機地址，端口及重寫之前的路徑，並在資源鏈接中使用網關的地址與路徑，網關就需要以 <code>X-Forwarded-<strong></code> 標頭的形式將信息傳送給目的服務。<code>X-Forwarded-</strong></code> 雖然被廣泛應用，它們並沒有被標準化。Spring Cloud Gateway支持以下 <code>X-Forwarded-*</code> 標頭：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名穪</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-Forwarded-For</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">源請求來源IP地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-Forwarded-Host</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">源請求的主機（域）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-Forwarded-Port</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">源請求的端口。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-Forwarded-Proto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">源請求的協議（http或https）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X-Forwarded-Prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">源請求的路徑前綴（被 <code>RewritePathFilter</code> 移除的部份）。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除此之外，還需在目的微服務中通過屬性 <code>server.use-forward-headers</code> 顯示激活 <code>X-Forwarde-*</code> 標頭的處理。</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml(catalog)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">server:
  ...
  use-forward-headers: true
...</code></pre>
</div>
</div>
</li>
</ol>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>配置CORS。在API Gateway模式下，所有請求和响應都經過網關。所以在網關處處理CORS是最合理的。
<div class="ulist">
<ul>
<li>
<p>使用通配符 <code>[/**]</code> 處理作用所有資源</p>
</li>
<li>
<p>然後允許與所有網域共用資源 <code>allowedOrigins: '*'</code></p>
</li>
<li>
<p>再然後允許CORS請求使用任意標頭 <code>allowedHeaders: '*'</code></p>
</li>
<li>
<p>再然後允許CORS請求使用任意方法 <code>allowedMethods: '*'</code></p>
</li>
</ul>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，在命令行中執行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="bash" class="language-bash hljs">./gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>網關就會監聽在端口 <code>9101</code>，可以通過URL <code><a href="http://localhost:9101/&lt;serviceId&gt" class="bare">http://localhost:9101/&lt;serviceId&gt</a>;</code> 訪問所有注冊在Eureka的微服務了。</p>
</div>
</div>
<div class="sect2">
<h3 id="總結-3"><a class="link" href="#總結-3">總結</a></h3>
<div class="paragraph">
<p>本章我們使用Spring Cloud Gateway構建API Gateway，並集成Eureka，使其可以自動從Eureka中發現微服務並路由請求給微服務。我們在網關中配置CORS，使網關代理的所有資源都可以被跨來源共用。</p>
</div>
</div>
<div class="sect2">
<h3 id="參考-5"><a class="link" href="#參考-5">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/projects/spring-cloud-gateway">Spring Cloud Gateway</a></p>
</li>
<li>
<p><a href="https://fetch.spec.whatwg.org/#http-cors-protocol">CORS protocol</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="security"><a class="link" href="#security">Security</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="目標-4"><a class="link" href="#目標-4">目標</a></h3>
<div class="ulist">
<ul>
<li>
<p>理解認證「Authentication」與授權「Authorization」</p>
</li>
<li>
<p>理解 OAuth 協議</p>
</li>
<li>
<p>使用 Spring Cloud Security 實現 OAuth 認證與授權</p>
</li>
<li>
<p>在 API Gateway 實現認證</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="認證與授權"><a class="link" href="#認證與授權">認證與授權</a></h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>身分驗證（英語：Authentication）又穪「認證」、「鑒權」，是指通過一定的手段，完成對用戶身分的確認。</p>
</div>
<div class="paragraph">
<p>身分驗證的目的是確認當前所聲穪為某種身分的用戶，確實是所聲穪的用戶。在日常生活中，身分驗證並不罕見；比如，通過檢查對方的證件，我們一般可以確信對方的身分。雖然日常生活中的這種確認對方身分的做法也屬於廣義的「身分驗證」，但「身分驗證」一詞更多地被用在電腦、通信等領域。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 身份認證<br>
<cite>https://zh.wikipedia.org/wiki/身份认证</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>授權（英語：Authorization）一般是指對資訊安全或電腦安全相關的資源定義與授多存取權限，尤指存取控制。動詞「授權」可指定義存取策略與接受存取。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 授權<br>
<cite>https://zh.wikipedia.org/wiki/授權_(資安)</cite>
</div>
</div>
<div class="paragraph">
<p>一次資源訪問行為可描述為：某人對某物做某個行為。認證是驗證某人為何人，而授權則驗證某人可否對某物做某個行為。舉個例子，類目管理員添加新的商品。當中，人為類目管理員，物為新的商品，行為為添加。認證階段驗證其人是否真為所宣穪的類目管理員，授權階段則驗證類目管理員是否有權添加新的商品。</p>
</div>
</div>
<div class="sect2">
<h3 id="設計-2"><a class="link" href="#設計-2">設計</a></h3>
<div class="paragraph">
<p>按照 OAuth 協議實現單點登入模式。
採用單點登入模式。採用 Cloud Foundry 的 UAA 實現認證與授權。在 Gateway處認證校驗。各個服務再作具體的授權校驗。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-57da8828796023edf759cb92aa4e0341.png" alt="diag 57da8828796023edf759cb92aa4e0341" width="201" height="267">
</div>
<div class="title">Figure 7. 架構</div>
</div>
<div class="paragraph">
<p>以 Catalog 服務為例，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-b5f47ab384ec7eeb0ce951041b0038ac.png" alt="diag b5f47ab384ec7eeb0ce951041b0038ac" width="498" height="401">
</div>
</div>
<div class="sect3">
<h4 id="oauth"><a class="link" href="#oauth">OAuth</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>開放授權（OAuth）是一個開放標準，允許用戶讓第三方應用存取該用戶在某一網站上儲存的私密的資源（如相片，影片，聯絡人列表），而無需將用戶名穪和密碼提供給第三方應用。</p>
</div>
<div class="paragraph">
<p>OAuth 允許用戶提供一個權仗，而不是用戶名穪和密碼來存取他們存放在特定服務提供者的資料。每一個權仗授權一個特定的網站（例如，影片編輯網站）在特定的時段（例如，接下來的2小時內）內存取特定的資源（例如僅僅是某一相簿中的影片）。這樣，OAuth 讓用戶可以授權第三方網站存取他們儲存在另外服務提供者的某些特定資訊，而非所有內容。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 開放授權<br>
<cite>https://zh.wikipedia.org/wiki/开放授权</cite>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/traditional-authentication-authorization-mechanism.png" alt="traditional authentication authorization mechanism" width="340" height="356">
</div>
<div class="title">Figure 8. 傳統認證授權機制</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>當用戶使用第三方應用時，比如使用圖片編輯應用訪問在線相冊中的相片，第三方應用需從資源服務器處訪問資源；</p>
</li>
<li>
<p>資源服務器會要求授權。完整應該是要求先認證再授權。但對任何請求，如果沒有聲明身分則都被視為匿名用戶「Anonynous」；</p>
</li>
<li>
<p>第三方應用像資源所有者即用戶請求認證；</p>
</li>
<li>
<p>資源所有者將自已的身分凭證，如密碼等，交給第三方应用；</p>
</li>
<li>
<p>第三方應用將資源所有者的身分凭證及資源請求一同提交給資源服務；</p>
</li>
<li>
<p>資源服務器校驗身分凭證；</p>
</li>
<li>
<p>資源服務器按照身分授於相應的權限；</p>
</li>
<li>
<p>資源服務器確認第三方應用具有相應的權限後，返回資源。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>該機制的缺點很明顯，資源所有者必須將身分凭證交由第三方應用。第三方應用有意濫用或無意泄露都會使資源用者所有的資源都受到非法訪問。</p>
</div>
<div class="paragraph">
<p>而 OAuth 避免了第三方應用接觸到資源所有者身分凭證。</p>
</div>
<div class="paragraph">
<p>OAuth 定義了四種⻆色：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">資源所有者「resource owner」</dt>
<dd>
<p>一個有能力授予受保護資源訪問的實體。當資源所有者為人時，其指代最終用戶。</p>
</dd>
<dt class="hdlist1">資源服務器「resource server」</dt>
<dd>
<p>持有受保護資源的服務器，有能力接受和响應用帶有訪問令牌的受保護資源請求。</p>
</dd>
<dt class="hdlist1">客戶「client」</dt>
<dd>
<p>代資源所有者執行受保護資源請求與授權的應用。"客戶"一詞沒有指定任何特定的實現特征（比如，無論該應用是運行在服務器、桌面或其它設備上）。</p>
</dd>
<dt class="hdlist1">授權服務器「authorization server」</dt>
<dd>
<p>在成功認證資源所有者及獲取授權後簽發訪問令牌的服務器。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>一個典型的 OAuth 認證授權過程如下：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oauth2-abstract-protocal-flow.png" alt="oauth2 abstract protocal flow" width="278" height="272">
</div>
<div class="title">Figure 9. OAuth2 Abstract Protocal Flow</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶嚮資源所有者請求授權。該授權請求可以是直接發給資源所有者，也可以經由授權服務器中轉。</p>
</li>
<li>
<p>客戶收到授權補助。該授權補助內容取決於所選用的授權凭證類型。OAuth2 定義了四種授權補助類型。</p>
</li>
<li>
<p>客戶嚮授權服務器提交授權補助以換取訪問令牌。</p>
</li>
<li>
<p>授權服務器認證客戶，校驗授權補助，如有效則頒發訪問令牌。</p>
</li>
<li>
<p>客戶訪問受保護資源，並同時嚮資源服務器出示訪問令牌。</p>
</li>
<li>
<p>資源服務器校驗訪問令牌，若有效則响應受保護的資源。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>OAuth2 定義了四種授權補助類型：Authorization Code, Implicit, Resource Owner Password Credentials 和 Client Credentials.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Authorization Code</dt>
<dd>
<div class="paragraph">
<p>該類型將授權服務器作為客戶與資源所有者之間的媒介。不同於從資源所有者直接請求授權，客戶將資源所有者導嚮授權服務器，授權服務器再將資源所有者導回客戶同時帶上授權補助。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oauth2-authorization-grant-type-authorization-code.png" alt="oauth2 authorization grant type authorization code" width="489" height="301">
</div>
<div class="title">Figure 10. Authorization Code</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶開始這個流程，將資源所有者的用戶代理導嚮授權服務器。客戶提供客戶標識、請求範圍、本地狀態和重定嚮URI，授權服務器會在訪問被允許時攴回這些信息給用戶代理。</p>
</li>
<li>
<p>資源所有者將自己的身分凭證提交給用戶代理。</p>
</li>
<li>
<p>用戶代理將身分凭證連同客戶標識及重定嚮URI一起提交給用授權服務器。</p>
</li>
<li>
<p>授權服務器校驗客戶標識、重定URI及資源所有者身分凭證，若通過則返回授權碼給用戶代理。</p>
</li>
<li>
<p>用戶代理將授權碼交給客戶。</p>
</li>
<li>
<p>客戶嚮授權服務器提交授權、重定嚮URI及客戶標識。</p>
</li>
<li>
<p>授權服務器將訪問令牌發送給客戶所提供的重定嚮URI。</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在這個認證授權過程中，客戶自始至終都沒有接觸到資源所有者身分凭證，確保了資源所有者的身分凭證不會被客戶濫用或泄露。授權服務器將訪問令牌發送給合法的重定嚮URI而非在HTTP响應中返回，阻止了攻擊者冒充客戶。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Implicit</dt>
<dd>
<div class="paragraph">
<p>該類型是為運行於瀏覧器的客戶而優化的簡版 Authorization Code 流程。在此流程中，不再頒發授權碼給客戶，而是直接頒發訪問令牌給客戶。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oauth2-authorization-grant-type-implicit.png" alt="oauth2 authorization grant type implicit" width="498" height="301">
</div>
<div class="title">Figure 11. Implicit</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶開始這個流程，將資源所有者的用戶代理導嚮授權服務器。客戶提供客戶標識、請求範圍、本地狀態和重定嚮URI，授權服務器會在訪問被允許時攴回這些信息給用戶代理。</p>
</li>
<li>
<p>資源所有者將自己的身分凭證提交給用戶代理。</p>
</li>
<li>
<p>用戶代理將身分凭證連同客戶標識及重定嚮URI一起提交給用授權服務器。</p>
</li>
<li>
<p>授權服務器將用戶代理重定嚮至之前提供的URI，並將訪問令牌以 fragment 的形式附加至 URI。</p>
</li>
<li>
<p>用戶代理重定嚮至URI，該URI一般跟客戶強綁定。</p>
</li>
<li>
<p>該URI返回一段可在瀏覧器中執行的腳本，該腳本將從 URI 的 fragment 中解出訪問令牌。</p>
</li>
<li>
<p>用戶代理將訪問令牌交給客戶。</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Resource Owner Password Credentials</dt>
<dd>
<div class="paragraph">
<p>該類型直接使用資源所有者的密碼凭證（如用戶名和密碼）獲取訪問令牌。應僅當資源所有者與客戶之間高度信任的情況下使用此類型。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oauth2-authorization-grant-type-resource-owner-password-credentials.png" alt="oauth2 authorization grant type resource owner password credentials" width="197" height="184">
</div>
<div class="title">Figure 12. Resource Owner Password Credentials</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>資源所有者將其身分凭證（一般是用戶名和密碼）提供給客戶。</p>
</li>
<li>
<p>客戶將資源使用者的身分凭證提交給授權服務器。</p>
</li>
<li>
<p>授權服務器將訪問令牌返回給客戶。</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Client Credentials</dt>
<dd>
<div class="paragraph">
<p>直接用客戶凭證獲取訪問令牌。此方式類型應僅用於獲取客戶所拥有的受保資源的訪問權限。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/oauth2-authorization-grant-type-client-credentials.png" alt="oauth2 authorization grant type client credentials" width="129" height="155">
</div>
<div class="title">Figure 13. Client Credentials</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客戶嚮授權服務器提交自己的凭證（client_id 和 client_secret）。</p>
</li>
<li>
<p>授權服務器校驗客戶凭證，若通過則返回訪問令牌。</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="access-token"><a class="link" href="#access-token">Access Token</a></h5>
<div class="paragraph">
<p>當嚮資源服務器請求受保護資源時，有三種方式可以傳送訪問令牌「Access Token」。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Authorization 請求頭</dt>
<dd>
<p>當以 Authorization 請求頭傳送訪問令牌時，應使用"Bearer"方案。例如</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">GET /resource HTTP/1.1
Host: server.example.com
Authorization: Bearer mF_9.B5f-4.1JqM</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Form-Econded 請求體</dt>
<dd>
<p>當以請求體的一部份傳送訪問令牌時，請求體的內容類型必須為 <code>application/x-www-form-urlencoded</code>。例如</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=mF_9.B5f-4.1JqM</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">URI 請求參數</dt>
<dd>
<p>訪問令牌也可以以查詢參數 <code>access_token</code> 的形式被傳送。例如</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="http" class="language-http hljs">GET /resource?access_token=mF_9.B5f-4.1JqM HTTP/1.1
Host: server.example.com</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-security"><a class="link" href="#spring-security">Spring Security</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Security 是一個強大的，高度可客製化的認證與訪問控制框架。其是保護基於 Spring 的應用的事實上的標準。</p>
</div>
<div class="paragraph">
<p>Spring Security 是一個專注於為 Java 應用提供認證與授權的框架。與所有 Spring 項目一樣，在發覺其是多麼容易地被擴展以滿足客戶需求才能明白 Spring Security 真實的力量。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring Security<br>
<cite>https://spring.io/projects/spring-security#overview</cite>
</div>
</div>
<div class="sect4">
<h5 id="認證"><a class="link" href="#認證">認證</a></h5>
<div class="paragraph">
<p>認證的核心為接口 <code>AuthenticationManager</code> 及其實現 <code>AuthenticationProvider</code>。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-security-authentication-class.png" alt="spring security authentication class" width="598" height="229">
</div>
<div class="title">Figure 14. Spring Security Authentication</div>
</div>
<div class="paragraph">
<p><code>AuthenticationManager</code> 僅有一個方法 <code>authenticate()</code>，該只會做三件事：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>若輸入的凭證是有效的，則返回一個 <code>Authentication</code> 对象；</p>
</li>
<li>
<p>若輸入的凭證是無效的，則拋出一個 <code>AuthenticationException</code>；</p>
</li>
<li>
<p>若無法決定，則返回 <code>null</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>最常用的 <code>AuthenticationManager</code> 實現為 <code>ProviderManager</code>，其將認證工作委派給一串 <code>AuthenticationProvider</code> 實例。<code>AuthenticationProvider</code> 提供了兩個方法 <code>authenticate</code> 和 <code>supports</code>。多個 <code>AuthenticationProvider</code> 以責任鏈模式串聯在一起，輸入的凭證將逐一經過 <code>AuthenticationProvider</code>。每個 <code>AuthenticationProvider</code> 先用 <code>supports</code> 判斷是否支持校驗該類型的凭證，若是則使用 <code>authenticate</code> 校驗凭證，若否則交由下一個 <code>AuthenticationProvider</code> 處理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/AuthenticationProvider.png" alt="AuthenticationProvider" width="599" height="90">
</div>
<div class="title">Figure 15. AuthenticationProvider</div>
</div>
<div class="paragraph">
<p><code>ProviderManager</code> 本身包含一個可選的上級 <code>AuthenticationManager</code>，通過其實現多級委派。有時應中受保護的資源被分為多個組，每組使用不同的 <code>AuthenticationManager</code>。當當前 <code>AuthenticationManager</code> 無法做出決定時則回退至上級 <code>AuthenticationManager</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="授權"><a class="link" href="#授權">授權</a></h5>
<div class="paragraph">
<p>授權的核心是 <code>AccessDecisionManager</code>。框架提供的三個實現類 <code>AffirmativeBased, ConsensusBased, UnanimousBased</code> 皆以責任鏈模式將訪問決定委派給一串 <code>AccessDecisionVoter</code>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">AffirmativeBased</dt>
<dd>
<p>若有一個及以上 <code>AccessDecisonVoter</code> 同意則允許，若有一個及以上 <code>AccessDecisionVoter</code> 反對且無任何 <code>AccessDecisionVoter</code> 同意則拒絕。此為默認 <code>AccessDecisionManager</code>。</p>
</dd>
<dt class="hdlist1">ConsensusBased</dt>
<dd>
<p>若表示同意的 <code>AccessDecisionVoter</code> 大於表示反對的則允許，反之則拒絕。</p>
</dd>
<dt class="hdlist1">UnanimousBased</dt>
<dd>
<p>若所有 <code>AccessDecisionVoter</code> 都同意則允許，否則拒絕。</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="images/AccessDecisionManager.png" alt="AccessDecisionManager" width="1028" height="367">
</div>
<div class="title">Figure 16. AccessDecisionManager</div>
</div>
<div class="paragraph">
<p><code>AccessDecisionVoter</code> 接受一個 <code>authentication</code> 和一個用 <code>ConfigAttributes</code> 裝飾的受保護的 <code>Object</code>。<code>Object</code> 是完全通用的的其表示用戶想要訪問的資源（URL、方法等等）。<code>ConfigAttributes</code> 也是相當地通用，其表示訪問 <code>Object</code> 所需要的權限（如拥有某些⻆色）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/AccessDEcisionVoter.png" alt="AccessDEcisionVoter" width="554" height="141">
</div>
<div class="title">Figure 17. AccessDecisionVoter</div>
</div>
</div>
<div class="sect4">
<h5 id="web-security"><a class="link" href="#web-security">Web Security</a></h5>
<div class="paragraph">
<p>Java Servlet 定義了請求處理框架。客戶端發送過來的請求先經過過濾器「Filter」鏈，再交由 Servlet 處理。Servlet 處理後的結果再反嚮經過過濾器鏈，最後再發回給客戶端。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/java-servlet.png" alt="java servlet" width="251" height="506">
</div>
<div class="title">Figure 18. Java Servlet Framework</div>
</div>
<div class="paragraph">
<p>Spring MVC 實現了 Servlet <code>DispatcherServlet</code>，將請求導嚮 Controllers。Spring Security 將 <code>FilterChainProxy</code> 插入到過濾器鏈中。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/web-security.png" alt="web security" width="362" height="508">
</div>
<div class="title">Figure 19. Web Security</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-cloud-security"><a class="link" href="#spring-cloud-security">Spring Cloud Security</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Cloud Security提供了一組原語，用於以最少的麻煩構建安全的應用程序和服務。可通過外部（或集中地）深度配置的聲明式模型，可被用於實現包含協作，遠程組件，一般還有集中式標識管理服務的大型係統。在 Cloud Foundry 等服務平台中使用其也非常容易。基於 Spring Boot 和 Spring Security OAuth2，我們可以快速地創建實現常見模式（如單點登錄、令牌中繼和令牌交換）的系統。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring Cloud Security
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="實現-4"><a class="link" href="#實現-4">實現</a></h3>
<div class="sect3">
<h4 id="uaa"><a class="link" href="#uaa">UAA</a></h4>
<div class="paragraph">
<p>User Account and Authentication (UAA) 是一個由 Cloud Foundry 開發並維護的，兼容 OAuth2 的授權服務器實現。UAA 的配置與使用不在本文的範圍之內。請使用提供的 Dockerfile 構建 UAA Docker 鏡像並運行之：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在命令行中，克隆包含 UAA Dockerfile 及本文適用的配置文件的 GitHub 倉庫：</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">git clone git://github.com/rscai/microservices-uaa.git</code></pre>
</div>
</div>
</li>
<li>
<p>然後，進入至項目根目錄：</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">cd microservices-uaa
ls</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以發現其包含了構建 Docker 鏡像所需的 Dockerfile 及 UAA 配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Dockerfile
READ.adoc
host-manager.xml
manager.xml
server.xml
tomcat-users.xml
uaa.yml</pre>
</div>
</div>
</li>
<li>
<p>構建 Docker 鏡像：</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker build --tag uaa .</code></pre>
</div>
</div>
</li>
<li>
<p>創建 Docker 容器並運行（在容器內，UAA監聽在端口8090。將其映射至宿主端口9103）：</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker run -p 9103:8090 --name=uaa uaa</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>為了方便，客戶信息（OAuth2 中的客戶）及測試用戶信息都硬編碼在 uaa.yml 中。</p>
</div>
<div class="listingblock">
<div class="title">uaa.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">...

oauth:
  user:
    authorities:
      - openid
      - scim.me
      - password.write
      - scim.userids
      - uaa.user
      - approvals.me
      - oauth.approvals
  clients:
    gateway: <i class="conum" data-value="1"></i><b>(1)</b>
      name: gateway <i class="conum" data-value="2"></i><b>(2)</b>
      secret: secret
      authorized-grant-types: authorization_code <i class="conum" data-value="3"></i><b>(3)</b>
      scope: uaa.user,openid,profile,email,catalog.read,catalog.write,inventory.read,inventory.write,order.use,order.operate <i class="conum" data-value="4"></i><b>(4)</b>
      authorities: uaa.resource
      redirect-uri: http://localhost:9101/login/oauth2/code/gateway <i class="conum" data-value="5"></i><b>(5)</b>
    service: <i class="conum" data-value="6"></i><b>(6)</b>
      name: service
      secret: secret
      authorized-grant-types: password
      scope: uaa.user,openid,profile,email,catalog.read,catalog.write,inventory.read,inventory.write,order.use,order.operate
      authorities: uaa.resource
scim:
  groups:
    email: Access your email address
    catalog.read: Read catalog <i class="conum" data-value="7"></i><b>(7)</b>
    catalog.write: Write catalog
    inventory.read: Read inventory
    inventory.write: Write inventory
    order.use: Create, submit, cancel and close owned order
    order.operate: cancel, mark pay, start delivery and complete order
  users:
    - customer1|password|customer1@provider.com|first1|last1|uaa.user,profile,email,catalog.read,inventory.read,order.use <i class="conum" data-value="8"></i><b>(8)</b>
    - customer2|password|customer2@provider.com|first2|last2|uaa.user,profile,email,catalog.read,inventory.read,order.use
    - catalog_ops|password|catalog_ops@provider.com|catalog|ops|uaa.user,profile,email,catalog.read,catalog.write
    - inventory_ops|password|inventory_ops@provider.com|inventory|ops|uaa.user,profile,email,inventory.read,inventory.write
    - order_ops|password|order_ops@provider.com|order|ops|uaa.user,profile,email,order.use,order.operate
    - inventory_service|password|inventory_service@provider.com|inventory|service|uaa.user,profile,email,catalog.read
    - order_service|password|order_service@provider.com|order|service|uaa.user,profile,email,catalog.read,inventory.read,inventory.write

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>本例中的網關扮演着 OAuth2 客戶的⻆色。所有的客戶都需在授權服務器中注冊。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>客戶名即標識和 secret 被用於認證客戶的身份，其一定要與客戶側的一致。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注冊網關僅使用 Authorization Code 類型的授權補助。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>羅列作為客戶的網關所可能申請的所有 Scope。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>注冊作為客戶的網關的重定嚮URI。授權服務器會比對注冊的重定URI和請求授權碼時的重定嚮URI，若不匹配則拒絕頒發授權碼。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>注冊另一個客戶。一個授權服務器可服務多個客戶。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>定義 Scope，格式為 <code>&lt;Scope 名穪&gt;:&lt;描述&gt;</code>。UAA 的 Scope 對應為 Spring Security 的職權「Authority」。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>注冊用戶，格式為 <code>用戶名|密碼|電郵地址|名|姓|scope 列表（以逗號分隔）</code>。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="網關"><a class="link" href="#網關">網關</a></h4>
<div class="paragraph">
<p>網關要校驗所有請求，若請求未認證則引導至 UAA 做認證與授權，若請求已認證則將訪問令牌一同轉發給後端服務。</p>
</div>
<div class="paragraph">
<p>首先，在 Gradle 構建文件中引入依賴。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...

dependencies {
	implementation 'org.springframework.cloud:spring-cloud-starter-gateway'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.cloud:spring-cloud-starter-oauth2' <i class="conum" data-value="1"></i><b>(1)</b>
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client' <i class="conum" data-value="2"></i><b>(2)</b>
	testImplementation('org.springframework.boot:spring-boot-starter-test') {
		exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
	}
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}

...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring-cloud-starter-oauth2</code> 引入了依賴 <code>org.springframework.cloud:spring-cloud-security</code> 和 <code>org.springframework.security.oauth.boot:spring-security-oauth2-autoconfigure</code>。<code>spring-cloud-security</code> 提供一些用於集成 OAuth 與 Spring Cloud 組件如 Spring Cloud Gateway，Spring Cloud OpenFeign 的類。<code>spring-security-oauth2-autoconfigure</code> 顧名思義，其提供了 OAuth2 相關的自動配置。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>spring-boot-starter-oauth2-client</code> 引入了 <code>org.springframework.security:spring-security-oauth2-client</code> 和 <code>org.springframework.security:spring-security-oauth2-jose</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，通過 Java Config 類 <code>SecurityConfig</code> 配置 <code>SecurityWebFilterChain</code>。</p>
</div>
<div class="listingblock">
<div class="title">SecurityConfig.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package io.github.rscai.microservices.gateway;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.oauth2.client.registration.ReactiveClientRegistrationRepository;
import org.springframework.security.web.server.SecurityWebFilterChain;

@Configuration <i class="conum" data-value="1"></i><b>(1)</b>
public class SecurityConfig {
  @Bean
  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http,
      ReactiveClientRegistrationRepository clientRegistrationRepository) { <i class="conum" data-value="2"></i><b>(2)</b>
    // Authenticate through configured OpenID Provider
    http.oauth2Login(); <i class="conum" data-value="3"></i><b>(3)</b>

    // Require authentication for all requests
    http.authorizeExchange().anyExchange().authenticated(); <i class="conum" data-value="4"></i><b>(4)</b>

    // Disable CSRF in the gateway to prevent conflicts with proxied service CSRF
    http.csrf().disable(); <i class="conum" data-value="5"></i><b>(5)</b>
    return http.build();
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@Configuration</code> 以聲明此類為 Spring 配置類，Spring 會依此組裝相應的 Bean；</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>聲明一個 <code>SecurityWebFilterChain</code> 類型的 Bean，Spring Security 會將其插入至 WebFlux 的過濾鏈中。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>指明使用 OAuth2 認證機制；</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>聲明所有的請求都需經過認證；</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>關閉 CSRF。跨站請求偽造（英語：Cross-site request forgery），也疲穪為 one-click attack 或者 session riding，通常縮寫為 CSRF 或者 XSRF，是一種挾制用戶在當前已登入的 Web 應用程式上執行非本意的操作的攻擊方法。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，通過 application YAML 配置 Spring Security。</p>
</div>
<div class="listingblock">
<div class="title">application-dev.yml</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="yaml" class="language-yaml hljs">...
  security:
    oauth2:
      client:
        registration:
          gateway: <i class="conum" data-value="1"></i><b>(1)</b>
            provider: uaa <i class="conum" data-value="2"></i><b>(2)</b>
            client-id: gateway <i class="conum" data-value="3"></i><b>(3)</b>
            client-secret: secret <i class="conum" data-value="4"></i><b>(4)</b>
            authorization-grant-type: authorization_code <i class="conum" data-value="5"></i><b>(5)</b>
            redirect-uri: "http://localhost:9101/login/oauth2/code/{registrationId}" <i class="conum" data-value="6"></i><b>(6)</b>
            scope: uaa.user,openid,profile,email,catalog.read,catalog.write,inventory.read,inventory.write,order.use,order.operate <i class="conum" data-value="7"></i><b>(7)</b>
        provider:
          uaa: <i class="conum" data-value="8"></i><b>(8)</b>
            authorization-uri: http://localhost:9103/uaa/oauth/authorize <i class="conum" data-value="9"></i><b>(9)</b>
            token-uri: http://localhost:9103/uaa/oauth/token <i class="conum" data-value="10"></i><b>(10)</b>
            user-info-uri: http://localhost:9103/uaa/userinfo <i class="conum" data-value="11"></i><b>(11)</b>
            user-name-attribute: sub
            jwk-set-uri: http://localhost:9103/uaa/token_keys <i class="conum" data-value="12"></i><b>(12)</b>
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>網關在 OAuth 協議中扮演着 client 的⻆色，所以要定義 client 相關的屬性；</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>provider</code> 指 authorization server，本例中使用 UAA 實現 authorization server，其具體信息將在獨立章節中定義；</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>client 的標識，需與 UAA 中的配置匹配；</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>client 的密鑰，用作 client 的身分凭證，需與 UAA 中的配置匹配；</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>OAuth2 定義了四種獲取訪問令牌的方式：Authorization Code, Implicit, Resource Owner Password Credentials 及 Client Credentials。本例使用 <code>Authorization Code</code> 型的 <code>Authorization Grant</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>當資源所有者在 UAA 完成了認證與授權之後，UAA 將會把授權碼傳送到這個URI。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Gateway 作為客戶所可能申請的所有 Scope，Scope 對應 Spring Security 中的 Authority。比如，Scope catalog.read 對應 Spring Security 中的 Authority <code>SCOPE_catalog.read</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>接着描述授權服務器 <code>uaa</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>當網關發現訪問受保護資源的請求未授權時，則會重定嚮用戶代理（一般是瀏覧器）至 <code>authorization-uri</code>，以認證資源所有者凭證並要求授權。</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>當作為客戶的網關得到授權碼之後，則會訪問 <code>token-uri</code> 從授權服務器獲取訪問令牌。</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>作為客戶的網關得到訪問令牌之後，可以訪問 <code>user-info-uri</code> 從授權服務器獲取資源所有者的其它信息。</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>當作為用戶的網關得到訪問令牌後，應使用相應的公鑰校驗令牌簽名以確定其是合法的。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="資源服務器"><a class="link" href="#資源服務器">資源服務器</a></h4>
<div class="paragraph">
<p>資源服務器需要校驗訪問令牌，再檢驗訪問令牌是否包含具體資源的授權。</p>
</div>
<div class="paragraph">
<p>以 Catalog 服務為例，首先引入依賴。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
	asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor'
	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-rest'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.boot:spring-boot-starter-security' <i class="conum" data-value="1"></i><b>(1)</b>
	implementation 'org.springframework.security:spring-security-oauth2-resource-server' <i class="conum" data-value="2"></i><b>(2)</b>
	implementation 'org.springframework.security:spring-security-oauth2-jose' <i class="conum" data-value="3"></i><b>(3)</b>
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
	testImplementation 'org.springframework.security:spring-security-test' <i class="conum" data-value="4"></i><b>(4)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring-boot-starter-security</code> 引入了 <code>org.springframework.security:spring-security-web</code>、<code>org.springframework.security:spring-security-core</code> 和 <code>org.springframework.security:spring-security-config</code>，其包含了 Spring Security 基礎的類及跟 Web 應用集成所需的工具類。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>spring-security-oauth2-resource-server</code> 提供了資源服務器所需的實現。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>spring-security-oauth2-jose</code> 提供了對 JWT 令牌的支持。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>spring-security-test</code> 提供測試工具，比如模拟認證用戶等。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，以 Java Config 形式配置 Spring Security。</p>
</div>
<div class="listingblock">
<div class="title">SecurityConfig.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Profile("!test") <i class="conum" data-value="1"></i><b>(1)</b>
@EnableWebSecurity <i class="conum" data-value="2"></i><b>(2)</b>
@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true) <i class="conum" data-value="3"></i><b>(3)</b>
public class SecurityConfig extends WebSecurityConfigurerAdapter { <i class="conum" data-value="4"></i><b>(4)</b>

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable() <i class="conum" data-value="5"></i><b>(5)</b>
        .authorizeRequests() <i class="conum" data-value="6"></i><b>(6)</b>
        .anyRequest().authenticated() <i class="conum" data-value="7"></i><b>(7)</b>
        .and()
        .oauth2ResourceServer() <i class="conum" data-value="8"></i><b>(8)</b>
        .jwt(); <i class="conum" data-value="9"></i><b>(9)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>利用 Spring Boot 的 Profile 特性，在測試場景中不啟用安全配置但在其它場景中啟用。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@EnableWebSecurity</code> 啟用安全機制。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@EnableGlobalMethodSecurity</code> 啟用方法層級的安全機制，本服務採用 Spring Data REST 構建 RESTFul 服務，所以在 Repository 方法聲明訪問控制是最合理的。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>繼承 <code>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter</code> 並覆寫方法 <code>configure(HttpSecurity http)</code> 以配置安全措施。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>關閉 CSRF。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>安全措施作用於所有請求。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>所有請求首先必需是認證過的。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>本服務採用 OAuth2 協議且扮演資源服務器的⻆色。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>採用 JWT 類型的令牌。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，在 Repository 的方法上聲明所需的權限。</p>
</div>
<div class="listingblock">
<div class="title">ProductRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@PreAuthorize("hasAuthority('SCOPE_catalog.read')") <i class="conum" data-value="1"></i><b>(1)</b>
@RepositoryRestResource(collectionResourceRel = "products", path = "products")
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {

  String AUTHORITY_CATALOG_WRITE = "hasAuthority('SCOPE_catalog.write')";

  @PreAuthorize(AUTHORITY_CATALOG_WRITE) <i class="conum" data-value="2"></i><b>(2)</b>
  @Override
  &lt;S extends Product&gt; S save(S entity);

  @PreAuthorize(AUTHORITY_CATALOG_WRITE)
  @Override
  &lt;S extends Product&gt; List&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);

  @PreAuthorize(AUTHORITY_CATALOG_WRITE)
  @Override
  void delete(Product entity);

  @PreAuthorize(AUTHORITY_CATALOG_WRITE)
  @Override
  void deleteAll();

  @PreAuthorize(AUTHORITY_CATALOG_WRITE)
  @Override
  void deleteAll(Iterable&lt;? extends Product&gt; entities);

  @PreAuthorize(AUTHORITY_CATALOG_WRITE)
  @Override
  void deleteById(String s);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@PreAuthorize</code> 以 Spring-EL 聲明必需的權限。<code>@PreAuthorize</code> 可以作用於方法也可作用於整個類。當作用於整個類時，等同於作用於該類所有的方法。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@PreAuthorize</code> 作用於方法，是在類級的 <code>@PreAuthorize</code> 的基礎上再附加權限要求。比如，要調用方法`save(S entity)<code>，請求者必須滿足 `hasAuthority('SCOPE_catalog.read')</code> 和 <code>hasAuthority('SCOPE_catalog.write')</code>。</td>
</tr>
</table>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring 表逹式語言（縮寫為"SpEL"）是一種強大的，支持運行時查詢和編輯對象圖的表逹式語言。該語言的語法與 Unified EL 相似但其提供了更多的特性，特殊方法調用和基本的字符串模板化功能。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring Expression language (SpEl)<br>
<cite>https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions</cite>
</div>
</div>
<div class="paragraph">
<p>Spring Security 內建一些表逹式，以方便應用開發者檢驗以 <code>Authentication</code> 對象形式展現的認證與授權信息。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Common Built-In Expressions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表逹式</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasRole(String role)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人拥有該⻆色則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasAnyRole(String&#8230;&#8203; roles)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人拥有任一⻆色則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasAuthority(String authority)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人拥有該職權則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasAnyAuthority(String&#8230;&#8203; authorities)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人拥有任一⻆色則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">principal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">直接訪問當前本人對象。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">authentication</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">直接訪問當前 <code>authentication</code> 對象。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">permitAll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">永遠為 <code>true</code> 即允許所有請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">denyAll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">永遠為 <code>false</code> 即拒絕所有請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">isAnonymous()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人是匿名用戶則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">isRememberMe()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人是 remember-me 用戶則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">isAuthenticated()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若當前本人為非匿名用戶則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">isFullyAuthenticated()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若前前本人非匿名且非 remember-me 則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasPermission(Object target, Object permission)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若該用戶拥有某對象的某許可則返回 <code>true</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hasPermission(Object targetId, String targetType, Object permission)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">若該用戶拥有某對象的某許可則返回 <code>true</code>，對象以對象類與標識的形式指定。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="測試-2"><a class="link" href="#測試-2">測試</a></h3>
<div class="sect3">
<h4 id="api-測試"><a class="link" href="#api-測試">API 測試</a></h4>
<div class="paragraph">
<p>包括安全的 API 測試跟普通的 API 測試相似，僅增加了認證用戶的模擬。</p>
</div>
<div class="paragraph">
<p>以 Product 的 API 為例，</p>
</div>
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ActiveProfiles("test") <i class="conum" data-value="1"></i><b>(1)</b>
@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class)
@SpringBootTest(classes = CatalogApplication.class)
@AutoConfigureMockMvc(addFilters = false) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureRestDocs
public class ProductTest {

  private static final String ENDPOINT = "/products";
  private static final String SCOPE_CATALOG_READ = "SCOPE_catalog.read";
  private static final String SCOPE_CATALOG_WRITE = "SCOPE_catalog.write";

  @Autowired
  private MockMvc mvc;
  @Autowired
  private ObjectMapper objectMapper;
  @Autowired
  private ProductImageRepository imageRepository;
  @Autowired
  private ProductRepository productRepository;

  ...

    @Test
  @WithMockUser(username = "catalog_ops", authorities = {SCOPE_CATALOG_READ, SCOPE_CATALOG_WRITE}) <i class="conum" data-value="3"></i><b>(3)</b>
  public void testCreateAndGet() throws Exception {
    final String imageALink = obtainLinkOfImage(imageAId);
    final String imageBLink = obtainLinkOfImage(imageBId);

    final String title = "New Product";
    final String ELECTRONICS = "Electronics";
    final String MOBILE = "Mobile";

    String createResponse = mvc.perform(
        post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
            .content(String.format(
                "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
                title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
        .andDo(print())
        .andExpect(status().isCreated())
        .andExpect(jsonPath("$.title", is(title)))
        .andExpect(jsonPath("$.createdAt", notNullValue()))
        .andExpect(jsonPath("$.updatedAt", notNullValue()))
        .andExpect(jsonPath("$._links.images", notNullValue()))
        .andDo(document("product/create", links(), requestFields(
            fieldWithPath("images").type(JsonFieldType.ARRAY)
                .description("links of referred ProductImage")), responseFields()))
        .andReturn().getResponse().getContentAsString();

    String productId = Stream
        .of(objectMapper.readTree(createResponse).at("/_links/self/href").asText().split("/"))
        .reduce((first, second) -&gt; second).orElse(null);

    mvc.perform(get(ENDPOINT + "/{id}", productId).accept(MediaType.APPLICATION_JSON))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.title", is(title)))
        .andExpect(jsonPath("$.createdAt", notNullValue()))
        .andExpect(jsonPath("$.updatedAt", notNullValue()))
        .andExpect(jsonPath("$._links.images", notNullValue()))
        .andDo(document("product/getOne", links(),
            pathParameters(parameterWithName("id").description("catalog's id")), responseFields()));

    mvc.perform(get(ENDPOINT + "/{id}/images", productId).accept(MediaType.APPLICATION_JSON))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$._embedded.productImages", hasSize(2)))
        .andDo(document("product/getImages",
            pathParameters(parameterWithName("id").description("catalog's id"))));
  }

  ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>顯式激活 profile test。還記我們聲明安全配置 <code>SecurityConfg</code> 祗在非 test profile 時才激活麼？安全配置 <code>SecurityConfig</code> 顯示指名採用 OAuth2 協議，但模擬兼容 OAuth2 的授權服務器太困難了，所以我們選擇在測試中不集成 OAuth2，而是模擬認證用戶即 <code>Authentication</code> 對象。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>addFilters = false</code> 是在測試中停用安全配置的必要步驟。Spring Security 是以嚮過濾器鏈中插入自己的過濾器的方式與 Spring MVC 應用集成的，且一但相關的類出現在 classpath 中就會觸發 Spring Security 自動配置。所以，必需要在測試中排除過濾器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@WithMockUser</code> 在測試方法範圍內模擬認證用戶即 <code>Authentication</code> 對象。通過 <code>@WithMockUser</code> 可以模擬用戶名、⻆色、職權和口令。
<div class="imageblock">
<div class="content">
<img src="images/WithMockUser.png" alt="WithMockUser" width="267" height="134">
</div>
<div class="title">Figure 20. WithMockUser.java</div>
</div></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="系統集成測試"><a class="link" href="#系統集成測試">系統集成測試</a></h4>
<div class="paragraph">
<p>將 UAA、Catalog 服務、Eureka 和網關全都運行在同一個環境，執行端到端的測試。</p>
</div>
<div class="paragraph">
<p>首先，創建並啟動 UAA Docker 容器；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker run -p 9103:8090 --name=uaa uaa</code></pre>
</div>
</div>
<div class="paragraph">
<p>或啟動已創建的 UAA Docker 容器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker start uaa</code></pre>
</div>
</div>
<div class="paragraph">
<p>然後，啟動 Eureka；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">cd microservices-eureka
./gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>再然後，創建並啟動 MongoDB Docker 容器；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker run -d --name catalog-mongo -p 27018:27017 -v &lt;LOCAL PATH&gt;/catalog-mongo-data:/data/db -e MONGO_INITDB_ROOT_USERNAME=mongoadmin -e MONGO_INITDB_ROOT_PASSWORD=secret mongo:3.4</code></pre>
</div>
</div>
<div class="paragraph">
<p>或啟動已創建的 MongoDB Docker 容器；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">docker start catalog-mongo</code></pre>
</div>
</div>
<div class="paragraph">
<p>再然後，啟動 Catalog 服務；</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="shell" class="language-shell hljs">cd microservices-cata
./gradlew bootRun -Dspring.profiles.active=dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>最後，打開瀏覧器訪問 <code><a href="http://localhost:9101/catalog/products" class="bare">http://localhost:9101/catalog/products</a></code>。其會重定嚮至 UAA，輸入用戶名密碼並確認授權。最終應能得到 HAL 格式的响應。</p>
</div>
<div class="paragraph">
<p>觀察 HTTP 報文可以發現，</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-30d924f9955f37a814c4b4b894e460bc.png" alt="diag 30d924f9955f37a814c4b4b894e460bc" width="1354" height="1081">
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>瀏覧器嚮網關發送 GET /catalog/products 請求；</p>
</li>
<li>
<p>網關發覺當前會話未認證，所以重定嚮瀏覧器至自身的認證URI；</p>
</li>
<li>
<p>瀏覧器訪問網關的認證URI；</p>
</li>
<li>
<p>網關根據自身配置，將瀏覧器重定嚮至 UAA 進行認證；</p>
</li>
<li>
<p>瀏覧器訪問 UAA 的認證 URI；</p>
</li>
<li>
<p>UAA 根據授權補助類型 Authorization Code，重定嚮瀏覧器至用戶登入頁面，引導用戶以用戶名密碼認證；</p>
</li>
<li>
<p>瀏覧器訪問用戶登入頁面；</p>
</li>
<li>
<p>瀏覧器將用戶提供的用戶名密碼發送給 UAA；</p>
</li>
<li>
<p>UAA 認證用戶名密碼通過以後，重定嚮瀏覧器至授權確認頁面；</p>
</li>
<li>
<p>瀏覧器訪問授權確認頁面；</p>
</li>
<li>
<p>瀏覧器將用戶的授權確定發送給 UAA；</p>
</li>
<li>
<p>UAA 以重定嚮回網關的形式將授權碼返回；</p>
</li>
<li>
<p>瀏覧器以包含授權碼的URI訪問網關認URI；</p>
</li>
<li>
<p>網關得到授權碼後，嚮 UAA 申請訪問令牌；</p>
</li>
<li>
<p>UAA 返回訪問令牌、刷新令牌及其它信息；</p>
</li>
<li>
<p>網關嚮 UAA 請求公鑰以校驗今牌的簽名；</p>
</li>
<li>
<p>UAA 返回校驗令牌簽名用的公鑰；</p>
</li>
<li>
<p>網關嚮 UAA 請求用戶信息；</p>
</li>
<li>
<p>UAA 返回用戶名、電郵地址等用戶信息；</p>
</li>
<li>
<p>網關將令牌存於當前會話中，返回瀏覧器會話標識，並重定嚮瀏覧器至最初的URL；</p>
</li>
<li>
<p>瀏覧器訪問最初的URL，並在Cookie中提供會話標識；</p>
</li>
<li>
<p>網關從服務注冊處發現 Catalog 服務實例，將請求轉發給其，並將從會話中恢复的訪問令牌以 <code>Authorization</code> 頭的形式附上；</p>
</li>
<li>
<p>Catalog 服務從 UAA 處請求公鑰以校驗訪問令牌的簽名；</p>
</li>
<li>
<p>UAA 返回公鑰給 Catalog 服務；</p>
</li>
<li>
<p>Catalog 服務校驗過訪問令牌及其包含的職權後，返回受保護的資源給網關；</p>
</li>
<li>
<p>網關把 Catalog 服務的响應轉發給瀏覧器。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="參考-6"><a class="link" href="#參考-6">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/身份认证">身份認證</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/开放授权">開放授權</a></p>
</li>
<li>
<p><a href="https://oauth.net/2">OAuth 2.0</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></p>
</li>
<li>
<p><a href="https://spring.io/guides/topicals/spring-security-architecture">Spring Security Architecture</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access">Expression-Based Access Control</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="inventory"><a class="link" href="#inventory">Inventory</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="目標-5"><a class="link" href="#目標-5">目標</a></h3>
<div class="paragraph">
<p>本章中，我們將基於 Spring Boot 開發提供 RESTful API 的 Inventory 微服務。我們將學習：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 Spring Data/Spring Data JPA 訪問關係式數據庫（本例中使用 MySQL）</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="設計-3"><a class="link" href="#設計-3">設計</a></h3>
<div class="sect3">
<h4 id="用例-3"><a class="link" href="#用例-3">用例</a></h4>
<div class="paragraph">
<p>作為一個倉儲運營，其可以：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新建倉儲項，每個倉儲項包含商品標識、單價、數量等屬性；</p>
</li>
<li>
<p>入庫，增加倉儲項的數量；</p>
</li>
<li>
<p>出庫，減少倉儲項的數量。</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-1a4eb8fa2d4d66be6d8803c5e43f9ad5.png" alt="diag 1a4eb8fa2d4d66be6d8803c5e43f9ad5" width="198" height="240">
</div>
<div class="title">Figure 21. 用例</div>
</div>
</div>
<div class="sect3">
<h4 id="業務模型"><a class="link" href="#業務模型">業務模型</a></h4>
<div class="paragraph">
<p>倉儲業務主要涉及到兩個業務模型：倉儲項「InventoryItem」和倉儲項數量變更「InventoryItemQuantityChange」。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">InventoryItem</dt>
<dd>
<p>記錄了倉儲項的所有屬性，包括商品標識、單價、數量等。</p>
</dd>
<dt class="hdlist1">InventoryItemQuantityChange</dt>
<dd>
<p>倉儲項的數量變更是比較頻繁，多來源且要求可追遡可撤消。所以，將倉儲項數量變更設計成獨立的業務模型。</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="images/inventory%20entity.png" alt="inventory entity" width="413" height="148">
</div>
<div class="title">Figure 22. 實體模型</div>
</div>
</div>
<div class="sect3">
<h4 id="架構-3"><a class="link" href="#架構-3">架構</a></h4>
<div class="imageblock">
<div class="content">
<img src="images/inventory-architecture.png" alt="inventory architecture" width="239" height="286">
</div>
<div class="title">Figure 23. 架構</div>
</div>
<div class="paragraph">
<p>整體採用網關模式。所有外部請求都被發送至網關，網關從發現倉儲服務實例，並將請求轉發給倉儲服務實例。倉儲服務實例在啟動階段將自身注冊於 Eureka。</p>
</div>
<div class="paragraph">
<p>倉儲服務自身採用經典的分層架構。由外至內分別為：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Controller 層，負責RESTful 請求/嚮應與對象模型之間的映射。.</p>
</li>
<li>
<p>Service 層，包含業務邏輯。因其業務邏輯比較簡單，所以可以省略此層。</p>
</li>
<li>
<p>Repository 層，負責數據查詢與持久化。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/inventory-layer.png" alt="inventory layer" width="261" height="344">
</div>
<div class="title">Figure 24. 分層架構</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa"><a class="link" href="#jpa">JPA</a></h4>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Java 持久化 API（JPA）是一個 Java 應用程式接口規範，描述了使用 Java 標準版平台（Java SE）和 Java 企業平台（Java EE）的應用中的關係數據的管理。</p>
</div>
<div class="paragraph">
<p>持久化，在這𥚃包括三個層面的意思：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>API 本身，定義在 <code>javax.persistence</code> 包內</p>
</li>
<li>
<p>Java 持久化查詢語言（JPQL）</p>
</li>
<li>
<p>對象/關係元數據</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; Java 持久化 API<br>
<cite>https://zh.wikipedia.org/wiki/Java持久化API</cite>
</div>
</div>
<div class="paragraph">
<p>在倉庫模式「Repository Pattern」中，業務邏輯代碼與倉庫「Repository」介面交互存取業務實體。Repository 通過特定的 Data Mapper 實現業務實體與具體 Data Source 之間的映射。JPA就是一種針對關係式數據庫 Data Source 的 Data Mapper。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-ede71629acf71a887e659167eb46af34.png" alt="diag ede71629acf71a887e659167eb46af34" width="666" height="146">
</div>
<div class="title">Figure 25. Repository Pattern</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>關係數據庫（英語：Relational database），是創建在關係模型基礎上的數據庫，借助於集合代數等數學概念和方法來處理數據庫中的數據。現實世界中的各種實體以及實體之間的各種聯系均用關係模型來表示。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 關係數據庫<br>
<cite>https://zh.wikipedia.org/zh-cn/关系數據庫</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>用於數據庫管理的關係模型（英語：Relational model）是基於謂詞邏輯和集合論的一種數據模型，廣泛被使用於數據庫之中。最旲於1970年由埃德加·科德提出。</p>
</div>
<div class="paragraph">
<p>關係模型的基本假定是所有數據都表示為數學上的關係，就是說 n 個集合的笛卡爾積的一個子集，有關這種數據的推理通過二值（就是說沒有 NULL）的謂詞邏輯來進行，這意味着對每個命題都有兩種可能的賦值：要麼是真要麼是假。數據通過關係演算和關係代數的一種方式來操作。關係模型是採用二維表格結構表逹實體類型及實體間聯係的數據模型。</p>
</div>
<div class="paragraph">
<p>關係模型允許設計者通過數據庫規範化的提煉，去建立一個信息的一致性的模型。訪問計劃和其他實現與操作細節由 DBMS 引擎來處理，而不應該反映在邏輯模型中。這與 SQL DBMS 普遍的實踐是對立的，在它們那𥚃性能調整經常需要改變邏輯模型。</p>
</div>
<div class="paragraph">
<p>基本的關係建造塊是域或者叫數據類型。元組是屬性的有序多重集（multiset），屬性是域和值的有序對。關係變量（relvar）是域和名字的有序對（序偶）的集合，它充當關係的表頭（header）。關係是元組的集合。儘管這些關係概念是數學上的定義，但它們可以寬鬆地映射到傳統數據庫概念上。表是關係公認的可視表示；元組類似於行的概念。</p>
</div>
<div class="paragraph">
<p>關係模型的基本原理是信息原理：所有信息都表示為關係中的資料值。所以，關係變量在設計時刻是相互無關係的；反而，設計者在多個關係變量中使用相同的域，如果一個屬性依賴另一個屬性，則通過參照完整性來強制這種依賴性。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; 關係模型<br>
<cite>https://zh.wikipedia.org/zh-cn/關係模型</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>關係模型中常用的操作包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>數據查詢</p>
</li>
<li>
<p>選擇</p>
</li>
<li>
<p>投影</p>
</li>
<li>
<p>連接</p>
</li>
<li>
<p>併</p>
</li>
<li>
<p>交</p>
</li>
<li>
<p>差</p>
</li>
<li>
<p>除</p>
</li>
<li>
<p>數據操作</p>
</li>
<li>
<p>插入</p>
</li>
<li>
<p>刪除</p>
</li>
<li>
<p>修改</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>完整性約束包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>實體完整性</p>
</li>
<li>
<p>參照完整性</p>
</li>
<li>
<p>用戶定義完整性</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; 關係數據庫<br>
<cite>https://zh.wikipedia.org/zh-cn/关系數據庫</cite>
</div>
</div>
<div class="paragraph">
<p>關係式數據庫中數據構件有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表（table）</p>
</li>
<li>
<p>行（row）</p>
</li>
<li>
<p>列（column）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>對象（Object Oriented）模型中基本構件有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>類（class）</p>
</li>
<li>
<p>對象（object）</p>
</li>
<li>
<p>屬性（property）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>JPA 提供了一組方法，使應用開發者可以聲明對象模型與關係式模型之間的映射。類映射為表，對象映射為行，屬性映射為列。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="實現-5"><a class="link" href="#實現-5">實現</a></h3>
<div class="paragraph">
<p>使用 Spring Initializr 生成項目骨架，並導入 IntelliJ IDEA.</p>
</div>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="sect3">
<h4 id="構建-2"><a class="link" href="#構建-2">構建</a></h4>
<div class="paragraph">
<p>首先，引入構建插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre>plugins {
    id 'org.springframework.boot' version '2.2.2.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
    id 'io.spring.dependency-management' version '1.0.8.RELEASE' <i class="conum" data-value="2"></i><b>(2)</b>
	id 'java'
    id "io.freefair.lombok" version "4.1.6"
    id "org.sonarqube" version "2.7.1"
    id 'jacoco'
    id 'org.asciidoctor.convert' version '1.5.3'
}

...</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入 Spring Boot 插件，其版本決定了引入的 Spring Boot 庫的版本。所以有了 Spring Boot 插件，就無需顯示指定各個 Spring Boot 庫的版本了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入 Spring 依賴管理插件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，引入依賴。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre>...

ext {
    snippetsDir = file('build/generated-snippets')
    set('springCloudVersion', "Hoxton.SR1") <i class="conum" data-value="1"></i><b>(1)</b>
}

dependencies {
    asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor'
    implementation 'org.springframework.boot:spring-boot-starter-web' <i class="conum" data-value="2"></i><b>(2)</b>
    implementation 'org.springframework.boot:spring-boot-starter-hateoas' <i class="conum" data-value="3"></i><b>(3)</b>
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa' <i class="conum" data-value="4"></i><b>(4)</b>
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client' <i class="conum" data-value="5"></i><b>(5)</b>
    implementation 'org.springframework.boot:spring-boot-starter-security' <i class="conum" data-value="6"></i><b>(6)</b>
    implementation 'org.springframework.security:spring-security-oauth2-resource-server' <i class="conum" data-value="7"></i><b>(7)</b>
    implementation 'org.springframework.security:spring-security-oauth2-jose' <i class="conum" data-value="8"></i><b>(8)</b>
    runtimeOnly 'mysql:mysql-connector-java' <i class="conum" data-value="9"></i><b>(9)</b>
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
    testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
    testImplementation 'org.junit.jupiter:junit-jupiter-api'
    testImplementation 'com.h2database:h2'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
}

dependencyManagement {
    imports {
        mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="10"></i><b>(10)</b>
    }
}

...</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>將 Spring Cloud 版本定義為變量，便於引用及統一管理。Spring Cloud 與 Spring Boot 之間的版本兼容性發佈在 <a href="https://spring.io/projects/spring-cloud#overview" class="bare">https://spring.io/projects/spring-cloud#overview</a>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Release train Spring Boot compatibility</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Release Train</th>
<th class="tableblock halign-left valign-top">Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hoxton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greenwich</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finchley</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edgware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dalston</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>spring-boot-starter-web</code> 引入了 Spring MVC 相關的庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>spring-boot-starter-hateoas</code> 引入了 HATEOAS 相關庫，用以實現 Level 3 RESTFul 服務。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>spring-boot-start-data-jpa</code> 引入了 Spring Data JPA 相關的庫，用以實現以 JPA 訪問關係式數據庫的倉庫「Repository」。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>spring-cloud-starter-betflix-eureka-client</code> 引入了 Eureka 客戶端庫，用以實現將本服務注冊至 Eureka，以便網關及其它服務發現。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>spring-boot-starter-security</code> 引入 Spring Security 相關的庫，用以實現請求安全控制。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>spring-security-oauth2-resource-server</code> 提供 OAuth2 資源服務器的實現，以便將本服務以資源服務器的⻆色集成進 OAuth2 機制中。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>spring-security-oauth2-jose</code> 提供了對 JWT 令牌的支持。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>本服務使用 MySQL 作為數據庫實現，所以需在運行時提供 MySQL 驅動。</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>通過引入 <code>org.springframework.cloud:spring-cloud-dependencies</code> BOM 來管理 Spring Cloud 庫的版本。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="業務模型-2"><a class="link" href="#業務模型-2">業務模型</a></h4>
<div class="paragraph">
<p>借助於 Lombok，可以在編器期生成樣板代碼，如訪問器、構造器等，從而使代碼更簡潔易讀。使用 JPA 和 Hibernate 定義的注解，可以以聲明式的方式描述業務模型與關係式模型之間的映射。</p>
</div>
<div class="paragraph">
<p>常用的用以描述模型映射的 JPA 注解有：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. 常用 JPA 注解</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 55.5555%;">
<col style="width: 22.2223%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">參數</th>
<th class="tableblock halign-left valign-top">作用域</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Entity</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="dlist">
<dl>
<dt class="hdlist1">name</dt>
<dd>
<p>實體名穪，默認為類名。</p>
</dd>
</dl>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Table</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="dlist">
<dl>
<dt class="hdlist1">name</dt>
<dd>
<p>表名，默認為類名。</p>
</dd>
<dt class="hdlist1">catalog</dt>
<dd>
<p>類目。</p>
</dd>
<dt class="hdlist1">schema</dt>
<dd>
<p>對應數據庫中的 schema。</p>
</dd>
<dt class="hdlist1">uniqueConstraints</dt>
<dd>
<p>唯一約束，一般用以定義多列聯合唯一約束。</p>
</dd>
<dt class="hdlist1">indexes</dt>
<dd>
<p>表上的索引。</p>
</dd>
</dl>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Column</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="dlist">
<dl>
<dt class="hdlist1">name</dt>
<dd>
<p>列名，默認為列名或屬性名。</p>
</dd>
<dt class="hdlist1">unique</dt>
<dd>
<p><code>@UniqueConstraint</code> 的快捷方法，用以定義列值是否唯一，默認值為否。</p>
</dd>
<dt class="hdlist1">nullable</dt>
<dd>
<p>列是否可空，默認值為是。</p>
</dd>
<dt class="hdlist1">insertable</dt>
<dd>
<p>該列是否可通過 INSERT SQL 語句賦值，默認值為是。</p>
</dd>
<dt class="hdlist1">updatable</dt>
<dd>
<p>該列是否可通過 UPDATE SQL 語句賦值，默認值為是。</p>
</dd>
<dt class="hdlist1">columnDefinition</dt>
<dd>
<p>創建列的 DDL 語句，默認是通過其它參數生成。</p>
</dd>
<dt class="hdlist1">table</dt>
<dd>
<p>表名，默認是定義在類級的主表名。</p>
</dd>
<dt class="hdlist1">length</dt>
<dd>
<p>列長度，默認值為255。</p>
</dd>
<dt class="hdlist1">precision</dt>
<dd>
<p>有效位數，默認值為0。</p>
</dd>
<dt class="hdlist1">scale</dt>
<dd>
<p>小數位數，默認值為0。</p>
</dd>
</dl>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段、訪問器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Id</p></td>
<td class="tableblock halign-left valign-top"><div class="content"></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段、訪問器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@GeneratedValue</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="dlist">
<dl>
<dt class="hdlist1">strategy</dt>
<dd>
<p>主鍵生成策略，可選值有 <code>TABLE, SEQUENCE, IDENTITY, AUTO</code>，默認值為 <code>AUTO</code>。</p>
</dd>
<dt class="hdlist1">generator</dt>
<dd>
<p>主鍵生成器的名穪，默認主鍵生成器由持久化提供者提供。</p>
</dd>
</dl>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段、訪問器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Temporal</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="dlist">
<dl>
<dt class="hdlist1">value</dt>
<dd>
<p><code>java.util.Date</code> 或 <code>java.util.Calendar</code> 要映射的類型，有三個可選項 <code>DATE, TIME, TIMESTAMP</code>。</p>
</dd>
</dl>
</div></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段、訪問器</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>JPA 本身僅是一個 API 規範，Spring Data JPA 採用 Hibernate 作為其 JPA 實現。</p>
</div>
<div class="sect4">
<h5 id="inventoryitem"><a class="link" href="#inventoryitem">InventoryItem</a></h5>
<div class="listingblock">
<div class="title">InventoryItem.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Data
@Entity
@Relation(collectionRelation = "inventoryItems")
public class InventoryItem {

  @Id
  @GeneratedValue(generator = "system-uuid")
  @GenericGenerator(name = "system-uuid", strategy = "uuid")
  private String id;
  @Column(nullable = false, unique = true)
  private String productId;
  @Column(nullable = false)
  private int quantity;
  @Column(nullable = false, scale = 2)
  private BigDecimal unitPrice;
  @Column(nullable = false, updatable = false)
  @Temporal(TemporalType.TIMESTAMP)
  @CreationTimestamp
  private Date createdAt;
  @Column(nullable = false)
  @Temporal(TemporalType.TIMESTAMP)
  @UpdateTimestamp
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其使用 JPA 注解將實體 <code>InventoryItem</code> 映射至表 <code>inventory_item</code>，表名可以通過注解 <code>@Table</code> 顯示指定，默認是將駝峰形式轉換成以下劃線連接單詞的形式。字段也被一一映射至列。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">id</dt>
<dd>
<p><code>String</code> 類型的字段被映射為 <code>varchar</code> 類型的列，長度默認為255。列名及長度可通過注解 <code>@Column</code> 顯示指定；使用注解 <code>@Id</code> 將該字段聲明為主鍵；組合使用注解 <code>GeneratedValue</code> 和 <code>GenericGenerator</code> 聲明以 UUID 策略生成該字段的值。在數據庫實踐中，主鍵值一般都是自動生成的。</p>
</dd>
<dt class="hdlist1">product_id</dt>
<dd>
<p><code>String</code> 類型的字段被映射為 <code>varchar</code> 類型的列，列名默認是把字段名轉換成以下劃線連接單詞的形式。這𥚃顯示用注解 <code>@Column</code> 聲明該字段是不可為空且不可重復。</p>
</dd>
<dt class="hdlist1">quantity</dt>
<dd>
<p><code>int</code> 類型的字段被映射為 <code>int</code> 類型的列，長度默認為11。列名及長度都可通過注解 <code>@Column</code> 顯示聲明。</p>
</dd>
<dt class="hdlist1">unitPrice</dt>
<dd>
<p><code>BigDecimal</code> 類型的字段被映射為 <code>decimal</code> 的列，通過注解 <code>@Column</code> 聲明小數點後的精度為2。</p>
</dd>
<dt class="hdlist1">createdAt</dt>
<dd>
<p><code>Date</code> 類型的字段可被映射為多種類型的列，比如 <code>datetime</code>、<code>date</code> 和 <code>time</code>。這𥚃使用注解 <code>@Temporal</code> 顯示聲明其映射為 <code>datetime</code> 類型的列。同時使用注解 <code>@Column</code> 聲明其不可為空且不可更新。因為羅輯上講，實體的創建時間戳在創建時就確定不變的。</p>
</dd>
<dt class="hdlist1">updatedAt</dt>
<dd>
<p>使用注解 <code>@Temporal</code> 顯示聲明其映射為 <code>datatime</code> 類型的列。同時使用注解 <code>@Column</code> 聲明其不可為空。</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-f154e654dbaeb237858fe0b31294686a.png" alt="diag f154e654dbaeb237858fe0b31294686a" width="449" height="148">
</div>
</div>
</div>
<div class="sect4">
<h5 id="inventoryitemquantitychange"><a class="link" href="#inventoryitemquantitychange">InventoryItemQuantityChange</a></h5>
<div class="listingblock">
<div class="title">InventoryItemQuantityChange.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Data <i class="conum" data-value="1"></i><b>(1)</b>
@NoArgsConstructor <i class="conum" data-value="2"></i><b>(2)</b>
@AllArgsConstructor <i class="conum" data-value="3"></i><b>(3)</b>
@Entity
public class InventoryItemQuantityChange {

  @Id
  private String id;
  @Column(nullable = false)
  private String inventoryItemId;
  // could be positive or negative
  @Column(nullable = false)
  private int quantityChange;
  @Column(nullable = false, updatable = false)
  @CreationTimestamp
  @Temporal(TemporalType.TIMESTAMP)
  private Date createdAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@Data</code> 修飾類，Lombok 會在編譯器為所有字段生成訪問器。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@NoArgsConstructor</code> 修飾類，Lombok會在編譯期為其生成不含任何參數的構造器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@AllArgsConstructor</code> 修飾類，Lombok會在編譯期為其生成以所字段為參數的構造器。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其使用 JPA 注解將類 <code>InventoryItemQuantityChange</code> 映射至表 <code>inventory_item_quantity_change</code>。其字段也被一一映射為列。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">id</dt>
<dd>
<p><code>String</code> 類型的字段被映射為 <code>varchar</code> 類型的列，長度默認為255。列名及長度可以通過注解 <code>@Column</code> 顯示聲明。</p>
</dd>
<dt class="hdlist1">inventoryItemId</dt>
<dd>
<p><code>String</code> 類型的字段被映射為 <code>varchar</code> 類型的列，長度默認為255。其使用注解 <code>@Column</code> 顯示聲明該字段值不能為空。</p>
</dd>
<dt class="hdlist1">quantityChange</dt>
<dd>
<p><code>int</code> 類型的字段被映射為 <code>varchar</code> 類型的列，長度默認為11。其使用注解 <code>@Column</code> 顯示聲明該字段值不能為空。</p>
</dd>
<dt class="hdlist1">createdAt</dt>
<dd>
<p><code>Date</code> 類型的字段可被映射為多種類型的列，比如 <code>datetime</code>、<code>date</code> 和 <code>time</code>。這𥚃使用注解 <code>@Temporal</code> 顯示聲明其映射為 <code>datetime</code> 類型的列。同時使用注解 <code>@Column</code> 聲明其不可為空且不可更新。因為羅輯上講，實體的創建時間戳在創建時就確定不變的。</p>
</dd>
</dl>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-e1983321d1d252ca9b14ac7bd47df7b4.png" alt="diag e1983321d1d252ca9b14ac7bd47df7b4" width="500" height="123">
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repository"><a class="link" href="#repository">Repository</a></h4>
<div class="paragraph">
<p>Spring Data 的核心是 Repository，Spring Data JPA 在其基礎之擴展出了針對 JPA 應用埸景的 <code>JpaRepository</code>。<code>JpaRepository</code> 增加了如 <code>flush(), deleteInBatch()</code> 等 JPA 應用場景中比較常用的方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/JpaRepository-class.png" alt="JpaRepository class" width="377" height="306">
</div>
<div class="title">Figure 26. JpaRepository</div>
</div>
<div class="sect4">
<h5 id="inventoryitemrepository"><a class="link" href="#inventoryitemrepository">InventoryItemRepository</a></h5>
<div class="paragraph">
<p>業務模型 <code>InventoryItem</code> 專屬的倉庫接口擴展至 <code>JpaRepository</code>，增加了一個按商品標識批量分頁查詢倉儲項的方法。</p>
</div>
<div class="listingblock">
<div class="title">InventoryItemRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public interface InventoryItemRepository extends JpaRepository&lt;InventoryItem, String&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

  Page&lt;InventoryItem&gt; findByProductIdIn(List&lt;String&gt; productIds, Pageable pageable); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@Repository</code> 聲明此接口為倉庫，Spring Data 在構建上下文時將為其生成一個實現類並初始化 Bean。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>擴展接口 <code>@JpaRepository</code>，並聲明實體類型為 <code>InventoryItem</code>，唯一標識類型為 <code>String</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>增加按一組商品標識分頁查詢實體的方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="inventoryitemquantitychangerepository"><a class="link" href="#inventoryitemquantitychangerepository">InventoryItemQuantityChangeRepository</a></h5>
<div class="paragraph">
<p>業務模型 <code>InventoryItemQuantityChange</code> 專屬的倉庫接口擴展至 <code>JpaRepository</code>。</p>
</div>
<div class="listingblock">
<div class="title">InventoryItemQuantityChangeRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository <i class="conum" data-value="1"></i><b>(1)</b>
public interface InventoryItemQuantityChangeRepository extends
    JpaRepository&lt;InventoryItemQuantityChange, String&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@Repository</code> 聲明此接口為倉庫，Spring Data 在構建上下文時將為其生成一個實現類並初始化 Bean。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>擴展接口 <code>@JpaRepository</code>，並聲明實體類型為 <code>InventoryItemQuantityChange</code>，唯一標識類型為 <code>String</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="controller"><a class="link" href="#controller">Controller</a></h4>
<div class="paragraph">
<p>Controller 層負責 RESTFul 風格請求與處理方法之間的映射，HAL 格式的請求/响應體與 Java 對象之間的映射，及鍳權。</p>
</div>
<div class="sect4">
<h5 id="inventoryitemcontroller"><a class="link" href="#inventoryitemcontroller">InventoryItemController</a></h5>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. 請求/方法映射</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">請求方法</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">處理方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/inventoryItems</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/inventoryItems/{id}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>update</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/inventoryItems/{id}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/inventoryItems/{id}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>getOne</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/inventoryItems/search/productIdIn</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>searchByProductId</code></p></td>
</tr>
</tbody>
</table>
<div class="sect5">
<h6 id="create"><a class="link" href="#create">create</a></h6>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE, "application/hal+json"}) <i class="conum" data-value="1"></i><b>(1)</b>
  @ResponseStatus(HttpStatus.CREATED) <i class="conum" data-value="2"></i><b>(2)</b>
  @PreAuthorize(AUTHORITY_INVENTORY_WRITE)
  public EntityModel&lt;InventoryItem&gt; create(@RequestBody InventoryItem entity) { <i class="conum" data-value="3"></i><b>(3)</b>
    InventoryItem createdOne = repository.save(entity);
    return new EntityModel&lt;&gt;(createdOne, itemLinks(createdOne));
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@PostMapping</code> 將 POST 請求映射至此方法，並聲明祗接受請求體媒體類型為 <code>application/json</code> 或 <code>application/hal+json</code> 的 POST 請求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@ResponseStatus</code> 聲明在成功响應時响應碼為201 Created。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@RequestBody</code> 聲明將請求體解碼為 <code>InventoryItem</code> 類型對象並作為實參傳給該方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="update"><a class="link" href="#update">update</a></h6>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">  @PutMapping(value = "{id}", consumes = {MediaType.APPLICATION_JSON_VALUE, "application/hal+json"}) <i class="conum" data-value="1"></i><b>(1)</b>
  @ResponseStatus(HttpStatus.NO_CONTENT) <i class="conum" data-value="2"></i><b>(2)</b>
  @PreAuthorize(AUTHORITY_INVENTORY_WRITE)
  public void update(@PathVariable("id") String id,
      @RequestBody InventoryItem entity) { <i class="conum" data-value="3"></i><b>(3)</b>
    InventoryItem existedOne = repository.findById(id)
        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND));
    existedOne.setProductId(entity.getProductId());
    existedOne.setUnitPrice(entity.getUnitPrice());
    repository.save(existedOne);
  }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@PutMapping</code> 將 PUT 請求映射至此方法，並聲明祗接受請求體媒體類型為 <code>application/json</code> 或 <code>application/hal+json</code> 的 PUT 請求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@ResponseStatus</code> 聲明在成功响應時响應碼為204 No Content, 即响應體為空。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@PathVariable</code> 將從請求路徑中解析出的 <code>id</code> 以實參 <code>id</code> 的形式傳給該方法，並使用注解 <code>@RequestBody</code> 聲明將請求體解碼為 <code>InventoryItem</code> 類型對象並作為實參傳給該方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="delete"><a class="link" href="#delete">delete</a></h6>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @DeleteMapping("{id}") <i class="conum" data-value="1"></i><b>(1)</b>
  @ResponseStatus(HttpStatus.NO_CONTENT) <i class="conum" data-value="2"></i><b>(2)</b>
  @PreAuthorize(AUTHORITY_INVENTORY_WRITE)
  public void delete(@PathVariable("id") String id) { <i class="conum" data-value="3"></i><b>(3)</b>
    InventoryItem existedOne = repository.findById(id)
        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND));
    repository.delete(existedOne);
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@DeleteMapping</code> 將 PUT 請求映射至此方法，DELETE 請求不帶請求體，所以對無需約束其請求體媒體類型。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@ResponseStatus</code> 聲明在成功响應時响應碼為204 No Content, 即响應體為空。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>@PathVariable</code> 將從請求路徑中解析出的 <code>id</code> 以實參 <code>id</code> 的形式傳給該方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="getone"><a class="link" href="#getone">getOne</a></h6>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @GetMapping(value = "{id}", produces = "application/hal+json") <i class="conum" data-value="1"></i><b>(1)</b>
  public EntityModel&lt;InventoryItem&gt; getOne(@PathVariable("id") String id) { <i class="conum" data-value="2"></i><b>(2)</b>
    InventoryItem existedOne = repository.findById(id)
        .orElseThrow(() -&gt; new ResponseStatusException(HttpStatus.NOT_FOUND));
    return new EntityModel&lt;&gt;(existedOne, itemLinks(existedOne));
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@GetMapping</code> 將 GET /inventoryItems/{id} 的請求映射至此方法，並聲明其响應體媒體類型為 <code>application/hal+json</code>。 默認的成功返回狀態碼為200，符合需求，所以無需通過 <code>@ResponseStatus</code> 顯示聲明。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@PathVariable</code> 將從請求路徑中解析出的 <code>id</code> 以實參 <code>id</code> 的形式傳給該方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="searchbyproductid"><a class="link" href="#searchbyproductid">searchByProductId</a></h6>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @GetMapping(value = "search/productIdIn", produces = "application/hal+json") <i class="conum" data-value="1"></i><b>(1)</b>
  public PagedModel&lt;EntityModel&lt;InventoryItem&gt;&gt; searchByProductId(
      @RequestParam("productId") List&lt;String&gt; productIds, @NotNull Pageable pageable) { <i class="conum" data-value="2"></i><b>(2)</b>
    Page&lt;InventoryItem&gt; pagedItems = repository.findByProductIdIn(productIds, pageable);
    return pagedResourcesAssembler.toModel(pagedItems);
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>@GetMapping</code> 將 GET /inventoryItems/{id} 的請求映射至此方法，並聲明其响應體媒體類型為 <code>application/hal+json</code>。 默認的成功返回狀態碼為200，符合需求，所以無需通過 <code>@ResponseStatus</code> 顯示聲明。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>@RequestParam</code> 將請求中的名為 productId 的查詢參數全都解析出來並以實參 <code>productIds</code> 的形式傳給該方法，並從請求中解析出分頁及排序條件以實參 <code>pageable</code> 的形式傳給該方法。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="hal"><a class="link" href="#hal">HAL</a></h6>
<div class="paragraph">
<p><code>org.springframework.boot:spring-boot-starter-hateoas</code> 提供了豐富的工具幫助應用開發者將 Java 對象編碼為 HAL 文本及將 HAL 文本解碼為 Java 對象。</p>
</div>
<div class="paragraph">
<p>相較與普通的 Java 對象， HAL 其實祗是附加了相關的鏈接「Link」。以 <code>InventoryItem</code> 為例，一個普通的對象編碼為 JSON 僅包含其所有屬性，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "id" : "ff8080817203fa06017203fa7df40011",
  "productId" : "P123456",
  "quantity" : 12,
  "unitPrice" : 12.12,
  "createdAt" : "2020-05-11T13:44:07.414+0000",
  "updatedAt" : "2020-05-11T13:44:07.414+0000"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但編碼為 HAL+JSON 格式時則需附加一些鏈接，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "id" : "ff8080817203fa06017203fa7df40011",
  "productId" : "P123456",
  "quantity" : 12,
  "unitPrice" : 12.12,
  "createdAt" : "2020-05-11T13:44:07.414+0000",
  "updatedAt" : "2020-05-11T13:44:07.414+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/inventoryItems/ff8080817203fa06017203fa7df40011"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Hateoas 提供了 <code>EntityModel</code> 和 <code>PagedModel</code>，分別用於將單個實體和分頁查詢結果「Page」包裝成 HAL 模型。</p>
</div>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RestController
@RequestMapping("inventoryItems")
@ExposesResourceFor(
    InventoryItem.class)
@PreAuthorize("hasAuthority('SCOPE_inventory.read')")
public class InventoryItemController {

  private static final String AUTHORITY_INVENTORY_WRITE = "hasAuthority('SCOPE_inventory.write')";

  private final EntityLinks entityLinks;
  @Autowired
  private PagedResourcesAssembler&lt;InventoryItem&gt; pagedResourcesAssembler; <i class="conum" data-value="1"></i><b>(1)</b>
  @Autowired
  private InventoryItemRepository repository;

  public InventoryItemController(EntityLinks entityLinks) { <i class="conum" data-value="2"></i><b>(2)</b>
    this.entityLinks = entityLinks;
  }
  @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE, "application/hal+json"})
  @ResponseStatus(HttpStatus.CREATED)
  @PreAuthorize(AUTHORITY_INVENTORY_WRITE)
  public EntityModel&lt;InventoryItem&gt; create(@RequestBody InventoryItem entity) {
    InventoryItem createdOne = repository.save(entity);
    return new EntityModel&lt;&gt;(createdOne, itemLinks(createdOne)); <i class="conum" data-value="3"></i><b>(3)</b>
  }
  ...
  @GetMapping(value = "search/productIdIn", produces = "application/hal+json")
  public PagedModel&lt;EntityModel&lt;InventoryItem&gt;&gt; searchByProductId(
      @RequestParam("productId") List&lt;String&gt; productIds, @NotNull Pageable pageable) {
    Page&lt;InventoryItem&gt; pagedItems = repository.findByProductIdIn(productIds, pageable);
    return pagedResourcesAssembler.toModel(pagedItems); <i class="conum" data-value="4"></i><b>(4)</b>
  }
    private Link[] itemLinks(final InventoryItem item) {
    return new Link[]{
        entityLinks.linkToItemResource(InventoryItem.class, item.getId()) <i class="conum" data-value="5"></i><b>(5)</b>
    };
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Spring Data 提供了一個工具類 <code>PagedResourcesAssembler</code> 幫助應用開發者將 <code>Page</code> 轉換為 <code>PagedModel</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>以構造器注入方式注入 <code>EntityLinks</code>。<code>EntityLinks`可以幫助應用開發者構造單個實體的鏈接。因為所有鏈接都是絕對地址，其中包含了服務的域名端口等，構造過程比較繁瑣。有了 `EntityLinks</code> 的幫助可以大大減少應用開發者的工作量。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>HAL 模型其實就是普通模型加鏈接。將單個實體的鏈接構造集中到一個補助方法中。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>PagedResourcesAssembler` 可以直接從 <code>Page</code> 對象構造 <code>PagedModel</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>EntityLinks</code> 構造一個至實體自身的鏈接，該鏈接包含了服務域名和端口號。</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="鍳權"><a class="link" href="#鍳權">鍳權</a></h6>
<div class="listingblock">
<div class="title">SecurityConfig.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Profile("!test")
@EnableWebSecurity
@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable()
        .authorizeRequests()
        .anyRequest().authenticated()
        .and()
        .oauth2ResourceServer()
        .jwt();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;1&gt;
&lt;2&gt;</p>
</div>
<div class="listingblock">
<div class="title">InventoryItemController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RestController
@RequestMapping("inventoryItems")
@ExposesResourceFor(
    InventoryItem.class)
@PreAuthorize("hasAuthority('SCOPE_inventory.read')") <i class="conum" data-value="1"></i><b>(1)</b>
public class InventoryItemController {

  private static final String AUTHORITY_INVENTORY_WRITE = "hasAuthority('SCOPE_inventory.write')";
  ...
  @PostMapping(consumes = {MediaType.APPLICATION_JSON_VALUE, "application/hal+json"})
  @ResponseStatus(HttpStatus.CREATED)
  @PreAuthorize(AUTHORITY_INVENTORY_WRITE)
  public EntityModel&lt;InventoryItem&gt; create(@RequestBody InventoryItem entity) {
    InventoryItem createdOne = repository.save(entity);
    return new EntityModel&lt;&gt;(createdOne, itemLinks(createdOne));
  }
  ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="測試-3"><a class="link" href="#測試-3">測試</a></h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="參考-7"><a class="link" href="#參考-7">參考</a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://zh.wikipedia.org/zh-cn/关系数据库">關係數據庫</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/zh-tw/关系模型">關係模型</a></p>
</li>
<li>
<p><a href="https://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-eval-oth-JSpec/persistence-2_0-final-spec.pdf">JSR 317: Java&#8482; Persistence API, Version 2.0</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="訂單服務order-service"><a class="link" href="#訂單服務order-service">訂單服務「Order Service」</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>::icons: font</p>
</div>
<div class="sect2">
<h3 id="目標-6"><a class="link" href="#目標-6">目標</a></h3>
<div class="paragraph">
<p>本章中，我們將基於Spring Boot開發RESTFul風格的訂單服務。我們將學習：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Spring Data JPA訪問MySQL數據庫</p>
</li>
<li>
<p>使用</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="需求分析"><a class="link" href="#需求分析">需求分析</a></h3>
<div class="sect3">
<h4 id="用例-4"><a class="link" href="#用例-4">用例</a></h4>
<div class="imageblock">
<div class="content">
<img src="images/order-usecase.png" alt="order usecase" width="334" height="521">
</div>
<div class="title">Figure 27. 用例</div>
</div>
<div class="paragraph">
<p>顧客「Customer」和訂單運營人員「OrderOps」兩個用戶⻆色參與訂單處理業務。</p>
</div>
<div class="paragraph">
<p>作為一名顧客，我可以創建訂單「Order」，並嚮其中添加任意數量的商品「Product」；創建訂單之後，我可以提交訂單或取消訂單；提交訂單之後，我可以支付訂單；一但我支付了訂單，系統應立即開始交付訂單；當我確認訂單已被交付，我可以關閉訂單。</p>
</div>
<div class="paragraph">
<p>作為一名訂單運營人員，我可以將已支付的「Paid」訂單標記為交付中「On Delivery」；當確認訂單已實際被交付時，可以將訂單標記為已交付「Delivered」。</p>
</div>
</div>
<div class="sect3">
<h4 id="領域模型-2"><a class="link" href="#領域模型-2">領域模型</a></h4>
<div class="imageblock">
<div class="content">
<img src="images/order-model.png" alt="order model" width="328" height="340">
</div>
<div class="title">Figure 28. Order</div>
</div>
<div class="paragraph">
<p>訂單處理是圍繞領域模型<strong>訂單「Order」</strong>。訂單紀錄了一竹竹中手<strong>購買</strong>活動的全部信息，包括購買商品清單數量、金額、顧客信息等。一筆真實的<strong>購買</strong>活動由多個線上線下子活動組成，所以訂單模型實體拥有較長的生命週期，及多個週期階段。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/order-state.png" alt="order state" width="852" height="373">
</div>
<div class="title">Figure 29. Order State</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>OPEN</strong> 當訂單被顧客創建時，其處於 <code>OPEN</code> 狀態。</p>
</li>
<li>
<p><strong>SUBMITTED</strong> 顧客可以提交<strong>OPEN</strong>狀態的訂單，提交後的訂單處於<strong>SUBMITTED</strong>狀態。</p>
</li>
<li>
<p><strong>CANCELLED</strong> 顧客也可以取消<strong>OPEN</strong>狀態的訂單。</p>
</li>
<li>
<p><strong>PAID</strong> 顧客針對<strong>SUBMITTED</strong>狀態的訂單進行支付。顧客其實是與第三方支付提供商「Payment Provider」交互，支付提供商嚮本系統通知支付結果。支付成功後，訂單狀態為<strong>PAID</strong>。</p>
</li>
<li>
<p><strong>ON_DELOVERY</strong> 訂單運營人員可以將<strong>PAID</strong>訂單標記為<strong>ON_DELIVERY</strong>以開始交付。</p>
</li>
<li>
<p><strong>DELIVERED</strong> 當訂單運營人員確認訂單已被交付時，將訂單標記為<strong>DELIVERED</strong>。</p>
</li>
<li>
<p><strong>CLOSED</strong> 顧客關閉已交付的訂單。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="設計-4"><a class="link" href="#設計-4">設計</a></h3>
<div class="sect3">
<h4 id="領域模型-3"><a class="link" href="#領域模型-3">領域模型</a></h4>
<div class="imageblock">
<div class="content">
<img src="images/order-class.png" alt="order class" width="506" height="235">
</div>
<div class="title">Figure 30. Order</div>
</div>
</div>
<div class="sect3">
<h4 id="restful-api"><a class="link" href="#restful-api">RESTFul API</a></h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Order RESTFul API</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">Endpoint</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
<th class="tableblock halign-left valign-top">參數</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">創建訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">提交訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/submit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">取消訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/cancel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">支付訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/pay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">開始交付訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/startDelivery</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">完成交付訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/completeDelivery</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">關閉定單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;/close</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">穫取單個訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders/&lt;id&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>id</code> 訂單唯一標識</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分頁穫取訂單</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/orders?page=&lt;page&gt;&amp;size=&lt;size&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>page</code> 分頁索引，從 <code>0</code> 開始；<code>size</code> 分頁大小，默認 <code>10</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="實現-6"><a class="link" href="#實現-6">實現</a></h3>

</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.0.1<br>
Last updated 2020-09-06 07:40:06 UTC
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>