<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Catalog Service</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Catalog Service</h1>
<div class="details">
<span id="revnumber">version 0.0.1</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#目標">目標</a></li>
<li><a href="#設計">設計</a>
<ul class="sectlevel2">
<li><a href="#用例">用例</a></li>
<li><a href="#架構">架構</a></li>
<li><a href="#理解-lombok">理解 Lombok</a></li>
<li><a href="#理解-rest">理解 REST</a></li>
<li><a href="#理解-json">理解 JSON</a></li>
<li><a href="#理解-hypermedia-driven">理解 Hypermedia-Driven</a></li>
<li><a href="#理解-spring-data-rest">理解 Spring Data REST</a></li>
<li><a href="#理解-mongodb">理解 MongoDB</a></li>
<li><a href="#理解-spring-data-mongodb">理解 Spring Data MongoDB</a></li>
<li><a href="#理解junit">理解JUnit</a></li>
<li><a href="#理解spring-mvc-test-framework">理解Spring MVC Test Framework</a></li>
<li><a href="#理解-spring-rest-docs">理解 Spring REST Docs</a></li>
</ul>
</li>
<li><a href="#實現">實現</a>
<ul class="sectlevel2">
<li><a href="#構建">構建</a></li>
<li><a href="#領域模型">領域模型</a></li>
<li><a href="#倉庫-repository">倉庫 Repository</a></li>
<li><a href="#restful-web-服務">RESTful Web 服務</a></li>
</ul>
</li>
<li><a href="#測試">測試</a>
<ul class="sectlevel2">
<li><a href="#應用編程接口測試api-test">應用編程接口測試「API Test」</a></li>
<li><a href="#使用嵌入式mongodb-mock-mongodb">使用嵌入式MongoDB mock MongoDB</a></li>
</ul>
</li>
<li><a href="#api文檔">API文檔</a></li>
<li><a href="#總結">總結</a></li>
<li><a href="#參考">參考</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="目標">目標</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章中，我們將基於Spring Boot開發提供RESTful API的Catalog微服務。我們將學習：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用Lombok在編譯器生成Getter和Setter訪問器，減少模板代碼</p>
</li>
<li>
<p>使用Spring Data/Spring Data MongoDB訪問MongoDB</p>
</li>
<li>
<p>使用Spring Data REST從Repository構建RESTful API</p>
</li>
<li>
<p>使用Spring Test/MockMVC測試RESTFul API</p>
</li>
<li>
<p>使用Spring REST Docs生成簡潔、準確且結構良好的RESTFul API文檔</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="設計">設計</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="用例">用例</h3>
<div class="paragraph">
<p>Catalog微服務負責維護Product和ProductImage兩個業務模型實體。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/catalog-model.png" alt="catalog model" width="410" height="148">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Product，可被獨立增刪改查的業務實體，其可關聯一至多個ProductImage</p>
</li>
<li>
<p>ProductImage，可被獨立增刪改查的業務實體，其可被零至一個Product關聯。如若關聯其的Product被移除，不會影嚮ProductImage實體的狀態。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Catalog微服務需支持特性：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>創建新的ProductImage</p>
</li>
<li>
<p>更新ProductImage</p>
</li>
<li>
<p>移除ProductImage</p>
</li>
<li>
<p>分頁查詢所有ProductImage</p>
</li>
<li>
<p>讀取單個ProductImage</p>
</li>
<li>
<p>創建新的Product</p>
</li>
<li>
<p>更新Product</p>
</li>
<li>
<p>移除Product</p>
</li>
<li>
<p>分頁查詢所有ProductImage</p>
</li>
<li>
<p>讀取單個Product</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="架構">架構</h3>
<div class="paragraph">
<p>Catalog微服務採用分層架構，自上往下分為：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>展示層。以RESTFul風格向外曝露Catalog支持的領域模型和操作，以JSON格式接受和迴應領域模型內容。</p>
</li>
<li>
<p>業務邏輯層，處理應用相關的業務邏輯，比如填充createdAt和updatedAt。</p>
</li>
<li>
<p>數據訪問層，處理Java object和具體存儲實體之間的映射轉換，實現橧刪改查等存儲訪問操作。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/catalog-design.png" alt="catalog design" width="276" height="440">
</div>
</div>
<div class="paragraph">
<p>這𥚃我們採用Spring Data REST實現展現層；供助Spring Data REST開放的實體事件擴展機制，實現業務邏輯；數據存儲方案選用MongoDB；數據訪問層採用Spring Data MongoDB實現。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-lombok">理解 Lombok</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Lombok項目是一個Java庫，它會自動插入您的編輯器和構建工具中，從而使您的Java更加生動有趣。
永遠不要再寫另一個getter或equals方法，帶有一個註釋的您的類有一個功能全面的生成器，自動化您的日誌記錄變量等等。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok<br>
<cite>https://projectlombok.org</cite>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>使用javac（以及netbeans，maven，gradle和大多數其他構建系統）時，lombok作為註釋處理器運行。</p>
</div>
<div class="paragraph">
<p>Lombok在classpath中，且javac將在它可以找到的類路徑上加載每個 <code>META-INF/services/javax.annotation.processing.Processor</code> 文件，讀取每一行並加載該類，然後將其作為註釋處理器執行。 <code>lombok.jar</code> 有此文件，它將`lombok.launch.AnnotationProcessorHider$AnnotationProcessor`列為條目。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Lombok Execution Path<br>
<cite>https://projectlombok.org/contributing/lombok-execution-path</cite>
</div>
</div>
<div class="paragraph">
<p>Lombok實現為注解處理器「Annotation Processor」，在編譯期被Java編譯器調用，掃描代碼，讀取Lombok注解及關鍵詞標注的類，並執行相應的代碼轉換。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Lombok官方網站 <a href="https://projectlombok.org/">Lombok Project</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-rest">理解 REST</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>代表性狀態轉移（REST）是一種軟件體系結構樣式，它定義了一組用於創建Web服務的約束。 符合REST體系結構樣式的Web服務（稱為RESTful Web服務）提供Internet上計算機系統之間的互操作性。 RESTful Web服務允許請求系統通過使用統一且預定義的無狀態操作集來訪問和操縱Web資源的文本表示。 其他類型的Web服務（例如SOAP Web服務）公開其自己的任意操作集。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Representational State Transfer<br>
<cite>https://en.wikipedia.org/wiki/Representational_state_transfer</cite>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服務有以下特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>以資源為中心，領域模型在RESTFul API中表現為資源，所有的業務操作都表現為對資源的操作。</p>
</li>
<li>
<p>重用HTTP請求方法。以HTTP請求方法表逹對資源的操作。HTTP協議中定義了九種請求方法：</p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET方法請求指定資源的表示形式。 使用GET的請求應僅檢索數據。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEAD方法請求的響應與GET請求的響應相同，但沒有響應主體。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST方法用於將實體提交給指定的資源，通常會導致狀態更改或對服務器產生副作用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT方法用請求有效負載替換目標資源的所有當前表示形式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE方法刪除指定的資源。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONNECT方法建立到由目標資源標識的服務器的隧道。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OPTIONS方法用於描述目標資源的通信選項。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TRACE方法沿到目標資源的路徑執行消息環回測試。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PATCH方法用於對資源進行部分修改。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>RESTFul 主要重用其中的POST、DELETE、PUT和GET來分別表逹增、刪、改和查操作。</p>
</div>
</li>
<li>
<p>重用HTTP嚮應狀態碼。重用HTTP嚮應狀態碼來表逹請求的處理結果。HTTP協議定義了五類嚮應狀態碼</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>信息性的嚮應（100-199）</p>
</li>
<li>
<p>成功的嚮應（200-299）</p>
</li>
<li>
<p>重定向（300-399）</p>
</li>
<li>
<p>客戶端錯誤（400-499）</p>
</li>
<li>
<p>服務端錯誤（500-599）</p>
<div class="paragraph">
<p>常用的嚮應狀態碼有：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Code</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 OK</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">該請求已成功。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">201 Created</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求成功，並因此創建了新資源。 這通常是在POST請求或某些PUT請求之後發送的響應。當使用POST請求訪問RESTFul API創建新資源實體後，應返迴嚮應狀態碼200。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">204 No Content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沒有要發送的內容，但標頭可能有用。 用戶代理可以使用新的代理更新該資源的緩存頭。當使用PUT請求訪問RESTFul API更新資源實體且未在嚮應報文中包含更新後的實體，應使用嚮應狀態碼204。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">400 Bad Request</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由於語法無效，服務器無法理解該請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">401 Unauthorized</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">儘管HTTP標準指定“未經授權”，但從語義上講，此響應表示“未經驗證”。 也就是說，客戶端必須對自己進行身份驗證才能獲得請求的響應。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">403 Forbidden</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客戶端無權訪問內容； 也就是說，它是未經授權的，因此服務器拒絕提供所請求的資源。 與401不同，服務器知道客戶端的身份。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">404 Not Found</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器找不到請求的資源。 在瀏覽器中，這意味著無法識別URL。 在API中，這也可能意味著端點有效，但是資源本身不存在。 服務器也可以發送此響應而不是403，以隱藏來自未授權客戶端的資源。 由於此響應代碼在網絡上經常出現，因此可能是最著名的響應代碼。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">405 Method Not Allowed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器知道該請求方法，但已被禁用，無法使用。比如針對祗讀資源的寫請求（POST、DELETE、PUT），RESTFul API可以嚮應此狀態碼。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">415 Unsupported Media Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器不支持所請求數據的媒體格式，因此服務器拒絕了該請求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">500 Internal Server Error</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">服務器遇到了不知道如何處理的情況。任何業務邏輯的錯誤都不應該嚮應該狀態碼。祗有真正無法處理或恢復的失效，比如依賴服務不可用等，才可以嚮應該狀態碼。</p></td>
</tr>
</tbody>
</table>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="product-restful-web-api">Product RESTFul Web API</h4>
<div class="paragraph">
<p>REST Web服務以資源為中心，把領域模型Product直接映射為資源product，所以資源product的根URL就為 <code>/products</code> 。因為從語義上講，對資源根URL的操作，如GET、POST，都是作用於資源集合而非單個資源實體，所以使用復數形式更為恰當。（很多人認為使用單數形式是最佳實踐，因為英文名詞的復數形式規則並不統一且大部份人英文不好，硬用復數形式容易出現拚寫錯誤）</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">創建新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新與ProductImage之間的關聯</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取單個Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分頁讀取所有Product</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取Product關聯的ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/products/&lt;productId&gt;/images</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="productimage-restful-api">ProductImage RESTFul API</h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">操作</th>
<th class="tableblock halign-left valign-top">URL</th>
<th class="tableblock halign-left valign-top">HTTP方法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">創建新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">更新ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUT</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">讀取單個ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages/&lt;productImageId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">分頁讀取所有ProductImage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/productImages?page=&lt;pageIndex&gt;&amp;size=&lt;pageSize&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-json">理解 JSON</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>JSON(JavaScript Object Notation) 是一種輕量級的數據交換格式。易於人閱讀和編寫。同時也易於機器解析和生成。它基於JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一個子集。 JSON採用完全獨立於語言的文本格式，但是也使用了類似於C語言家族的習慣（包括C, C++, C#, Java, JavaScript, Perl, Python等）。這些特性使JSON成為理想的數據交換語言。</p>
</div>
<div class="paragraph">
<p>JSON建構於兩種結構：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“名稱/值”對的集合（A collection of name/value pairs）。不同的語言中，它被理解為對象（object），紀錄（record），結構（struct），字典（dictionary），哈希表（hash table），有鍵列表（keyed list），或者關聯數組（associative array）。</p>
</li>
<li>
<p>值的有序列表（An ordered list of values）。在大部分語言中，它被理解為數組（array）。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; 介紹JSON<br>
<cite>https://www.json.org/json-zh.html</cite>
</div>
</div>
<div class="paragraph">
<p>JSON是一種面嚮字符的、編程語言獨立的、易於人和機器讀寫的數據交換格式。使用JSON作為RESTFul Web服務與消費者之間交換實體內容的數據格格，可以最大限度地提升Web服務的兼容性。但需要注意，JSON是面嚮文本的數據交換格式，所有類型的數據都必須被編碼為文本形式，所以JSON並不適用二進制數據的交換，比如圖像、音頻、視頻。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>關於JSON的規範定義，請參閱 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404 The JSON Data Interchange Standard</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="理解-hypermedia-driven">理解 Hypermedia-Driven</h3>
<div class="paragraph">
<p>Hypermedia指代所有包含指向其它媒體（如圖像、視頻和文本等）的鏈接的內容。Hypermedia-Driven的RESTFul Web服務則是指在請求體和嚮應體的內容為Hypermedia。</p>
</div>
<div class="paragraph">
<p>HATEOAS（Hypermedia as the Engine of Application State）是一組附加在RESTFul風格架構之上的約束，其旨在約束Hypermedia-Driven RESTFul Web服務。HATEOAS沒有嚴格的定義，各個框架都有自己的實現。但大多數HATEOAS實現都參考了以下規範：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc5988">RFC 5988 Web Linking</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Hypertext_Application_Language">Hypertext Application Language</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-data-rest">理解 Spring Data REST</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data REST是Spring Data的一部份，其致力於簡化在Spring Data repository之上構建<strong>超媒體驅動「hypermedia-driven」</strong> REST web微務。</p>
</div>
<div class="paragraph">
<p>Spring Data REST 構建於 Spring Data repository 之上，分析你的應用領域模型且曝露超媒體驅動HTTP資源。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-rest
</div>
</div>
<div class="paragraph">
<p>Spring Framework 本身提供了Spring MVC。借助Spring MVC，可以快速構造RESTFul web服務。再加上Spring HATEOAS，就可以構建超媒體驅動的RESTFul web服務了。但是RESTFul web服務是以資源為中心，其為每類資源實現一組有限的動作，如POS創建、PUT更新、DELETE移除。直接使用Spring MVC構建RESTFul web服務會造成很多模板代碼。Spring Data REST就是為了避免使用Spring MVC構建RESTFul web服務時產生冗餘模板代碼而被創造出來。Spring Data REST分析應用中的repository，分揀出領域模型和增刪改查方法，分別曝露為相應的RESTFul URLs.</p>
</div>
<div class="paragraph">
<p>Spring Data REST 開放出了八個實體事件，應用開發者可以注入自定義的事件監聽器以實現業務邏輯處理。Spring Data REST會釋放出以下八種事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeforeCreateEvent</code></p>
</li>
<li>
<p><code>AfterCreateEvent</code></p>
</li>
<li>
<p><code>BeforeSaveEvent</code></p>
</li>
<li>
<p><code>AfterSaveEvent</code></p>
</li>
<li>
<p><code>BeforeDeleteEvent</code></p>
</li>
<li>
<p><code>AfterDeleteEvent</code></p>
</li>
<li>
<p><code>BeforeLinkSaveEvent</code></p>
</li>
<li>
<p><code>AfterLinkSaveEvent</code></p>
</li>
<li>
<p><code>BeforeLinkDeleteEvent</code></p>
</li>
<li>
<p><code>AfterLinkDeleteEvent</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beforecreateevent-和-aftercreateevent"><code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在創建實體實例時，會釋放出 <code>BeforeCreateEvent</code> 和 <code>AfterCreateEvent</code>。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; createAndReturn(Object domainObject, RepositoryInvoker invoker,
		PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeCreateEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object savedObject = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterCreateEvent(savedObject)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在調用repository方法將創建的實體持久化至存儲服務之前，釋放出事件 <code>BeforeCreateEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在調用repository方法將創建的實體持久化至存儲服務之後，釋放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>POST和PUT請求都有可能觸發實體的創建。POST在REST語義中就是創建新實體，所以POST請求肯定會觸發實體創建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@ResponseBody
@RequestMapping(value = BASE_MAPPING, method = RequestMethod.POST)
public ResponseEntity&lt;ResourceSupport&gt; postCollectionResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, PersistentEntityResourceAssembler assembler,
		@RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	resourceInformation.verifySupportedMethod(HttpMethod.POST, ResourceType.COLLECTION);

	return createAndReturn(payload.getContent(), resourceInformation.getInvoker(), assembler,
			config.returnBodyOnCreate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>PUT請求在REST語義中是更新實體，但若要求更新的目標實體不存在，則更新操作就自動轉化為創建操作。所以，當使用PUT請求更新不存在的實體時，會觸發實體創建。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

	...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>若請求創建的實體是新建的即目標實體不存在，則更新請求轉化為創建操作。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforesaveevent-和-aftersaveevent"><code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在更新實體時會釋放出 <code>BeforeSaveEvent</code> 和 <code>AfterSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private ResponseEntity&lt;ResourceSupport&gt; saveAndReturn(Object domainObject, RepositoryInvoker invoker,
		HttpMethod httpMethod, PersistentEntityResourceAssembler assembler, boolean returnBody) {

	publisher.publishEvent(new BeforeSaveEvent(domainObject)); <i class="conum" data-value="1"></i><b>(1)</b>
	Object obj = invoker.invokeSave(domainObject);
	publisher.publishEvent(new AfterSaveEvent(obj)); <i class="conum" data-value="2"></i><b>(2)</b>

	...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在調用repository方法將更新的實體持久化至存儲服務之前，釋放出事件 <code>BeforeSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在調用repository方法將更新的實體持久化至存儲服務之後，釋放出事件 <code>AfterCreateEvent</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>PUT和PATCH請求都會觸發實體更新操作。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PUT)
public ResponseEntity&lt;? extends ResourceSupport&gt; putItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException {

    ...

	return payload.isNew() ? createAndReturn(objectToSave, invoker, assembler, config.returnBodyOnCreate(acceptHeader))
			: saveAndReturn(objectToSave, invoker, PUT, assembler, config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>當請求更新的目標實體存在時，PUT請求觸發更新操作。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.PATCH)
public ResponseEntity&lt;ResourceSupport&gt; patchItemResource(RootResourceInformation resourceInformation,
		PersistentEntityResource payload, @BackendId Serializable id, PersistentEntityResourceAssembler assembler,
		ETag eTag, @RequestHeader(value = ACCEPT_HEADER, required = false) String acceptHeader)
		throws HttpRequestMethodNotSupportedException, ResourceNotFoundException {

	...

	return saveAndReturn(domainObject, resourceInformation.getInvoker(), PATCH, assembler,
			config.returnBodyOnUpdate(acceptHeader)); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>PATCH請求祗能觸發實體更新。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="beforedeleteevent-和-afterdeleteevent"><code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在移除實體時會釋放出事件 <code>BeforeDeleteEvent</code> 和 <code>AfterDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryEntityController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING + "/{id}", method = RequestMethod.DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;?&gt; deleteItemResource(RootResourceInformation resourceInformation, @BackendId Serializable id,
		ETag eTag) throws ResourceNotFoundException, HttpRequestMethodNotSupportedException {

	...

	return domainObj.map(it -&gt; {

		PersistentEntity&lt;?, ?&gt; entity = resourceInformation.getPersistentEntity();

		eTag.verify(entity, it);

		publisher.publishEvent(new BeforeDeleteEvent(it)); <i class="conum" data-value="2"></i><b>(2)</b>
		invoker.invokeDeleteById(entity.getIdentifierAccessor(it).getIdentifier());
		publisher.publishEvent(new AfterDeleteEvent(it)); <i class="conum" data-value="3"></i><b>(3)</b>

		return new ResponseEntity&lt;Object&gt;(HttpStatus.NO_CONTENT);

	}).orElseThrow(() -&gt; new ResourceNotFoundException());
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>針對實體的DELETE請求會觸發實體移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將實體從存儲服務中移除之前，釋放出事件 <code>BeforeDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將實體從存儲服務中移除之後，釋放出事件 <code>AfterDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforelinksaveevent-和-afterlinksaveevent"><code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code></h4>
<div class="paragraph">
<p>Spring Data REST在創建和變更實體關聯時會釋放出 <code>BeforeLinkSaveEvent</code> 和 <code>AfterLinkSaveEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = { PATCH, PUT, POST }, <i class="conum" data-value="1"></i><b>(1)</b>
		consumes = { MediaType.APPLICATION_JSON_VALUE, SPRING_DATA_COMPACT_JSON_VALUE, TEXT_URI_LIST_VALUE })
public ResponseEntity&lt;? extends ResourceSupport&gt; createPropertyReference(RootResourceInformation resourceInformation,
		HttpMethod requestMethod, @RequestBody(required = false) Resources&lt;Object&gt; incoming, @BackendId Serializable id,
		@PathVariable String property) throws Exception {

	...

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; {

        ...

		publisher.publishEvent(new BeforeLinkSaveEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = invoker.invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkSaveEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return null;
	};

	doWithReferencedProperty(resourceInformation, id, property, handler, requestMethod);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>PATCH、PUT或POST請求鏈接（LINK）類型的實體屬性都會觸發實體鏈接屬性的創建或變更。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將鏈接屬性變更持久化至存儲服務之前，釋放出 <code>BeforeLinkSaveEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將鏈接屬性變更持久化至存儲服務之後，釋放出 <code>AfterLinkSaveEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beforelinkdelete-和-afterlinkdelete"><code>BeforeLinkDelete</code> 和 <code>AfterLinkDelete</code></h4>
<div class="paragraph">
<p>Spring Data REST在移除實體之間的關聯（LINK）時，會釋放出 <code>BeforeLinkDeleteEvent</code> 和 <code>AfterLinkDeleteEvent</code> 。</p>
</div>
<div class="listingblock">
<div class="title">RepositoryPropertyReferenceController.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@RequestMapping(value = BASE_MAPPING, method = DELETE) <i class="conum" data-value="1"></i><b>(1)</b>
public ResponseEntity&lt;? extends ResourceSupport&gt; deletePropertyReference(RootResourceInformation repoRequest,
		@BackendId Serializable id, @PathVariable String property) throws Exception {

	Function&lt;ReferencedProperty, ResourceSupport&gt; handler = prop -&gt; prop.mapValue(it -&gt; {

		...

		publisher.publishEvent(new BeforeLinkDeleteEvent(prop.accessor.getBean(), prop.propertyValue)); <i class="conum" data-value="2"></i><b>(2)</b>
		Object result = repoRequest.getInvoker().invokeSave(prop.accessor.getBean());
		publisher.publishEvent(new AfterLinkDeleteEvent(result, prop.propertyValue)); <i class="conum" data-value="3"></i><b>(3)</b>

		return (ResourceSupport) null;

	}).orElse(null);

	doWithReferencedProperty(repoRequest, id, property, handler, HttpMethod.DELETE);

	return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>目標為鏈接類型的實體屬性的DELETE請求會觸發實體關聯移除操作。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在將實體關聯移除持久化至存儲服務之前，釋放出事件 <code>BeforeLinkDeleteEvent</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在將實體關聯移除持久化至存儲服務之後，釋放出事件 <code>AfterLinkDeleteEvent</code> 。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="注入事件處理器">注入事件處理器</h4>
<div class="paragraph">
<p>應用開發者可以自定義事件處理器，再使用注解將自定義事件處理器注刪為事件監聽器。Spring Data REST提供了十個注解分別對應上述十個實體事件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@HandleBeforCreate</code></p>
</li>
<li>
<p><code>@HandleAfterCreate</code></p>
</li>
<li>
<p><code>@HandleBeforeSave</code></p>
</li>
<li>
<p><code>@HandleAfterSave</code></p>
</li>
<li>
<p><code>@HandleBeforeDelete</code></p>
</li>
<li>
<p><code>@HandleAfterDelete</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkSave</code></p>
</li>
<li>
<p><code>@HandleAfterLinkSave</code></p>
</li>
<li>
<p><code>@HandleBeforeLinkDelete</code></p>
</li>
<li>
<p><code>@HandleAfterLinkDelete</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解-mongodb">理解 MongoDB</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>MongoDB是一個文檔數據庫，具有所需的可伸縮性和靈活性，可用於所需的查詢和索引編制。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MongoDB將數據存儲在類似於JSON的靈活文檔中，這意味著字段隨文檔的不同而不同，並且數據結構可以隨時間而變化</p>
</li>
<li>
<p>文檔模型映射到應用程序代碼中的對象，從而使數據易於使用</p>
</li>
<li>
<p>臨時查詢，索引編制和實時聚合提供了訪問和分析數據的強大方法</p>
</li>
<li>
<p>MongoDB以分佈式數據庫為核心，因此內置了高可用性，水平擴展和地理分佈並且易於使用</p>
</li>
<li>
<p>MongoDB是免費使用的。 在AGPL下發布了2018年10月16日之前發布的版本。 2018年10月16日之後發布的所有版本（包括先前版本的修補程序修補程序）均根據服務器端公共許可證（SSPL）v1發布。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
&#8212; What Is MongoDB<br>
<cite>https://www.mongodb.com/what-is-mongodb</cite>
</div>
</div>
<div class="paragraph">
<p>MongoDB是schema-free的數據庫，其非常適用於同一類別數據結構會隨時間較頻繁變動（增加屬性、減少屬性等）的應用場景。Catalog服務所維護的數據就符合這一特徵。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-data-mongodb">理解 Spring Data MongoDB</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data的任務是為數據訪問提供一個熟悉且一致的基於Spring的編程模型，同時仍保留基礎數據存儲的特殊特徵。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring Data MongoDB是Spring Data項目的一部分，該項目旨在為新數據存儲提供熟悉且一致的基於Spring的編程模型，同時保留特定於存儲的功能。</p>
</div>
<div class="paragraph">
<p>Spring Data MongoDB項目提供了與MongoDB文檔數據庫的集成。 Spring Data MongoDB的關鍵功能區域是一個以POJO為中心的模型，該模型用於與MongoDB DBCollection進行交互並輕鬆編寫存儲庫樣式的數據訪問層。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; https://spring.io/projects/spring-data-mongodb
</div>
</div>
<div class="paragraph">
<p>Spring Data的核心模式是倉庫設計模式「Repository Design Pattern」。
倉庫設計模式最早由Eric Evens在他的著作《Domain Driven Design》中提出，其核心概念是倉庫「Repository」。倉庫在業務邏輯層與數據源之間扮演着中間人的⻆色，其解耦了業務邏輯層和數據源，使用業務邏輯層無需關心具體數據源的接口或任何接口變更，甚至無需任何業務邏輯層的代碼變更就可以遷移至不同的數據源上。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/repository-pattern.png" alt="repository pattern" width="406" height="256">
</div>
</div>
<div class="paragraph">
<p>Spring Data提供的核心接口就是 <code>Repository</code> 。應用開發者祗需聲明專用於領域模型的、繼承 <code>Repository</code> 的倉庫接口，針對特定存儲服務實現的Spring Data模塊（如Spring Data MongoDB）會構造相應的倉庫實現Bean。</p>
</div>
<div class="paragraph">
<p>Spring Data除了 <code>Repository</code> 之外，還提供了其它倉庫接口。這些倉庫口提供了常用的數據訪問操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.data.repository.CrudRepository</code> 提供了基本的增刪改查操作</p>
</li>
<li>
<p><code>org.springframework.data.repository.PagingAndSortingRepository</code> 添加了分頁和排序功能</p>
</li>
<li>
<p><code>org.springframework.data.repository.query.QueryByExampleExecutor</code> 提供了相似查詢功能，應用可以按照業務邏輯定義相似算法，查詢相似（不完全相同，或主鍵相同）的實體</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/repository-interface.png" alt="repository interface" width="706" height="525">
</div>
</div>
<div class="paragraph">
<p>Spring Data MongoDB在Spring Data Commons提供的倉庫接口基礎上，還擴展了 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-data-mongodb-repository.png" alt="spring data mongodb repository" width="495" height="276">
</div>
</div>
</div>
<div class="sect2">
<h3 id="理解junit">理解JUnit</h3>
<div class="paragraph">
<p>JUnit 是一個 Java 編程語言的單元測試框架。JUnit 定義了三層單元測試組織結構：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TestSuite</p>
</li>
<li>
<p>TestCase</p>
</li>
<li>
<p>Test</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Test</strong> 是單元測試的最小組織單位，多個 <strong>Test</strong> 可以組織為 <strong>TestCase</strong>，多個 <strong>TestCase</strong> 可以組織為 <strong>TestSuite</strong>。在 Java 中，<strong>TestCase</strong> 和 <strong>TestSuite</strong> 實現為類，<strong>Test</strong> 實現為 <strong>TestCase</strong> 的方法。所以在實際應用中，<strong>Test</strong> 和 <strong>TestCase</strong> 是必須的，<strong>TestSuite</strong> 是可選的。</p>
</div>
<div class="paragraph">
<p>Junit 定義了五個單元測試執行階段：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BeforeClass</p>
</li>
<li>
<p>BeforeEach</p>
</li>
<li>
<p>Test</p>
</li>
<li>
<p>AfterEach</p>
</li>
<li>
<p>AfterClass</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong> 為 <strong>TestCase</strong> 的初始階段，JUnit 在即將執行 <strong>TestCase</strong> 所包含的 <strong>Test</strong> 之前執行 <strong>BeforeClass</strong>；<strong>BeforeEach</strong> 為 <strong>Test</strong> 的前置階段，JUnit 在每次執行 <strong>Test</strong> 之前執行 <strong>BeforeEach</strong>；<strong>Test</strong> 為單元測試的主要階段，該階段應包含嚮測試對象輸入和斷言測試對象的輸出；<strong>AfterEach</strong> 為 <strong>Test</strong> 的後置階段，JUnit 在每次執行 <strong>Test</strong> 之後執行 <strong>AfterEach</strong>；<strong>AfterClass</strong> 為 <strong>TestCase</strong> 的善後階段，JUnit 在執行完 <strong>TestCase</strong> 所包含的所有 <strong>Test</strong> 之後執行 <strong>AfterClass</strong>。</p>
</div>
<div class="paragraph">
<p>舉個例子，</p>
</div>
<div class="listingblock">
<div class="title">ExampleTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleTest {
  private Example testObject;
  @BeforeClass
  public void beforeClass() {
    System.out.println("Before test case ExampleTest");
  }
  @AfterClass
  public void afterClass() {
    System.out.println("After test case ExampleTest");
  }
  @BeforeEach
  public void setUp() {
    System.out.println("SetUp for each test");
    testObject = new Example();
  }
  @AfterEach
  public void tearDown() {
    System.out.println("TearDown for each test");
  }
  @Test
  public void testFunA() {
    String actual = testObject.funA();
    assertEqual(actual, "expected value");
  }
  @Test
  public void testFunB() {
    String actual = testObject.funB();
    assertEqual(actual, "expected value");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>BeforeClass</strong>, <strong>AfterClass</strong>, <strong>BeforeEach</strong>, <strong>AfterEach</strong> 和 <strong>Test</strong> 都被實現為 <strong>TestCase</strong> 的方法，通過注解聲明。JUnit 在執行上述 <strong>TestCase</strong>，方法調用序列為：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>beforeClass()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunA()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>setUp()</code></p>
</li>
<li>
<p><code>testFunB()</code></p>
</li>
<li>
<p><code>tearDown()</code></p>
</li>
<li>
<p><code>afterClass()</code></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="理解spring-mvc-test-framework">理解Spring MVC Test Framework</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring MVC測試框架提供了一流的支持，可使用可與JUnit，TestNG或任何其他測試框架一起使用的流暢API測試Spring MVC代碼。 它基於spring-test模塊的Servlet API mock objects構建，因此不使用正在運行的Servlet容器。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring MVC Test Framework<br>
<cite>https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#spring-mvc-test-framework</cite>
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架通過 <code>DispatcherServlet</code> 與Spring MVC代碼直接通信，無需運行Servlet容器。且測試代碼與被測試代碼（服務端代碼）運行在同一個JVM中，所以不僅可以驗證服務端代碼的輸出還可以驗證服務端代碼的內部狀態，即支持服務端代碼的白盒測試。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-mvc-architecture.png" alt="spring mvc architecture" width="495" height="309">
</div>
</div>
<div class="paragraph">
<p>在生產環境中， <code>dispatcherServlet</code> 和 <code>controller</code> 都運行在 <code>Servlet</code> 容器中（Spring Boot應用是內嵌Servlet容器），並通過Servlet容器嚮外曝露HTTP服務。客户端應用（Web瀏器、原生應用等）通過HTTP協議訪問Servlet容器，Servlet容器將請求轉化為 <code>HttpServletRequest</code> 交由 <code>dispatcherServlet</code> ； <code>dispatcherServlet</code> 再分發給對應的 <code>controller</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/mockmvc-archotecture.png" alt="mockmvc archotecture" width="352" height="234">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架則通過MockMvc（Servlet API mock objects）直接與 <code>dispatcherServlet</code> 通信。我們的測試目標是應用上下文配置和 <code>controller</code> 及其調用的其它Beans，Servlet容器並不是我們的測試目標（因為它們的代碼不是我們寫的）。使用這種測試方法可以最大限度地排除第三方代碼，僅關注於應用代碼的測試。</p>
</div>
</div>
<div class="sect2">
<h3 id="理解-spring-rest-docs">理解 Spring REST Docs</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Spring REST Docs可幫助您記錄RESTful服務。</p>
</div>
<div class="paragraph">
<p>它結合了用Asciidoctor編寫的手寫文檔和Spring MVC Test生成的自動生成的代碼片段。 這種方法使您擺脫了Swagger之類的工具所產生的文檔限制。</p>
</div>
<div class="paragraph">
<p>它可以幫助您生成準確，簡潔且結構合理的文檔。 然後，該文檔可讓您的用戶以最少的麻煩獲得他們所需的信息。</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Spring REST Docs<br>
<cite>https://spring.io/projects/spring-restdocs</cite>
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs致力於幫助應用開發者生成準確且可讀的RESTFul服務文檔。Spring REST Docs借助測試生成的HTTP請求和响應內容片斷，再組合手工編寫的Asciidoc或Markdown文本，產生HTML格式的文檔。文檔的生成依賴測試的通過。所以當測測未通過時，文檔也不會被生成，從而避免成生與實現不符的文檔。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-rest-docs-process.png" alt="spring rest docs process" width="388" height="293">
</div>
</div>
<div class="paragraph">
<p>Spring REST Docs可以從由Spring MVC Test框架、Spring WebFlux&#8217;s <code>WebTestClient</code> 和REST Assured 3編寫的測試中截取HTTP請求和响應片斷。</p>
</div>
<div class="paragraph">
<p>應用開發者編寫asciidoc文檔（以.adoc, .asciidoc, .ad, .asc山大弓火後綴的），引用Spring REST Docs在測試階段截取的片斷。Asciidoctor讀取asciidoc文檔和請求响應片斷，轉換生成HTML格式的可閱讀文檔（Asciidoctor還支持其它輸出格式，如PDF、EPUB等）。</p>
</div>
<div class="paragraph">
<p>作為Spring REST Docs的核心，其提供了豐富的HTTP請求响應片斷截取和注釋功能。所有這些截取注釋功能都實現為 <code>org.springframework.restdocs.snippet.Snippet</code> 的實現類，應用開發者通過構造方法穫取這些Snippet實現類實例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/http-message.png" alt="http message" width="606" height="313">
</div>
</div>
<div class="paragraph">
<p>HTTP報文分為請求（request）報文和响應（response）報文。請求報文由三部份組成：請求行（Request Line）、頭（Header Field）和消息體（Message Body）。响應報文也由三部份組成：狀態行（Status Line）、頭（Header Field）和消息體（Message Body）。</p>
</div>
<div class="paragraph">
<p>Spring REST Docs為請求行，頭和消息體分別提供了Snippet。這些Snippet的構造方法被組織為三個類：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.restdocs.request.RequestDocumentation</code> 包含用於截取請求行中各個部份的Snippet的構造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.headers.HeaderDocumentation</code> 包含用於截取請求頭和响應頭的Snippet的構造方法。</p>
</li>
<li>
<p><code>org.springframework.restdocs.payload.PayloadDocumentation</code> 包含用於截取請求消息體和响應消息體的Snippet的構造方法。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除此之外，Spring REST Docs還為Hypermedia-Driven RESTFul Web服務提供了專用的Snippets。這些專用Snippets的構造方法被組織為類 <code>org.springframework.restdocs.hypermedia.HypermediaDocumentation</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>關於Spring REST Docs完整的資料，請參閱官方文檔 <a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="實現">實現</h2>
<div class="sectionbody">
<div class="paragraph">
<p>最簡單的創建一個新的 Spring Boot 應用方法是使用 <a href="https://start.spring.io">Spring Initializr</a>。使用瀏覽器訪問 <a href="https://start.spring.io" class="bare">https://start.spring.io</a> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Project 選擇 Gradle Project，使用 Gradle 構建我們的項目；</p>
</li>
<li>
<p>Language 選擇 Java；</p>
</li>
<li>
<p>Spring Boot 撰擇 2.2.7 或其它 2.2.x 版本，最新版（訖今為止）的 Spring Cloud Hoxton 兼容 Spring Boot 2.2.x；</p>
</li>
<li>
<p>Project Metadata 部份，Group 填 <code>io.github.rscai.microservices</code>，Artifact 填 <code>catalog</code>，Name 填 <code>catalog</code>，Packaging 撰 Jar，Java 撰擇版本 8；</p>
</li>
<li>
<p>Dependencies 選擇</p>
</li>
<li>
<p>Spring Web</p>
</li>
<li>
<p>Spring Data MongoDB</p>
</li>
<li>
<p>Rest Repositories</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/02-Catalog/generate-project-by-spring-initializr.png" alt="generate project by spring initializr">
</div>
</div>
<div class="paragraph">
<p>單擊<strong>GENERATE</strong>，Spring initializr 就會生成 ZIP 格式的項目文件。</p>
</div>
<div class="paragraph">
<p>將 <code>catalog.zip</code> 解壓後得到一個 Spring Boot 項目。其中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>  .gitignore
  build.gradle
+ gradle
  + wrapper
      gradle-wrapper.war
      gradle-wrapper.properties
  graldew
  gradlew.bat
  HELP.md
  settings.gradle
+ src
  + main
    - java
    - resources
  + test
    - java</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>.gitignore</code>, 羅列了應被 GIT 忽略的文件和目錄。自動生成及臨時文件及目錄不應被納入版本控制；</p>
</li>
<li>
<p><code>build.gradle</code>，Gradle 項目文件，定義了項結構及構建過程；</p>
</li>
<li>
<p><code>gradle/wrapper/</code> 包含所有 Gradle Wrapper 相關的文件；</p>
</li>
<li>
<p><code>gradlew</code> 是 UNIX-like 平台版本的 Gradle 命令包裝；</p>
</li>
<li>
<p><code>gradlew.bat</code> 是 Windows 平台版本的 Gradle 命令包裝；</p>
</li>
<li>
<p><code>HELP.md</code> 顧名思義是幫助文檔，與 README 類似；</p>
</li>
<li>
<p><code>setting.gradle</code> Gradle 的屬性文件；</p>
</li>
<li>
<p><code>src/</code> 包含所有源代碼和資源文件：</p>
</li>
<li>
<p><code>src/main/</code> 包含所有部署至運行環境的源代碼文件（以編譯後的目標代碼形式被部署至運行環境）和資源文件：</p>
</li>
<li>
<p><code>src/main/java/</code> 包含所有部署至運行環境的 Java 源代碼文件：</p>
</li>
<li>
<p><code>src/main/resources/</code> 包含所有部署至運行環境的資源文件；</p>
</li>
<li>
<p><code>src/test</code> 包含所有用於測試的源代碼和資源文件；</p>
</li>
<li>
<p><code>src/test/java/</code> 包含所有用於測試的 Java 源代碼文件；</p>
</li>
<li>
<p><code>src/test/resource/</code> 包含所有用於測試的資源文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>將 catalog 項目導入 IntelliJ IDEA。首先，打開 Intellij IDEA，然後，單繫 Import Project，選定 catalog 項目目錄，再然後選擇以 Gradle 項目形式導入。IntelliJ IDEA 會自動初始執行 Gradle 配置，下載 <code>/gradle/wrapper/gradle-wrapper.properties</code> 中指定版本的 Gradle。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/02-Catalog/catalog-import.gif" alt="catalog import">
</div>
</div>
<div class="sect2">
<h3 id="構建">構建</h3>
<div class="paragraph">
<p>本項目使用 Gradle 構建。Gradle 構建過程主要通過 <code>build.gradle</code> 描述。</p>
</div>
<div class="paragraph">
<p>首先，引用必要的 Gradle 插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	id 'org.springframework.boot' version '2.2.2.RELEASE' <i class="conum" data-value="1"></i><b>(1)</b>
	id 'io.spring.dependency-management' version '1.0.8.RELEASE' <i class="conum" data-value="2"></i><b>(2)</b>
	id 'java'
	id "io.freefair.lombok" version "4.1.6"
	id "org.sonarqube" version "2.7.1"
	id 'jacoco'
	id 'org.asciidoctor.convert' version '1.5.3'
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入 Spring Boot 插件，其版本決定了引入的 Spring Boot 庫的版本。所以有了 Spring Boot 插件，就無需顯式指定各個 Spring Boot 庫的版本了。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>引入 Spring 依賴管理插件。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，引入依賴。</p>
</div>
<div class="listingblock">
<div class="title">gradle.build</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
ext {
	snippetsDir = file('build/generated-snippets')
	set('springCloudVersion', "Hoxton.SR1") <i class="conum" data-value="1"></i><b>(1)</b>
}

dependencies {
	asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor'
	implementation 'org.springframework.boot:spring-boot-starter-data-mongodb' <i class="conum" data-value="2"></i><b>(2)</b>
	implementation 'org.springframework.boot:spring-boot-starter-web' <i class="conum" data-value="3"></i><b>(3)</b>
	implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="4"></i><b>(4)</b>
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.cloud:spring-cloud-starter-netflix-eureka-client'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.security:spring-security-oauth2-resource-server'
	implementation 'org.springframework.security:spring-security-oauth2-jose'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo'
	testImplementation 'org.springframework.security:spring-security-test'
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}" <i class="conum" data-value="5"></i><b>(5)</b>
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>將 Spring Cloud 版本定義為變量，便於引用及統一管理。Spring Cloud 與 Spring Boot 之間的版本兼容性發佈在 <a href="https://spring.io/projects/spring-cloud#overview" class="bare">https://spring.io/projects/spring-cloud#overview</a>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Release train Spring Boot compatibility</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Release Train</th>
<th class="tableblock halign-left valign-top">Boot Version</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hoxton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Greenwich</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.1.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Finchley</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edgware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dalston</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.x</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-mongodb</code> 引入 Spring Data MongoDB 相關的庫，用以生成訪問 MongoDB 的 Repository。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>spring-boot-starter-web</code> 引入了 Spring MVC 相關的庫。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.boot:spring-boot-starter-data-rest</code> 引入 Spring Data REST 相關的庫。Spring Data REST 將 Repository 方法發佈為 RESTFul 風格的 Web 服務，以減少模板代碼。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>通過引入 <code>org.springframework.cloud:spring-cloud-dependencies</code> BOM 來管理 Spring Cloud 庫的版本。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="領域模型">領域模型</h3>
<div class="paragraph">
<p>利用Lombok編譯期生成getter/setter方法，減少重復的模板代碼。</p>
</div>
<div class="paragraph">
<p>使用Spring Data MongoDB提供的注解描述java類與MongoDB集合、java字段與MongoDB字段之間的映射關系。Spring Data MongoDB會根據映射關系生成對應的Repository實現。</p>
</div>
<div class="sect3">
<h4 id="product">Product</h4>
<div class="listingblock">
<div class="title">Product.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class Product {

  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String title;
  private List&lt;String&gt; tags;
  @DBRef <i class="conum" data-value="5"></i><b>(5)</b>
  private List&lt;ProductImage&gt; images;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>lombok.Getter</code> 注解標注的類中所有成員字段生成getter訪問器。比如針對字段 <code>private String id</code> ，其生成了相當與以下源代碼的Getter訪問器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public String getId() {
    return this.id;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>為了使使用Gradle構建項目也可處理Lombok注解、生成相應訪問器，我們需要在 <code>build.gradle</code> 中顯式引入Lombok插件：</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id "io.freefair.lombok" version "4.1.5" <i class="conum" data-value="1"></i><b>(1)</b>
	...
}
...</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>lombok.Setter</code> 注解標注的類中所有成員字段生成Setter訪問器。比如針對字段 <code>private String id</code> ，其生成了相當與以下代碼的Setter訪問器：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void setId(String id) {
    this.id = id;
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 將一個Java類映射到MongoDB的某個Collection。在MongoDB中，Collection是Document的集合。在Java中，Class是Object的模板，"從某個Class實例出來的Object"是一個Object的集合。所以，在Java Class/Object與MongoDB Collection/Document映射關系中，Class對應Collection，Object對應Document。而Object中的字段對應Document中的字段。
<div class="imageblock">
<div class="content">
<img src="images/diag-6a64f855599da504ff3b560cf8a9ee20.png" alt="diag 6a64f855599da504ff3b560cf8a9ee20" width="1563" height="397">
</div>
</div>
<div class="paragraph">
<p>其實例object映射為MongoDB中的一個docuemnt。object中的每一個屬性映射為document中的一個字段。比如，object中的字段 <code>id</code> 映射為Mongo document中的字段 <code>id</code> ；object中的字段 <code>title</code> 映射為Mongo document中的字段 <code>title</code> ；object中的字段 <code>tags</code> 映射為Mongo document中的字段 <code>tags</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.data.annotation.Id</code> 將對象中的字段`id`映射為文檔的主鍵 <code>id</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.data.mongodb.core.mapping.DBRef</code> 將對象中的字段 <code>images</code> 映射為一組 <code>com.mongodb.DBRef</code> 。 <code>com.mongodb.DBRef</code> 是指嚮另一個文檔的引用。 <code>@DBRef</code> 可用以標注簡單字段或集合字段。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data MongoDB提供的映射注解：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">注解</th>
<th class="tableblock halign-left valign-top">作用目標</th>
<th class="tableblock halign-left valign-top">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段是主鍵。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@MongoId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段是主鍵，與@Id不同的是其接受一個可選的參數 <code>FieldType</code> 用以自定義變換。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Document</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該類是要映射至數據庫的。同時可以指定對應的collection名穪。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@DBRef</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段會被映射為 <code>com.mongodb.DBRef</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Indexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@CompoundIndex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">類</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述聯合索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@GeoSpatialIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的地理索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@TextIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述該字段上的文本索引。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@HashIndexed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">聲明該字段上的HASH索引以用於分片集群上分區數據。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Language</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">為文本索引設置語言屬性。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Transient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默認所有私有字段都被映射到Mongo文檔，該注解可以顯式指明不映射該字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@PersistenceConstructor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">構造器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明在從數據庫實例化對象時使用該構造器。構造器的實參則按名穪從數據庫文檔中穫取。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">構造器參數</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">顯式聲明構造器參數所對應的文檔字段。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">顯式描述字段映射，包括對應文檔中字段的名穪和類型。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">字段</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指明該字段將作為樂觀鎖定「Optimistic Locking」機制中的版本屬性，在保存變更之前都會先檢查版本值是否為所期望的。其初始值為 <code>0</code> ，每次變更都會自動加 <code>1</code> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="productimage">ProductImage</h4>
<div class="listingblock">
<div class="title">ProductImage.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Getter <i class="conum" data-value="1"></i><b>(1)</b>
@Setter <i class="conum" data-value="2"></i><b>(2)</b>
@Document <i class="conum" data-value="3"></i><b>(3)</b>
public class ProductImage {
  @Id <i class="conum" data-value="4"></i><b>(4)</b>
  private String id;
  private String src;
  private Date createdAt;
  private Date updatedAt;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>@lombok.Getter</code> 注解標注的類中所有成員字段生成getter訪問器。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Lombok會在編譯期掃描類，為以 <code>@lombok.Setter</code> 注解標注的類中所有成員字段生成setter訪問器。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注解 <code>org.springframework.data.mongodb.core.mapping.Document</code> 將一個類 <code>ProductImage</code> 映射至MongoDB的Collection <code>ProductImage</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>org.springframework.data.annotation.Id</code> 將對象中的字段 <code>id</code> 映射為文檔的主鍵 <code>id</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="倉庫-repository">倉庫 Repository</h3>
<div class="paragraph">
<p><code>Repository</code> 是Spring Data抽象的中心接口。應用開發者以 <code>Repository</code> 子接口的形式聲明模型Repository及其需支持的數據訪問方法，Spring Data的具體數據存儲模塊（本例中是Spring Data MongoDB）將會為其生成相應的實現類。由於這些實現類僅包含模板代碼，所以自動生成可以大幅減少應用開發者重復工作。</p>
</div>
<div class="sect3">
<h4 id="productrepository">ProductRepository</h4>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products")
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>為模型 <code>Product</code> 創建專屬的 <code>ProductRepository</code> 接口，繼承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> . <code>MongoRepository</code> 繼承了接口 <code>PagingAndSortingRepository</code> ，Spring Data MongoDB會其生成一個支持增刪改查及分頁排序的MongoDB訪問實現類。因為 <code>ProductRepository</code> 除了繼承的方法聲明外，沒有聲明其它方法，所以Spring Data MongoDB就會直接使用通用的實現類 <code>org.springframework.data.mongodb.repository.support.SimpleMongoRepository&lt;T, ID&gt;</code> 做為其實現。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="productimagerepository">ProductImageRepository</h4>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages")
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>為模型 <code>ProductImage</code> 創建專屬的 <code>ProductImageRepository</code> ，繼承至 <code>org.springframework.data.mongodb.repository.MongoRepository</code> 。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="restful-web-服務">RESTful Web 服務</h3>
<div class="paragraph">
<p>Spring Data REST 是Spring Data的一部份，旨於簡化在Spring Data倉庫上構建hypermedia-driven REST Web服務。應用開發者僅需在依賴中引入 <code>spring-boot-starter-data-rest</code> ，再聲明領域模型的倉庫，Spring Data REST就會將其發佈為 Hypermedia-Driven REST Web服務。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
    ...
    implementation 'org.springframework.boot:spring-boot-starter-data-rest' <i class="conum" data-value="1"></i><b>(1)</b>
    ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>將 <code>spring-boot-starter-data-rest</code> 引入至 <code>implemenation</code> 範圍依賴。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductRepository</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "products", path = "products") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductRepository extends MongoRepository&lt;Product, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RepositoryRestResource</code> 宣告 <code>ProductRepository</code> 的數據訪問方法需被曝露為RESTful介面。RESTFul風格的API是以resource為中心，repository所專屬的模型就對應為RESTFul中的resource。 <code>@RepositoryRestResource</code> 充許應用開發者自定義模型所對應的resource在URL中及在內容體中的名字。本例中，resource Product的根RESTFul URL定義為 <code>products/</code> 。在HATEOAS標準的內容體中，Product集合會被命名為 <code>products</code> ，例如：
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-07T08:04:17.818+0000",
  "updatedAt" : "2019-12-07T08:04:17.818+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deb5d01eadafcc6501846a6/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Data REST有四種倉庫檢測策略，用以檢測哪些倉庫應被曝露為REST Web服務。其默認的檢測策略是曝露所有公共的倉庫接口（除了通過注解顯式標注不曝露的倉庫），但我推薦使用 <code>ANNOTATION</code> 檢測策略，僅曝露以注解 <code>@RepositoryRestResource</code> 顯式標注的倉庫。以下是Spring Data REST提供的四種倉庫檢測策略：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名穪</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEFAULT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有公共的倉庫但通過注解 <code>@RestResource</code> 和 <code>@RepositoryRestResource</code> 中的 <code>exported</code> 旗標顯式標記不曝露的倉庫除外。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ALL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">曝露所有倉庫，不考慮其可見性或被顯式標記為不曝露。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANNOTATED</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">僅曝露被注解 <code>@RestResource</code> 或 <code>@RepositoryRestResource</code> 標記的，且其 <code>exported</code> 旗標不為 <code>false</code> 的倉庫。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VISIBILITY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">僅曝露公共的且被注解標記的倉庫。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring Data REST的檢測策略可以通過聲明一個 <code>RepositoryRestConfigurer</code> Bean來自定義。</p>
</div>
<div class="paragraph">
<p>　.RepositoryRestConfig.java</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration <i class="conum" data-value="1"></i><b>(1)</b>
public class RepositoryRestConfig {

  @Bean <i class="conum" data-value="2"></i><b>(2)</b>
  public RepositoryRestConfigurer repositoryRestConfigurer() {

    return new RepositoryRestConfigurer() {

      @Override
      public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ANNOTATED); <i class="conum" data-value="3"></i><b>(3)</b>
      }
    };
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@Configurition</code> 聲明該類為配置類。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在Spring上下文中聲明個類型為 <code>RepositoryRestConfigurer</code> 的Bean。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>構造一個子類，並覆寫方法 <code>configureRepositoryRestConfiguration</code> ，自定義倉庫檢測策略為 <code>ANNOTATED</code> 。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">ProductImageRepository.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RepositoryRestResource(collectionResourceRel = "productImages", path = "productImages") <i class="conum" data-value="1"></i><b>(1)</b>
public interface ProductImageRepository extends MongoRepository&lt;ProductImage, String&gt; {

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用注解 <code>org.springframework.data.rest.core.annotation.RepositoryRestResource</code> 宣告 <code>ProductImageRepository</code> 的數據訪問方法需被曝露為RESTFul Web服務。RESTFul Web服務是以資源為中心的， <code>ProductImageRepository</code> 所專屬於的領域模型 <code>ProductImage</code> 就對應為RESTFul中的資源。 <code>@RepositoryRestResource</code> 允許應用闕發者自定義模型所對應資源名穪。本例中，資源的名穪為`product`。</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="測試">測試</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一個典型的軟件測試金字塔自下而上為：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>單元測測「Unit Test」</p>
</li>
<li>
<p>集成測試「Integration Test」</p>
</li>
<li>
<p>應用編程接口測試「API Test」</p>
</li>
<li>
<p>功能測試「Function Test」</p>
</li>
<li>
<p>性能測試「Performance Test」</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>單元測試是一種以單個代碼單元（在Java中就是類）為測試目標的測試方法。</p>
</div>
<div class="paragraph">
<p>我們應權衡考慮測試的覆盖度和編寫維護測試代碼的工作量。鍳於我們的應用大量使用第三框架，應用開發者編寫的代碼實際上很少，且是RESTFul的Web服務。所以跳過單元測試和集成測試，僅做應用編程接口測試是比較合適的。</p>
</div>
<div class="sect2">
<h3 id="應用編程接口測試api-test">應用編程接口測試「API Test」</h3>
<div class="paragraph">
<p>Spring Test提供了Spring MVC Test框架，其為Spring MVC代碼測試提供了流暢的API，應用開發者可以方便等將其與JUnit、TestNG或其它測試框架集成。</p>
</div>
<div class="paragraph">
<p>本例中，我們集成JUnit和Spring MVC Test框架，實現應用編程接口測試。</p>
</div>
<div class="paragraph">
<p>以測試創建和讀取單個Product為例。首先，創建測試目標及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductTest {

  private static final String ENDPOINT = "/products";

  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>

  ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring擴展的JUnit Runner <code>org.springframework.test.context.junit4.SpringRunner</code> 。 <code>SpringRunner</code> 會初始化Spring上下文，從而可以在測試代碼中使用依賴注入、模組掃描等Spring特性。默認的JUnit Runner並不會初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 聲明測試用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置類，這點我們使用生產代碼相同的應用入口類配置測試上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 聲明配置MockMvc，然後就可以在測試代碼中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入ObjectMapper。MockMvc是以包裝了HTTP請求和响應的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式與DispatcherServlet通信的，所以需要構造和解析JSON格式的請求體和响應體。在測試代碼中使用與被測試代碼相同皂JSON序列化和反序列化實現可以避免編解碼不一致的麻煩。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入 <code>ProductImageRepository</code> 。在領域模型中，Product關聯ProductImage，所以有些測試用例需要預置ProductImage數據。直接使用 <code>ProductImageRepository</code> 是最直接簡單的預置ProductImage數據的方法。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，預置ProductImage數據。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
  @Before <i class="conum" data-value="1"></i><b>(1)</b>
  public void setUp() {
    ProductImage imageA = new ProductImage(); <i class="conum" data-value="2"></i><b>(2)</b>
    imageA.setSrc("https://aaa.bbb.ccc/ddd.png");
    imageA.setCreatedAt(new Date());
    imageA.setUpdatedAt(new Date());

    imageAId = imageRepository.save(imageA).getId(); <i class="conum" data-value="3"></i><b>(3)</b>

    ProductImage imageB = new ProductImage();
    imageB.setSrc("https://bbb.ccc.ddd/eee.png");
    imageB.setCreatedAt(new Date());
    imageB.setUpdatedAt(new Date());

    imageBId = imageRepository.save(imageB).getId();

    ProductImage imageC = new ProductImage();
    imageC.setSrc("https://ccc.ddd.eee/fff.png");
    imageC.setCreatedAt(new Date());
    imageC.setUpdatedAt(new Date());

    imageCId = imageRepository.save(imageC).getId();
  }
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.junit.Before</code> 聲明在執行每個測試方法之前都預置一遍數據。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>構造預置的 <code>ProductImage</code> 對象。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>調用 <code>ProductImageRepository</code> 方法，將預置 <code>ProductImage</code> 對象持久化至數據庫</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，通過MockMvc嚮測試目標發送模擬RESTFul HTTP請求並校驗响應。</p>
</div>
<div class="paragraph">
<p>Hypertexy Transfer Protocol (HTTP)是一種請求/嚮應架構的通信協議。其共定義了兩種消息包：請求包和嚮應包。請求包由請求行、標頭和消息體三部份構成，嚮應包由狀態行、標頭和消息體三部份構成。MockMvc提供了豐富的工具構造請求的各個部份，和校驗嚮應的各個部份。MockMVC是直接與DispatcherServlet交互的，所以其是構造和校驗 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 對象。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  final String imageALink = obtainLinkOfImage(imageAId);
  final String imageBLink = obtainLinkOfImage(imageBId);

  final String title = "New Product";
  final String ELECTRONICS = "Electronics";
  final String MOBILE = "Mobile";

  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="2"></i><b>(2)</b>
      .andExpect(jsonPath("$.title", is(title))) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", links(), requestFields(
          fieldWithPath("images").type(JsonFieldType.ARRAY)
              .description("links of referred ProductImage")),responseFields()))
      .andReturn().getResponse().getContentAsString();

  String productId = Stream
      .of(objectMapper.readTree(createResponse).at("/_links/self/href").asText().split("/"))
      .reduce((first, second) -&gt; second).orElse(null); <i class="conum" data-value="4"></i><b>(4)</b>

  mvc.perform(get(ENDPOINT + "/{id}", productId).accept(MediaType.APPLICATION_JSON)) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/getOne", links(),
          pathParameters(parameterWithName("id").description("catalog's id")), responseFields()));

  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的構造方法構造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法會從中構造請求實例並發送給DispatcherServlet模擬HTTP請求。（後續為了從測試中生成API文檔，我們會換用兼容的 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的構造器方法。 <code>RestDocumentationRequestBuilders</code> 構造方法僅添加了文檔描述功能，HTTP協議相關的部份，如HTTP頭、响應碼等，依舊與 <code>MockMvcRequestBuilders</code> 的構造器相同。）
<div class="paragraph">
<p><code>MockMvcRequestBuilders</code> 提供了對應HTTP協議中定義的九種請求方法中的八種構造方法。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/MockMvcRequestBuilders.png" alt="MockMvcRequestBuilders" width="493" height="244">
</div>
</div>
<div class="paragraph">
<p>可以發現所有的構造方法都是返回同類型的構造器 <code>MockHttpServletRequestBuilder</code> ，測試代碼在穫取到 <code>MockHttpServletRequestBuilder</code> 實例後，可以繼續設置請求。 <code>MockHttpServletRequestBuilder</code> 提供了很多方法以供設置HTTP請求，這𥚃僅羅列常用的，具體請參閱源代碼：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">方法</th>
<th class="tableblock halign-left valign-top">可設置HTTP請求內容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">accept(MediaType&#8230;&#8203; mediaTypes)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Accept`請求頭</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">contentType(MediaType mediaType)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`Content-Type`請求頭</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">content(byte[] content)
content(String content)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">請求體</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>MockMvc的perform方法從構造器中創建mock請求例發送給DispatcherServlet，並將DispatcherServlet的响應包裝成 <code>org.springframework.test.web.servlet.ResultActions</code> 。測試代碼可以通過 <code>ResultActions</code> 提供的 <code>andExpect</code> 方法校驗响應結果；通過 <code>andDo</code> 方法附加一些操作，如打印响應內容等；通過 <code>andReturn</code> 方法讀取响應內容以做進一步操作。
<div class="imageblock">
<div class="content">
<img src="images/ResultActions.png" alt="ResultActions" width="314" height="103">
</div>
</div>
<div class="paragraph">
<p>Spring MVC Test框架提供了豐富的ResultMatcher供應用開發者檢驗MVC响應的各個部份。所有這些ResultMatcher都通過 <code>org.springframework.test.web.servlet.result.MockMvcResultMatchers</code> 的構造方法穫取。 <code>StatusResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一個結果檢驗器，通過方法 <code>status()</code> 穫取，用於檢驗响應狀態碼。POST請求意在創建新的實體，在成功創建新實體後RESTFul Web服務應响應狀態碼 <code>200 Created</code> 。</p>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>JsonPathResultMatchers</code> 是由 <code>MockMvcResultMatchers</code> 提供的一個結果檢驗器，通過方法 <code>jsonPath(String expression, Matcher&lt;T&gt; matcher)</code> 穫取，用於檢驗JSON格式的响應體。 <code>JsonPathResultMatchers</code> 按JSON路徑表逹式從响應體解析出內容，再搭配Hamcrest的檢驗器就可以檢驗JSON格式响應體的任意部份。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>新創建Product實體的唯一標識是由MongoDB生成的，且以自身鏈接的一部份的形式在响應體中返回。（Hypermedia-Driven的RESTFul Web服務在展現實體內容的响應體中包含指hlvlhbr甚它實體或集合的鏈接，其中就包括指嚮自身的鏈接。RESTFul風格的資源URL形式為 <code>/&lt;resources&gt;/&lt;id&gt;</code> ，所以解析單一資源URL最後一部份就可以得到資源唯一標識。）通過 <code>ResultActions</code> 的 <code>andReturn</code> 方法穫取包含所有响應信息的對象，再從中讀取响應體，再從响應體中解析出自身鏈接，最後從自身鏈接中解析出新創建Product實體的唯一標識。
<div class="paragraph">
<p>Spring Data REST對實體內容的編碼遵循Hypertext Application Language（HAL）約定。按照HAL，表示實體的JSON中應包含object類型的屬性 <code>_links</code> ，而 <code>_links</code> 應包含一個名為 <code>self</code> 的object類型屬性， <code>self</code> 應包含名為 <code>href</code> 文本類型的屬性， <code>href</code> 即該實體的自身鏈接。JSON路徑 <code>/_links/self/href</code> 應能解析出實體的自身鏈接。創建Product實體响應體樣例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="json" class="language-json hljs">{
  "title" : "New Product",
  "tags" : [ "Electronics", "Mobile" ],
  "createdAt" : "2019-12-08T07:10:53.091+0000",
  "updatedAt" : "2019-12-08T07:10:53.091+0000",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "product" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a"
    },
    "images" : {
      "href" : "http://localhost:8080/products/5deca1fdeadafc1b0547bd3a/images"
    }
  }
}</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的 <code>get</code> 構造方法構造get請求構造器。MockMvc從中構造get請求實例並發送給DispatcherServlet。再使用Spring MVC Test框架提供的結果檢驗器檢驗結果。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它Product應用編程接口測試與此相似，這𥚃就不再贅述，請參閱源碼。</p>
</div>
</div>
<div class="sect2">
<h3 id="使用嵌入式mongodb-mock-mongodb">使用嵌入式MongoDB mock MongoDB</h3>
<div class="paragraph">
<p>我們的應用編程接口測試依賴運行的MongoDB服務，而可重復執行測試的一個重要特性是「不依賴外部資源或服務」。所以內嵌MongoDB服務是最佳解決方案。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">...
dependencies {
	...
	testImplementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo' <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在 <code>de.flapdoodle.embed.mongo</code> 引入Gradle的testImplementation範圍依賴。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>spring-boot-autoconfigure担供了嵌入式MongoDB支持，當 <code>de.flapdoodle.embed.mongo</code> 被添加到classpath， <code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration</code> 就會被激活，自動配置嵌入式MongoDB。</p>
</div>
<div class="listingblock">
<div class="title">EmbeddedMongoAutoConfiguration.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableConfigurationProperties({ MongoProperties.class, EmbeddedMongoProperties.class })
@AutoConfigureBefore(MongoAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongodStarter.class })
public class EmbeddedMongoAutoConfiguration {
  ...
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="productimage-api-test">ProductImage API Test</h4>
<div class="paragraph">
<p>首先，創建測試目標及MockMvc。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ActiveProfiles({"test"})
@RunWith(SpringRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@SpringBootTest(classes = CatalogApplication.class) <i class="conum" data-value="2"></i><b>(2)</b>
@AutoConfigureMockMvc <i class="conum" data-value="3"></i><b>(3)</b>
@AutoConfigureRestDocs
public class ProductImageTest {

  private static final String ENDPOINT = "/productImages";
  @Autowired
  private MockMvc mvc; <i class="conum" data-value="4"></i><b>(4)</b>
  @Autowired
  private ObjectMapper objectMapper; <i class="conum" data-value="5"></i><b>(5)</b>
  @Autowired
  private ProductImageRepository imageRepository; <i class="conum" data-value="6"></i><b>(6)</b>
  ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用JUnit注解 <code>org.junit.runner.RunWith</code> 指明使用Spring擴展的JUnit Runner <code>org.springframework.test.context.junit4,SpringRunner</code> 。 <code>SpringRunner</code> 會初始化Spring上下文，從而可以在測試中使用依賴注入、模組掃描等Spring特性。默認的JUnit Runner不會初始化Spring上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用注解 <code>org.springframework.boot.test.context.SpringBootTest</code> 聲明測試用Spring上下文。 <code>@SpringBootTest</code> 可以指定上下文配置類，這𥚃我們使用生產代碼相同的應用入口類配置測試上下文。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc</code> 聲明配置MockMvc，然後就可以在測試代碼中注入MockMvc Bean了。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入MockMvc。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用注解 <code>org.springframeowrk.beans.factory.annotation.Autowired</code> 聲明注入ObjectMapper。MockMvc是以包裝HTTP請求和响應的 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 的形式與DispatcherServlet通信的，所以需要構造和解析JSON格式的請求體和响戈人心土體。在測試代碼中使用與被測試代碼相同的JSON序列化和反序列化實現可以避免編解碼不一致的麻煩。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用注解 <code>org.springframework.beans.factory.annotation.Autowired</code> 聲明注入ProductImageRepository，用於在測試之後清理數據庫中的ProductImage數據，避免測試之間互相干擾。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，通過MockMvc嚮測試目標發送模擬RESTFul HTTP請求並檢驗响應。</p>
</div>
<div class="listingblock">
<div class="title">ProductImageTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testSaveAndGetOne() throws Exception {
  final String src = "https://aaa.bbb.ccc/ddd.png";
  ProductImage newImage = new ProductImage();
  newImage.setSrc(src);

  ArgumentCaptor&lt;String&gt; linkMatcher = ArgumentCaptor.forClass(String.class);
  String responseContent = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON) <i class="conum" data-value="1"></i><b>(1)</b>
          .content(objectMapper.writeValueAsString(newImage))) <i class="conum" data-value="2"></i><b>(2)</b>
      .andDo(print())
      .andExpect(status().isCreated()) <i class="conum" data-value="3"></i><b>(3)</b>
      .andExpect(content().contentTypeCompatibleWith(MediaType.APPLICATION_JSON)) <i class="conum" data-value="4"></i><b>(4)</b>
      .andExpect(jsonPath("$.src", is(src))) <i class="conum" data-value="5"></i><b>(5)</b>
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andDo(document("productImage/create",
          links(),
          requestFields(),
          responseFields(
              subsectionWithPath("_links").description("links to other resources"))))
      .andReturn().getResponse().getContentAsString();
  ...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 提供的構造方法構造 <code>MockHttpServletRequestBuilder</code> ，MockMvc的perform方法會從中構造請求實例並發送給DispatcherServlet模擬HTTP請求。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <code>objectMapper</code> 將 <code>ProductImage</code> 對象序列化成JSON格式的字符串，填充為請求的消息體。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>status()</code> 檢驗响應狀態碼。對應成功處理的創建請求，RESTFul Web服務應响應 <code>201 Created</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用 <code>content()</code> 檢驗响應頭 <code>Content-Type</code> 應為 <code>application/json</code> 或相容的其它媒體類型。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>jsonPath()</code> 檢驗响應消息體的各個部份。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>其它ProductImage應用編程接口測試與此類似，這𥚃就不贅述了，詳情請參閱源碼。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="api文檔">API文檔</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用Spring REST Docs，從應用編程接口測試中生成API文檔。</p>
</div>
<div class="paragraph">
<p>首先，引入Spring REST Docs及Asciidoctor依賴，並引入Asciidoctor插件。</p>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">plugins {
	...
	id 'org.asciidoctor.convert' version '1.5.3' <i class="conum" data-value="1"></i><b>(1)</b>
}
...
depedencies {
  asciidoctor 'org.springframework.restdocs:spring-restdocs-asciidoctor' <i class="conum" data-value="2"></i><b>(2)</b>
  ...
  testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc' <i class="conum" data-value="3"></i><b>(3)</b>
}
...
ext {
	snippetsDir = file('build/generated-snippets') <i class="conum" data-value="4"></i><b>(4)</b>
	...
}

test {
	outputs.dir snippetsDir <i class="conum" data-value="5"></i><b>(5)</b>
}

asciidoctor { <i class="conum" data-value="6"></i><b>(6)</b>
	inputs.dir snippetsDir
	dependsOn test
}
...
bootJar { <i class="conum" data-value="7"></i><b>(7)</b>
	dependsOn asciidoctor
	from ("${asciidoctor.outputDir}/html5") {
		into 'static/docs'
	}
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引入Asciidoctor的Gradle插件 <code>org.asciidoctor.convert</code> ，其會引入Gradle task <code>asciidoctor</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>將 <code>spring-restdocs-asciidoctor</code> 引入至Gradle的asciidoctor範圍依賴，asciidoctor範圍是Asciidoctor插入擴展的，僅對Asciidoctor插件起效。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>將 <code>spring-restdocs-mockmvc</code> 引入Gradle的 <code>testImplementation</code> 範圍依賴，版本由Spring Boot Gradle插入統一控制。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>聲明變量 <code>snippetsDir</code> 為Spring REST Docs輸出HTTP請求响應片斷的根目錄。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>設置測試任務的輸出目錄為 <code>snippetsDir</code> 。Spring REST Docs是做為測試的一部份被執行的，其輸出根目錄即測試的輸出相錄即 <code>snippetsDir</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>配置Gradle任務asciidoctor，將 <code>snippetsDir</code> 添加為輸入目錄，Asciidoc文檔就可以引用Spring REST Docs截取的HTTP請求响應片斷了；並該任務 <code>asciidoctor</code> 依賴任務 <code>test</code> ，因為任務 <code>asciidoctor</code> 所需的請求响應片斷是在任務 <code>test</code> 中產生的，所以任務 <code>asciidoctor</code> 必須在任務 <code>test</code> 之後執行。任務 <code>asciidoctor</code> 是由Asciidoctor插件提供的。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>配置Gradle任務 <code>bootJar</code>，使其依賴任務 <code>asciidoctor</code> ，並將經 <code>asciidoctor</code> 轉換後的HTML格式文檔打包至 <code>flatjar</code> 中，置於路徑 <code>static/docs</code> 。Spring Boot默認將 <code>static/docs</code> 下的內容以靜態文件的形式發佈至URL <code>/docs/</code> 。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然後，在測試中激活Spring REST Docs配置。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Import(RestDocsMockMvcConfiguration.class)
@RunWith(SpringRunner.class)
@SpringBootTest(classes = CatalogApplication.class)
@AutoConfigureMockMvc
@AutoConfigureRestDocs <i class="conum" data-value="1"></i><b>(1)</b>
public class ProductTest {
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用注解 <code>org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs</code> 激活Spring REST Docs自動配置。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，用 <code>org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders</code> 提供的mock請求構造方法替換 <code>org.springframework.test.web.servlet.request.MockMvcRequestBuilders</code> 的mock請求構造方法。 <code>RestDocumentationRequestBuilders</code> 構造方法返回與 <code>MockMvcRequestBuilders</code> 構造方法相同的 <code>MockHttpServletRequestBuilder</code> 。不同的是， <code>RestDocumentationRequestBuilders</code> 往 <code>MockHttpServletRequestBuilder</code> 中添加了請求屬性 <code>ATTRIBUTE_NAME_URL_TEMPLATE</code> ，使其可以從mock請求的URL模格中解析出實參。</p>
</div>
<div class="listingblock">
<div class="title">RestDocumentationRequestBuilders.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
public static MockHttpServletRequestBuilder get(String urlTemplate,
		Object... urlVariables) {
	return MockMvcRequestBuilders.get(urlTemplate, urlVariables).requestAttr(
			RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE, urlTemplate); <i class="conum" data-value="1"></i><b>(1)</b>
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>RestDocumentationRequestBuilders</code> 在每個接受URL模板的構造方法中都將URL模格注冊為請求屬性，以備 <code>PathParametersSnippet</code> 從穫取請求URL中的參數化部份，如資源唯一標識等。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">PathParametersSnippet.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private String extractUrlTemplate(Operation operation) {
	String urlTemplate = (String) operation.getAttributes()
			.get(RestDocumentationGenerator.ATTRIBUTE_NAME_URL_TEMPLATE); <i class="conum" data-value="1"></i><b>(1)</b>
	Assert.notNull(urlTemplate, "urlTemplate not found. If you are using MockMvc did "
			+ "you use RestDocumentationRequestBuilders to build the request?");
	return urlTemplate;
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>PathParametersSnippet</code> 從請求屬性中讀取URL模板。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再然後，在測試中截取請求响應片斷並注釋。</p>
</div>
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
@Test
public void testCreateAndGet() throws Exception {
  ...
  String createResponse = mvc.perform(
      post(ENDPOINT).accept(MediaType.APPLICATION_JSON).contentType(MediaType.APPLICATION_JSON)
          .content(String.format(
              "{\"title\":\"%s\",\"tags\":[\"%s\",\"%s\"],\"images\":[\"%s\",\"%s\"]}",
              title, ELECTRONICS, MOBILE, imageALink, imageBLink)))
      .andDo(print())
      .andExpect(status().isCreated())
      .andExpect(jsonPath("$.title", is(title)))
      .andExpect(jsonPath("$.createdAt", notNullValue()))
      .andExpect(jsonPath("$.updatedAt", notNullValue()))
      .andExpect(jsonPath("$._links.images", notNullValue()))
      .andDo(document("product/create", <i class="conum" data-value="1"></i><b>(1)</b>
              links(), <i class="conum" data-value="2"></i><b>(2)</b>
              requestFields( <i class="conum" data-value="3"></i><b>(3)</b>
                fieldWithPath("images").type(JsonFieldType.ARRAY)
                  .description("links of referred ProductImage")),
              responseFields())) <i class="conum" data-value="4"></i><b>(4)</b>
      .andReturn().getResponse().getContentAsString();
...
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document(String identifier, Snippet&#8230;&#8203; snippets)</code> 方法構造一個 <code>org.springframework.restdocs.mockmvc.RestDocumentationResultHandler</code> 實例。 <code>RestDocumentationResultHandler</code> 實現了接口 <code>org.springframework.test.web.servlet.ResultHandler</code> ，可以作為 <code>org.springframework.test.web.servlet.ResultActions.andDo(ResultHandler handler)</code> 的參數，完美地嵌入MockMvc測試。
<div class="olist arabic">
<ol class="arabic">
<li>
<p>參數 <code>identitifer</code> 指明截取片斷的輸出住置。 <code>document("product/create"</code> 將把該測試過程中截取的片斷輸出至 <code>$snippetsDir/product/create</code> 。</p>
</li>
<li>
<p><code>document</code> 接受零至多個Snippet。</p>
</li>
</ol>
</div></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>構造專用於Hypermedia的 <code>org.springframework.restdocs.hypermedia.LinksSnippet</code> 。本例為了在多個測試中重用 <code>Product</code> 的 <code>LinksSnippet</code> ，而使用自定義構造方法構造 <code>Product</code> 的 <code>LinksSnippet</code>。
<div class="listingblock">
<div class="title">ProductTest</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static LinksSnippet links(LinkDescriptor... descriptors) {
  return HypermediaDocumentation.links(halLinks(), linkWithRel("self").description("self link"),
      linkWithRel("product").description("self link"),
      linkWithRel("images").description("related images")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>RESTFul Web服務是以資源為中心的，Hypermedia-Driven RESTFul Web服務當然依舊是以資源為中心的，資源實例的結構是相對穏定的。再加上HAL定義了一些通用的鏈接，所以 <code>Product</code> 的鏈接結構在任何場景下都是相同的。所以我們就可以使用同一構造方法為不同場景構造 <code>LinksSnippet</code> 。 <code>LinksSnippet</code> 由一系列的 <code>org.springframework.restdocs,hypermedia.LinkDescriptor</code> 組成，每一個 <code>LinkDescriptor</code> 截取和注釋一個鏈接。上述 <code>LinksSnippet</code> 截取的片斷樣例（asciidoc格式的，且包含了注釋）：</p>
</div>
<div class="listingblock">
<div class="title">links.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Relation|Description

|`+self+`
|self link

|`+product+`
|self link

|`+images+`
|related images

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Relation</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>self</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>product</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">self link</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">related images</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>構造 <code>org.springframework.restdocs.payload.RequestFieldsSnippet</code> ，以截取和注釋請求消息體。因同一類資源在不同場景下結構相同，所以這𥚃也通過自定義構造方法重用請求消息體 <code>Snippet</code>。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static RequestFieldsSnippet requestFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.requestFields(
    fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp").optional()
          .ignored(),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp").optional()
          .ignored()).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RequestFieldsSnippets</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 組成，每個 <code>FieldDescriptor</code> 截取和注釋請求消息體的一部份。上述 <code>RequestFieldsSnippet</code> 截取的片斷樣例（asciidoc格式且包含注釋）：</p>
</div>
<div class="listingblock">
<div class="title">request-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog's title

|`+tags+`
|`+Array+`
|tags

|`+images+`
|`+Array+`
|links of referred ProductImage

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog&#8217;s title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>images</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links of referred ProductImage</p></td>
</tr>
</tbody>
</table></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>構造 <code>org.springframework.restdocs.payload.ResponseFieldsSnippet</code> 截取和注釋响應消息體。這𥚃依舊通過自定構造方法重用响應消息體 <code>Snippet</code> 。
<div class="listingblock">
<div class="title">ProductTest.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">...
private static ResponseFieldsSnippet responseFields(FieldDescriptor... descriptors) {
  return PayloadDocumentation.responseFields(
      fieldWithPath("title").type(JsonFieldType.STRING).description("catalog's title"),
      fieldWithPath("tags").type(JsonFieldType.ARRAY).description("tags"),
      fieldWithPath("createdAt").type("Date").description("create timestamp"),
      fieldWithPath("updatedAt").type("Date").description("last update timestamp"),
      subsectionWithPath("_links").description("links to other resources")).and(descriptors);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ResponseFieldsSnippet</code> 由一系列 <code>org.springframework.restdocs.payload.FieldDescriptor</code> 組成。每個 <code>FieldDescriptor</code> 截取和注釋响應消息體的一部份。上述 <code>ResponseFieldSnippet</code> 截取的片斷樣例（asciidoc格式且包含注釋）：</p>
</div>
<div class="listingblock">
<div class="title">response-fields.adoc</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="asciidoc" class="language-asciidoc hljs">|===
|Path|Type|Description

|`+title+`
|`+String+`
|catalog's title

|`+tags+`
|`+Array+`
|tags

|`+createdAt+`
|`+Date+`
|create timestamp

|`+updatedAt+`
|`+Date+`
|last update timestamp

|`+_links+`
|`+Object+`
|links to other resources

|===</code></pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後為：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>title</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">catalog&#8217;s title</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tags</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Array</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>createdAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">create timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>updatedAt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Date</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">last update timestamp</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_links</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Object</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">links to other resources</p></td>
</tr>
</tbody>
</table></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最後，編寫asciidoc文檔並在其中引用截取的片斷。</p>
</div>
<div class="listingblock">
<div class="title">product.adoc</div>
<div class="content">
<pre>== Create

Endpoint `products`.

=== Request

include::{snippets}/product/create/http-request.adoc[]

*Request Fields:*

include::{snippets}/product/create/request-fields.adoc[]

=== Response

include::{snippets}/product/create/http-response.adoc[]

*Response Fields:*

include::{snippets}/product/create/response-fields.adoc[]</pre>
</div>
</div>
<div class="paragraph">
<p>經Asciidoctor渲染後的樣例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spring-rest-docs-product-example.png" alt="spring rest docs product example">
</div>
</div>
<div class="paragraph">
<p>其它API文檔生成方式與此相同，這𥚃就不再贅述，請參閱源碼。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="總結">總結</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章我們使用Spring Data REST從Spring Data倉庫上創建領域模型 <code>Product</code> 和 <code>ProductImage</code> 的Hypermedia-Driven RESTFul Web服務，使用Spring Data MongoDB生成領域模型 <code>Product</code> 和 <code>ProductImage</code> 的MongoDB訪問倉庫實現，使用Spring MVC Test框架測試應用編程接口，使用Spring REST Docs從測試中生成準確、易讀的API文檔。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="參考">參考</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://docs.spring.io/spring-data/commons/docs/current/reference/html/">Spring Data Commons - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/">Spring Data MongoDB - Reference Documentation</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-data/rest/docs/current/reference/html/">Spring Data REST Reference Guide</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-restdocs/docs/current/reference/html5/">Spring REST Docs</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.0.1<br>
Last updated 2020-09-06 07:40:06 UTC
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>